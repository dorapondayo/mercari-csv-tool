<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>メルカリCSV生成ツール v5.1</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/encoding-japanese@2.0.0/encoding.min.js"></script>
  <style>
    .drag-over { border-color: #3b82f6 !important; background: #eff6ff !important; }
    /* 写真振り分けモード */
    .sorter-overlay { position:fixed; inset:0; background:#1a1a2e; z-index:300; display:flex; flex-direction:column; }
    .sorter-header { background:#16213e; padding:10px 20px; display:flex; justify-content:space-between; align-items:center; border-bottom:2px solid #0f3460; }
    .sorter-header h2 { color:#e94560; font-size:18px; font-weight:bold; }
    .sorter-stats { display:flex; gap:16px; font-size:14px; color:#eee; }
    .sorter-stat { background:#0f3460; padding:4px 12px; border-radius:16px; }
    .sorter-stat b { color:#e94560; }
    .sorter-toolbar { background:#16213e; padding:8px 16px; display:flex; gap:8px; align-items:center; border-bottom:1px solid #0f3460; flex-wrap:wrap; }
    .sorter-toolbar .sbtn { padding:6px 16px; border:none; border-radius:6px; cursor:pointer; font-size:13px; font-weight:600; transition:all 0.2s; }
    .sbtn-split { background:#e94560; color:#fff; } .sbtn-split:hover { background:#ff6b81; }
    .sbtn-undo { background:#444; color:#ddd; } .sbtn-undo:hover { background:#555; }
    .sbtn-done { background:#28a745; color:#fff; font-size:15px; padding:8px 24px; } .sbtn-done:hover { background:#34d058; }
    .sbtn-done:disabled { background:#555; cursor:not-allowed; }
    .sbtn-cancel { background:#666; color:#fff; } .sbtn-cancel:hover { background:#777; }
    .sorter-grid { flex:1; overflow-y:auto; padding:10px; display:flex; flex-wrap:wrap; gap:6px; align-content:flex-start; }
    .sorter-item { width:120px; height:120px; position:relative; cursor:pointer; border-radius:6px; overflow:hidden; border:3px solid transparent; background:#222; user-select:none; transition:border-color 0.15s; }
    .sorter-item img { width:100%; height:100%; object-fit:cover; pointer-events:none; }
    .sorter-item.s-selected { border-color:#00bfff; }
    .sorter-item.s-split { border-color:#e94560; }
    .sorter-item.s-split::after { content:"✂"; position:absolute; top:2px; right:4px; background:#e94560; color:#fff; font-size:12px; padding:2px 6px; border-radius:4px; pointer-events:none; }
    .sorter-item .s-label { position:absolute; bottom:0; left:0; right:0; background:rgba(0,0,0,0.7); font-size:9px; text-align:center; padding:2px; color:#ccc; pointer-events:none; }
    .sorter-divider { width:100%; padding:4px 10px; background:#e94560; color:#fff; font-weight:bold; font-size:13px; border-radius:4px; margin:4px 0; display:flex; justify-content:space-between; }
    .sorter-sidebar { width:180px; background:#16213e; overflow-y:auto; border-right:1px solid #0f3460; flex-shrink:0; }
    .sorter-pc-item { padding:8px 12px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; color:#eee; font-size:13px; transition:background 0.2s; }
    .sorter-pc-item:hover { background:#1a1a40; }
    .sorter-pc-item.s-active { background:#0f3460; border-left:3px solid #e94560; }
    .sorter-preview { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:400; justify-content:center; align-items:center; cursor:pointer; }
    .sorter-preview.active { display:flex; }
    .sorter-preview img { max-width:90%; max-height:90%; object-fit:contain; }
    .sorter-keys { font-size:12px; color:#888; margin-left:auto; }
    .sorter-keys kbd { background:#333; padding:2px 6px; border-radius:4px; border:1px solid #555; font-family:monospace; color:#ddd; }
    
    /* ===== v5.1 UI Overhaul (CSS only) ===== */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');
    body { font-family: 'Noto Sans JP', sans-serif !important; background: #f0f2f5; margin: 0; }
    
    /* Step2全体のコンテナを全幅に */
    #root > div { max-width: 100% !important; }
    .max-w-6xl { max-width: 100% !important; padding: 0 4px !important; }
    
    /* ステータスバー */
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 {
      background: linear-gradient(135deg, #1e293b 0%, #334155 100%) !important;
      color: #e2e8f0 !important; border-radius: 0 !important; margin: 0 -4px 8px !important;
      padding: 8px 16px !important; box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
      position: sticky; top: 0; z-index: 50;
    }
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 b { color: #60a5fa; }
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 span { color: #94a3b8; }
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 .text-purple-600 { color: #a78bfa !important; }
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 .text-orange-500 { color: #fb923c !important; }
    .bg-white.rounded.shadow.p-3.mb-4.flex.gap-6 .text-gray-400 { color: #64748b !important; }
    
    /* 商品リスト（左パネル）ダーク化 */
    .w-40.border-r.bg-gray-50 {
      background: #1e293b !important; border-color: #334155 !important; color: #94a3b8 !important;
    }
    .w-40.border-r.bg-gray-50 .text-xs.text-gray-400 { color: #64748b !important; font-size: 10px !important; text-transform: uppercase; letter-spacing: 0.05em; }
    .w-40.border-r.bg-gray-50 .bg-blue-500 { background: #334155 !important; border-left: 3px solid #3b82f6 !important; }
    .w-40.border-r.bg-gray-50 > div > div:hover { background: rgba(255,255,255,0.05); }
    
    /* プレビューエリア */
    .w-1\/2.bg-gray-900 { background: #0f172a !important; }
    .w-1\/2.bg-gray-900 .text-gray-600 { color: #475569 !important; }
    
    /* カテゴリバッジ鮮明化 */
    .bg-blue-500.text-white.text-xs.font-bold { background: #2563eb !important; }    /* MAIN */
    .bg-green-600.text-white.text-xs.font-bold { background: #16a34a !important; }   /* INFO */
    .bg-yellow-600.text-white.text-xs.font-bold { background: #ca8a04 !important; }  /* SPEC */
    .bg-cyan-500.text-white.text-xs.font-bold { background: #0891b2 !important; }    /* KEY */
    .bg-purple-500.text-white.text-xs.font-bold { background: #7c3aed !important; }  /* SIDE */
    .bg-gray-500.text-white.text-xs.font-bold { background: #6b7280 !important; }    /* OTHER */
    
    /* ボタン群整理 */
    .bg-purple-500.text-white.rounded.text-sm { font-weight: 600 !important; }
    .bg-indigo-500.text-white.rounded.text-sm { font-weight: 600 !important; }
    .bg-orange-500.text-white.rounded.text-sm { font-weight: 600 !important; }
    .bg-orange-600.text-white.rounded.text-sm { font-weight: 600 !important; }
    
    /* 画像カードのホバー効果 */
    .relative.group:hover { transform: translateY(-2px); transition: transform 0.15s; }
    .relative.group { transition: transform 0.15s; }
    
    /* メッセージバー */
    .bg-yellow-50.border.border-yellow-200 { border-radius: 6px !important; }
    .bg-green-50.border.border-green-200 { border-radius: 6px !important; }
    
    /* Step1 グリッドを4列に */
    .grid.grid-cols-2.lg\:grid-cols-5 { grid-template-columns: repeat(4, 1fr) !important; }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useCallback, useEffect } = React;

// 設定
const CONFIG = {
  category_macbook: '9taHgBE3YAkhXLEpvShiYc',
  category_windows: 'FUdk7W2MDA6tujBfXCjgr4',
  shipping_method: 3,        // 配送方法（3=らくらくメルカリ便）
  region: 'jp14',            // 発送元（jp14=神奈川県）
  shipping_days: 2,          // 発送日数（2=2~3日で発送）
  shipping_fee: 1,           // 配送料負担（1=送料込み）
  condition_map: {           // 商品の状態
    '新品、未使用': 1,
    '未使用に近い': 2,
    '目立った傷や汚れなし': 3,
    'やや傷や汚れあり': 4,
    '傷や汚れあり': 5,
    '全体的に状態が悪い': 6
  }
};

const CONDITION_MAP = {
  'A': 2, 'B': 3, 'C': 3, 'D': 4, 'Z': 6
};
const CONDITION_LABELS = {
  1: '新品、未使用', 2: '未使用に近い', 3: '目立った傷や汚れなし',
  4: 'やや傷や汚れあり', 5: '傷や汚れあり', 6: '全体的に状態が悪い'
};

const ACCESSORY_MAP = {
  '電源ｺｰﾄﾞ': 'ACコード', 'ACｺｰﾄﾞ': 'ACコード', 'ACコード': 'ACコード',
  'ACｱﾀﾞﾌﾟﾀ': 'ACアダプター', 'ACｱﾀﾞﾌﾟﾀｰ': 'ACアダプター', 'ACアダプター': 'ACアダプター',
  'MagSafeケーブル': 'MagSafeケーブル', 'USB-C-Cケーブル': 'USB-Cケーブル',
  'ACプラグ': 'ACプラグ', 'ﾏｳｽ': 'マウス', 'ｷｰﾎﾞｰﾄﾞ': 'キーボード'
};
const ACCESSORY_EXCLUDE = ['ﾊﾞｯﾃﾘﾊﾟｯｸ', 'Webｶﾒﾗ有', '英字KB', 'TV機能'];

const DEFAULT_NOTICE_TEXT = `※ 実際の商品画像です。
※ スペックや状態の詳細は画像からご確認ください。
※ 中古品のため、使用に差し支えない傷や汚れがある場合があります。必ず写真をご確認ください。

■ 初期不良について
出荷日から7日以内にご連絡いただいた初期不良（電源が入らない、画面が映らないなど）については、当店にて動作確認の上、無償で交換または修理対応を行います。
・対象期間：出荷日から7日間
・送料：往復すべて当店負担

■ 保証対象外
以下の場合は保証・返品の対象外です。
・お客様の過失による故障・破損（水濡れ・落下・衝撃・誤接続など）
・分解・改造によるトラブル
・お客様ご自身によるOS再インストール後のトラブル
・ソフトウェアの不具合、対応しないゲーム等との相性問題
・動作に影響しない軽微な外観上の傷や汚れ
・動作に影響しないUSBポート・Type-Cポートの不良
・動作に影響しないカードリーダー・オーディオ端子等の不良
・バッテリーの劣化・消耗（ノートPCの場合）
・その他、PC動作に影響のない微細な不具合
※商品説明に動作確認済みと記載されている機能は保証対象です。
※「分解・改造」について：当店からの指示なく内部パーツへの作業を行った場合は保証対象外となります。不具合が発生した場合は、まず当店へご連絡ください。

■ 返送について
・初期不良の場合：送料は往復すべて当店負担です。
・初期不良以外の保証適用・返品の場合：送料はお客様負担（元払い）となります。

■ 不具合のご連絡について
不具合の具体的な症状・発生状況・写真または動画をご提供ください。
情報をご提供いただけない場合は、対応をお断りすることがあります。`;

// ユーティリティ
const normalizeMemory = (v) => {
  if (!v) return '';
  const str = String(v).toUpperCase();
  // MB表記の場合はGBに変換
  const mbMatch = str.match(/(\d+)\s*(MB|M)/i);
  if (mbMatch) {
    const mb = parseInt(mbMatch[1]);
    return `${Math.round(mb / 1024)}GB`;
  }
  // GB表記
  const gbMatch = str.match(/(\d+)\s*(GB|G)?/i);
  if (gbMatch) {
    const n = parseInt(gbMatch[1]);
    // 1000以上はMBの可能性が高い
    if (n >= 1000) return `${Math.round(n / 1024)}GB`;
    return `${n}GB`;
  }
  return v;
};

const normalizeStorage = (v) => {
  if (!v) return '';
  const str = String(v).trim();
  // SSD:256GB+HDD:1TB 形式の複数ストレージ対応
  if (str.includes('+')) {
    const parts = str.split('+').map(p => normalizeStorage(p.trim())).filter(Boolean);
    return parts.join(' + ') || str;
  }
  // SSD:256GB, HDD:1TB, NVMe:512GB 形式
  const typed = str.match(/^(SSD|HDD|NVMe|SATA)[:\s]*(\d+)\s*(G|GB|T|TB)?/i);
  if (typed) {
    const type = typed[1].toUpperCase() === 'NVME' ? 'SSD' : typed[1].toUpperCase();
    const n = parseInt(typed[2]);
    const u = (typed[3] || '').toUpperCase();
    const size = (u === 'T' || u === 'TB' || n <= 4) ? `${n}TB` : (roundStorage(n) >= 1024 ? `${roundStorage(n)/1024}TB` : `${roundStorage(n)}GB`);
    return `${size} ${type}`;
  }
  // 欠品等
  if (/欠品/.test(str)) return '';
  // 単純な数値+単位
  const m = str.match(/(\d+)\s*(G|GB|T|TB)?/i);
  if (m) {
    const n = parseInt(m[1]);
    const u = (m[2] || '').toUpperCase();
    if (u === 'T' || u === 'TB' || n <= 4) return `${n}TB`;
    const rounded = roundStorage(n);
    return rounded >= 1024 ? `${rounded/1024}TB SSD` : `${rounded}GB SSD`;
  }
  return v;
};
// OS表示容量→実際のSSD容量に丸める（238→256, 477→512, 953→1024 etc）
const roundStorage = (n) => {
  if (n <= 34) return 32;
  if (n <= 68) return 64;
  if (n <= 135) return 128;
  if (n <= 270) return 256;
  if (n <= 540) return 512;
  if (n <= 1080) return 1024;
  if (n <= 2160) return 2048;
  return n;
};

// EMC番号からMac情報を取得するマッピング
const EMC_MAP = {
  // MacBook Pro 16"
  '3347': { size: '16', year: '2019' },
  '3651': { size: '16', year: '2021' },
  '4044': { size: '16', year: '2023' },
  // MacBook Pro 15"
  '3215': { size: '15', year: '2018' },
  '3162': { size: '15', year: '2017' },
  '3163': { size: '15', year: '2017' },
  '3072': { size: '15', year: '2016' },
  // MacBook Pro 14"
  '3598': { size: '14', year: '2021' },
  '4046': { size: '14', year: '2023' },
  // MacBook Pro 13"
  '3301': { size: '13', year: '2019' },
  '3214': { size: '13', year: '2018' },
  '3164': { size: '13', year: '2017' },
  '3071': { size: '13', year: '2016' },
  '3358': { size: '13', year: '2020' },
  '3578': { size: '13', year: '2020' }, // M1
  // MacBook Air 13"
  '3348': { size: '13', year: '2020' },
  '3598': { size: '13', year: '2020' }, // M1
  '3941': { size: '13', year: '2022' }, // M2
  // MacBook Air 15"
  '4043': { size: '15', year: '2023' },
};

// CPU名を人間が読みやすい形に変換
const cleanCpu = (cpu) => {
  if (!cpu) return '';
  let c = cpu;
  // クアッドコア / デュアルコア / 6コア 等の日本語コア数を除去
  c = c.replace(/クアッドコア\s*/g, '');
  c = c.replace(/デュアルコア\s*/g, '');
  c = c.replace(/\d+コア\s*/g, '');
  // 11th Gen / 12th Gen / 13th Gen 等を除去
  c = c.replace(/\d+(st|nd|rd|th)\s*Gen\s*/gi, '');
  // Intel(R) Core(TM) i5-10310U CPU @ 1.70GHz → Core i5-10310U
  c = c.replace(/Intel\s*\(R\)\s*Core\s*\(TM\)\s*/gi, 'Core ');
  c = c.replace(/Intel\s*Core\s*/gi, 'Core ');
  c = c.replace(/AMD\s+/gi, '');
  c = c.replace(/\s*CPU\s*@?\s*/gi, ' ');
  c = c.replace(/-[\d.]+G(?=-|$)/g, '');
  c = c.replace(/\s*[\d.]+\s*GHz/i, '');
  c = c.replace(/-(\d\.\d)-/g, '-');
  // 末尾の @ を除去
  c = c.replace(/\s*@+\s*$/g, '');
  // PRO → Pro: Ryzen 5PRO-6650U → Ryzen 5 Pro 6650U
  c = c.replace(/(\d)\s*PRO\s*[-\s]*/gi, '$1 Pro ');
  // Ryz7-4750U → Ryzen 7 4750U
  c = c.replace(/^Ryz(\d)/i, 'Ryzen $1');
  c = c.replace(/^(Ryzen)(\d)/i, '$1 $2');
  c = c.replace(/^(Ryzen\s*\d(?:\s*Pro)?)\s*-\s*/i, '$1 ');
  c = c.replace(/^[CG]i(\d)/i, 'Core i$1');
  c = c.replace(/^Corei(\d)/i, 'Core i$1');
  c = c.replace(/^(Celeron)\s*-\s*/i, '$1 ');
  c = c.replace(/^(Pentium)\s*-\s*/i, '$1 ');
  c = c.replace(/^(Core\s*i\d)\s*-\s*/i, '$1 ');
  c = c.replace(/--+/g, '-').replace(/^-|-$/g, '');
  c = c.replace(/[\d.]+ GB/g, '').trim();
  // 先頭に @ が残ってたら除去
  c = c.replace(/^@\s*/, '');
  return c.trim();
};
const cleanCpuForTitle = cleanCpu;

// GPU名正規化: GA102 [GeForce RTX 3080 Ti] → GeForce RTX 3080 Ti
const cleanGpu = (gpu) => {
  if (!gpu) return '';
  // [括弧内] があればそれを使用（チップコード名除去）
  const bracket = gpu.match(/\[(.+?)\]/);
  let g = bracket ? bracket[1] : gpu;
  // Mobile / Laptop GPU 除去
  g = g.replace(/\s*(Mobile|Laptop GPU)/gi, '');
  return g.trim();
};

// メーカー名正規化
const normalizeMaker = (m) => {
  if (!m) return '';
  const map = {
    'lenovo': 'Lenovo', 'LENOVO': 'Lenovo',
    'hp': 'HP', 'Hp': 'HP',
    'dell': 'DELL', 'Dell': 'DELL',
    'nec': 'NEC', 'Nec': 'NEC',
    'fujitsu': 'Fujitsu', 'FUJITSU': 'Fujitsu',
    'toshiba': 'TOSHIBA', 'Toshiba': 'TOSHIBA',
    'dynabook': 'dynabook', 'DYNABOOK': 'dynabook', 'Dynabook': 'dynabook',
    'vaio': 'VAIO', 'Vaio': 'VAIO',
    'apple': 'Apple', 'APPLE': 'Apple',
    'panasonic': 'Panasonic', 'PANASONIC': 'Panasonic',
    'mouse computer': 'mouse', 'MOUSE COMPUTER': 'mouse',
    'microsoft': 'Microsoft', 'MICROSOFT': 'Microsoft',
    'asus': 'ASUS', 'Asus': 'ASUS',
    'acer': 'Acer', 'ACER': 'Acer',
  };
  return map[m] || map[m.toLowerCase()] || m;
};

// 解決名からメーカー名を分離: "Fujitsu LIFEBOOK UH90" → {maker:"Fujitsu", name:"LIFEBOOK UH90"}
const splitMakerFromName = (resolved) => {
  if (!resolved) return { maker: '', name: '' };
  const makers = ['Fujitsu', 'NEC', 'dynabook', 'TOSHIBA', 'Lenovo', 'HP', 'DELL', 'Dell', 'VAIO', 'mouse', 'Apple', 'Panasonic', 'ASUS', 'Acer', 'Microsoft'];
  for (const mk of makers) {
    if (resolved.startsWith(mk + ' ')) {
      return { maker: mk, name: resolved.slice(mk.length + 1).trim() };
    }
  }
  // case insensitive
  const lower = resolved.toLowerCase();
  for (const mk of makers) {
    if (lower.startsWith(mk.toLowerCase() + ' ')) {
      return { maker: mk, name: resolved.slice(mk.length + 1).trim() };
    }
  }
  return { maker: '', name: resolved };
};

// 型番クリーニング: Win10/W10/11DG等のOS情報・余計なサフィックスを除去
const cleanModelName = (name) => {
  if (!name) return '';
  let n = name;
  // 括弧内の:Win10, :W10, :11DG 等を除去
  n = n.replace(/[:：](Win\d*\s*\d*P?|W\d+|11DG|10DG)\b/gi, '');
  // 末尾の空括弧を除去
  n = n.replace(/\(\s*\)$/g, '');
  // Intel(R) Core(TM)... がモデル名に入ってしまった場合は空に
  if (/^Intel\s*\(R\)/i.test(n)) return '';
  // DESKTOP-xxxxx（Windows PC名）除去
  n = n.replace(/\bDESKTOP-[A-Z0-9]+\??\b/gi, '').trim();
  // 半角カナゴミ除去
  n = n.replace(/[\uFF61-\uFF9F_]+/g, '').trim();
  // AI文章混入（日本語の助詞が複数含まれる場合は除去）
  if (/[はがをのでに]{2,}/.test(n) || (n.includes('シリーズ') && n.includes('型番'))) return '';
  // 連結された型番にスペース挿入: ThinkPadX13Gen1 → ThinkPad X13 Gen1
  n = n.replace(/(ThinkPad|IdeaPad|EliteBook|ProBook|ZBook|Latitude|Inspiron|Vostro|LIFEBOOK|VersaPro|LaVie|dynabook|Satellite|Surface)([A-Z0-9])/g, '$1 $2');
  n = n.replace(/(\d)(Gen)/gi, '$1 $2'); // X13Gen1 → X13 Gen1
  n = n.replace(/([a-z])(\d{2,})/g, '$1 $2'); // 小文字+2桁以上数字 → スペース
  return n.trim();
};

const extractSpecs = (row) => {
  const s = { maker: '', product_name: '', cpu: '', memory: '', storage: '', display: '', gpu: '', model: '', size: '', year: '', chip: '' };
  if (!row) return s;
  
  s.maker = normalizeMaker(row['メーカー'] || '');
  const rawName = cleanModelName((row['商品名'] || '').replace(/\([^)]*\)/g, '').replace(/\(.*$/, '').trim());
  // 内部型番の場合はmodel_mapで解決
  if (isInternalCode(rawName)) {
    const resolved = resolveModelLocal(rawName);
    if (resolved) {
      // 解決名からメーカー名を分離（"Fujitsu LIFEBOOK UH90" → maker:Fujitsu, name:LIFEBOOK UH90）
      const { maker: resMaker, name: resName } = splitMakerFromName(resolved);
      s.product_name = resName || resolved;
      if (!s.maker && resMaker) s.maker = normalizeMaker(resMaker);
      s._resolved = true;
    } else {
      s.product_name = rawName;
      s._needsAI = true; // 後でAI解決が必要
      s._rawCode = rawName;
    }
  } else {
    s.product_name = rawName;
  }
  s.gpu = cleanGpu(row['GPU'] || '');
  
  // Mac情報抽出
  const name = row['商品名'] || '';
  const cpu = row['CPU'] || '';
  const makerLower = s.maker.toLowerCase();
  const nameLower = name.toLowerCase();
  
  if (makerLower.includes('apple') || nameLower.includes('mac')) {
    // EMC番号から情報取得
    const emcMatch = name.match(/EMC\s*(\d{4})/i);
    if (emcMatch && EMC_MAP[emcMatch[1]]) {
      const emcInfo = EMC_MAP[emcMatch[1]];
      s.size = emcInfo.size + 'インチ';
      s.year = emcInfo.year;
    }
    
    // model抽出（Pro/Air/mini/iMac）
    if (/macbook\s*pro|m-?book\s*pro/i.test(name)) {
      s.model = 'MacBook Pro';
    } else if (/macbook\s*air|m-?book\s*air/i.test(name)) {
      s.model = 'MacBook Air';
    } else if (/mac\s*mini/i.test(name)) {
      s.model = 'Mac mini';
    } else if (/imac/i.test(name)) {
      s.model = 'iMac';
    } else if (/mac\s*pro/i.test(name)) {
      s.model = 'Mac Pro';
    } else {
      s.model = 'MacBook';
    }
    
    // size抽出（EMCから取得済みでなければ）
    if (!s.size) {
      const nameForSize = name.replace(/\([^)]*\)/g, '');
      const sizeMatch = nameForSize.match(/(\d{2})[- ]?inch|(\d{2}(?:\.\d)?)[ｲイ]?ﾝ?ﾁ|(\d{2}(?:\.\d)?)インチ/i);
      if (sizeMatch) {
        s.size = (sizeMatch[1] || sizeMatch[2] || sizeMatch[3]) + 'インチ';
      }
    }
    
    // year抽出（EMCから取得済みでなければ）
    if (!s.year) {
      const yearMatch = name.match(/\b(20[12]\d)\b/);
      if (yearMatch) {
        s.year = yearMatch[1];
      }
    }
    
    // yearがなければCPU型番から推測
    if (!s.year && cpu) {
      // Ice Lake Mac用（1000NG4, 1030NG7など）
      if (/10[0-9]{2}NG/i.test(cpu)) {
        s.year = '2020';
      } else {
        // 第10世代以降（10xxx〜14xxx）
        let genMatch = cpu.match(/i[3579]-(1[0-4])\d{3}/i);
        if (genMatch) {
          const gen = parseInt(genMatch[1]);
          const yearMap = {10: '2020', 11: '2020', 12: '2021', 13: '2022', 14: '2023'};
          s.year = yearMap[gen] || '';
        } else {
          // 第4-9世代（4xxx〜9xxx）
          genMatch = cpu.match(/i[3579]-([4-9])\d{3}/i);
          if (genMatch) {
            const gen = parseInt(genMatch[1]);
            const yearMap = {4: '2013', 5: '2015', 6: '2016', 7: '2017', 8: '2018', 9: '2019'};
            s.year = yearMap[gen] || '';
          }
        }
      }
    }
    
    // chip抽出（M1/M2/M3/M4など、M1P=M1 Proなど短縮形も対応）
    const chipMatch = cpu.match(/\b(M[1-4](?:\s*(?:Pro|Max|Ultra))?)\b/i) || cpu.match(/\b(M[1-4]P)\b/i);
    if (chipMatch) {
      let chip = chipMatch[1];
      // 短縮形を展開
      chip = chip.replace(/^M(\d)P$/i, 'M$1 Pro');
      s.chip = chip;
    }
  }
  
  // 専用列があれば優先
  if (row['メモリ']) s.memory = normalizeMemory(row['メモリ']);
  if (row['ストレージ']) s.storage = normalizeStorage(row['ストレージ']);
  if (row['ディスプレイサイズ']) {
    const d = row['ディスプレイサイズ'].replace(/[ｲﾝﾁインチ型]/g, '').trim();
    if (d) s.display = `${d}インチ`;
  }
  
  // CPU列を解析
  if (cpu) {
    const p = cpu.split('/');
    s.cpu = cleanCpu(p[0]?.trim() || '');
    
    // CPU列からGPU抽出
    p.forEach(x => { if (/RTX|GTX|MX\d/i.test(x) && !s.gpu) s.gpu = cleanGpu(x.trim()); });
    
    // 専用列が空の場合、CPU列から抽出
    if (!s.memory && p[1]) s.memory = normalizeMemory(p[1].trim());
    if (!s.storage && p[2]) s.storage = normalizeStorage(p[2].trim());
    if (!s.display && p[3]) {
      const d = p[3].replace(/[ｲﾝﾁインチ型]/g, '').trim();
      if (d) s.display = `${d}インチ`;
    }
    
    // Mac用: sizeがまだ空ならCPU列から取得
    if (!s.size && p[3]) {
      const sizeFromCpu = p[3].match(/(\d{2}(?:\.\d)?)/);
      if (sizeFromCpu) s.size = sizeFromCpu[1] + 'インチ';
    }
  }
  
  return s;
};

const detectProductType = (row, specs) => {
  const m = (specs.maker || '').toLowerCase();
  const n = (row['商品名'] || '').toLowerCase();
  const c = row['CPU'] || '';
  if (m.includes('apple') || n.includes('mac')) {
    // M1/M2/M3/M4、またはM1P/M2Pなど短縮形
    return /\bM[1-4]\b|^M[1-4]P?\b/i.test(c) ? 'apple_silicon' : 'intel_mac';
  }
  return 'windows';
};

const parseAccessories = (str) => {
  if (!str) return [];
  const r = [];
  str.split(/[\s/]+/).forEach(p => {
    if (ACCESSORY_EXCLUDE.some(e => p.includes(e))) return;
    for (const [k, v] of Object.entries(ACCESSORY_MAP)) {
      if (p.includes(k) && !r.includes(v)) { r.push(v); break; }
    }
  });
  return r;
};

// ランクを日本語に変換
const RANK_DISPLAY = {
  'A': '美品',
  'B': '美品',
  'C': '良品',
  'D': '傷あり',
  'E': 'ジャンク'
};

// conditionからタイトル用ランクを決定
const conditionToRank = (p) => {
  if (p.isJunk) return 'ジャンク';
  // CSVランクがあればそれを使用
  if (p.rank && RANK_DISPLAY[p.rank]) return RANK_DISPLAY[p.rank];
  // なければconditionから判定
  const c = p.condition || 3;
  if (c <= 2) return '美品';
  if (c === 3) return '良品';
  if (c <= 5) return '傷あり';
  return 'ジャンク';
};

const makeTitle = (p) => {
  const s = p.specs || {};
  const t = p.product_type;
  const LIMIT = 65;
  // ジャンク品の場合は【ジャンク】のみ、通常は【ランク】【1週間保証】
  let prefix;
  if (p.isJunk) {
    prefix = '【ジャンク】';
  } else {
    const rankJp = conditionToRank(p);
    prefix = `【${rankJp}】【1週間保証】`;
  }
  
  if (t === 'intel_mac' || t === 'apple_silicon') {
    const parts = [];
    // サイズを短縮: "13.3インチ (2560 x 1600) Retina" → "13.3型"
    let sizeShort = '';
    const sizeStr = s.size || s.display || '';
    const sizeNum = sizeStr.match(/([\d.]+)\s*[ｲイ]?ﾝ?[ﾁチ]?/);
    if (sizeNum) sizeShort = sizeNum[1] + '型';
    parts.push(`${s.model || 'MacBook'}${sizeShort ? ' ' + sizeShort : ''}`.trim());
    if (s.year) parts.push(String(s.year));
    if (t === 'apple_silicon' && s.chip) parts.push(s.chip);
    else if (s.cpu) parts.push(cleanCpuForTitle(s.cpu));
    if (s.memory) parts.push(s.memory);
    if (s.storage) parts.push(s.storage.replace(/\s*(SSD|HDD|NVMe)/gi, ''));
    let title = prefix + parts.join(' / ');
    if (p.barcode) title += ' ' + p.barcode;
    return title.length > LIMIT ? title.slice(0, LIMIT - 3) + '...' : title;
  }
  
  // --- メーカー名クリーニング ---
  let maker = s.maker ? s.maker.replace('mouse computer', 'mouse') : '';
  maker = maker.replace(/\s*Corp\.?\s*/gi, '').trim();  // VAIO Corp. → VAIO
  maker = maker.replace(/\s*\(東芝系\)\s*/g, '').trim(); // (東芝系) 除去
  if (/^不明|^unknown|^表示なし/i.test(maker)) maker = '';
  
  // --- 型番クリーニング ---
  let model = s.product_name || '';
  // 括弧以降を除去（内部型番残り対策）
  model = model.replace(/\(.*$/, '').trim();
  // :Win 10P 等除去
  model = model.replace(/[:：]\s*(Win\d*\s*\d*P?|W\d+|11DG|10DG)\b/gi, '').trim();
  // DESKTOP-xxxxx（Windows PC名）除去
  model = model.replace(/\bDESKTOP-[A-Z0-9]+\??\b/gi, '').trim();
  // 半角カナゴミ除去（ｶﾝｲ_ 等）
  model = model.replace(/[\uFF61-\uFF9F_]+/g, '').trim();
  // AI文章混入検出（日本語の文章が混じってたら除去）
  if (/[はがをのでに、。]/.test(model) && model.length > 20) model = '';
  // 不明系
  if (/^不明|^unknown|^表示なし/i.test(model)) model = '';
  // 内部型番がまだ残っていたら除去
  if (model && isInternalCode(model)) model = '';
  // 内部型番コード + 正式名が連結されている場合: "FMVU26011 LIFEBOOK U939/C" → "LIFEBOOK U939/C"
  model = model.replace(/^[A-Z0-9]{6,15}\s+/i, (match) => {
    return isInternalCode(match.trim()) ? '' : match;
  }).trim();
  
  // メーカー名 + 型番をスペース区切り（重複排除）
  let namepart = maker;
  if (model && !model.toLowerCase().startsWith(maker.toLowerCase())) {
    namepart = `${maker} ${model}`.trim();
  } else if (model) {
    namepart = model;
  }
  
  // ストレージからSSD/HDD除去（タイトル用）
  const storForTitle = (s.storage || '').replace(/\s*(SSD|HDD|NVMe)/gi, '').trim();
  
  // フルスペック版
  const specFull = [];
  if (s.cpu) specFull.push(cleanCpuForTitle(s.cpu));
  if (s.memory) specFull.push(s.memory);
  if (storForTitle) specFull.push(storForTitle);
  if (s.gpu && /RTX|GTX|MX\d|Radeon|GeForce|Quadro/i.test(s.gpu)) specFull.push(s.gpu);
  
  // タイトル組み立て（65文字以内に収める）
  const bc = p.barcode ? ' ' + p.barcode : '';
  let title = prefix + (namepart ? namepart + ' / ' : '') + specFull.join(' / ') + bc;
  
  if (title.length <= LIMIT) return title;
  
  // 省略1: GPU削除
  const specNoGpu = specFull.filter(x => !/RTX|GTX|MX\d|Radeon|GeForce|Quadro/i.test(x));
  title = prefix + (namepart ? namepart + ' / ' : '') + specNoGpu.join(' / ') + bc;
  if (title.length <= LIMIT) return title;
  
  // 省略2: ストレージ削除
  const specMin = specNoGpu.filter(x => x !== storForTitle);
  title = prefix + (namepart ? namepart + ' / ' : '') + specMin.join(' / ') + bc;
  if (title.length <= LIMIT) return title;
  
  // 省略3: 型番省略、メーカー名のみ残す（ユーザー要求）
  const makerOnly = maker || namepart.split(/\s/)[0] || '';
  title = prefix + (makerOnly ? makerOnly + ' / ' : '') + specNoGpu.join(' / ') + bc;
  if (title.length <= LIMIT) return title;
  
  // 省略4: メーカー+CPU+メモリのみ
  const specUltraMin = specFull.filter(x => x === specFull[0] || x === specFull[1]).slice(0, 2);
  title = prefix + (makerOnly ? makerOnly + ' / ' : '') + specUltraMin.join(' / ') + bc;
  if (title.length <= LIMIT) return title;
  
  // 省略5: 強制切り詰め
  title = prefix + (makerOnly ? makerOnly + ' / ' : '') + specNoGpu.join(' / ') + bc;
  return title.slice(0, LIMIT - 3) + '...';
};

// ジャンク品用の状態テキスト
const JUNK_STATE_TEXT = `本商品はジャンク品のため、動作・状態・部品の欠品を一切保証しません。
起動不可・画面不良・異音・端子不良・バッテリー劣化・外装破損など、いかなる不具合でも返品・返金・交換不可となります。
修理・部品取り前提でご購入ください。`;

const makeDescription = (p, customNotice) => {
  const s = p.specs || {};
  const t = p.product_type;
  // 型番から「他 X台セット」と括弧以降を除去
  let modelClean = (s.product_name || '-').replace(/他?\s*\d+台[ｾセ][ｯッ][ﾄト]/g, '').replace(/\(.*$/, '').trim() || '-';
  if (isInternalCode(modelClean)) modelClean = '（型番不明）';
  const lines = [];
  if (t === 'intel_mac' || t === 'apple_silicon') {
    lines.push(`モデル：${s.model || 'MacBook'} ${s.year || ''}`);
    if (t === 'apple_silicon') lines.push(`チップ：Apple ${s.chip || ''}`);
    else lines.push(`CPU：${s.cpu || '-'}`);
    if (s.gpu && /RTX|GTX|MX\d|Radeon|GeForce|Quadro/i.test(s.gpu)) lines.push(`GPU：${s.gpu}`);
    lines.push(`メモリ：${s.memory || '-'}`, `ストレージ：${s.storage || '-'}`, `ディスプレイ：${s.size || '-'}`);
    if (p.cycle_count) lines.push(`充放電回数：${p.cycle_count}回`);
    if (p.battery_health) lines.push(`バッテリー最大容量：${p.battery_health}%`);
    lines.push(`初期設定パスワード：0000`);
  } else {
    lines.push(`メーカー：${s.maker || '-'}`, `型番：${modelClean}`, `CPU：${s.cpu || '-'}`);
    if (s.gpu && /RTX|GTX|MX\d|Radeon|GeForce|Quadro/i.test(s.gpu)) lines.push(`GPU：${s.gpu}`);
    lines.push(`メモリ：${s.memory || '-'}`, `ストレージ：${s.storage || '-'}`, `ディスプレイ：${s.display || '-'}`, 'OS：Windows 11');
    if (p.hasOffice) lines.push('Office：Microsoft Office2024(永続版)搭載\n⇒word,excel,PowerPoint等利用可能');
  }
  if (p.is_english_kb) lines.push('キーボード：英字配列');
  const spec = '【スペック】\n' + lines.join('\n');
  const acc = `【付属品】\n${(p.accessories || []).join('、')}`;
  // ジャンク品の場合は専用テキスト、通常はconditionNotesのみ（CSV瑕疵の生テキストは出さない）
  const stateContent = p.isJunk ? JUNK_STATE_TEXT : (p.conditionNotes || '使用に伴う多少のスレがあります。');
  const state = `【状態】\n${CONDITION_LABELS[p.condition] || 'やや傷や汚れあり'}\n${stateContent}\n※実際の商品写真を必ずご確認の上ご購入ください。細かな見落としがある場合がございます。`;
  // ジャンク品の場合はNOTICE_TEXTを省略
  const notice = p.isJunk ? '' : (customNotice || DEFAULT_NOTICE_TEXT);
  return `${p.barcode || ''}\n\n${p.intro || ''}\n\n${spec}\n\n${acc}\n\n${state}${notice ? '\n\n' + notice : ''}`;
};


// ===== 型番変換システム =====
const BASE_MODEL_MAP = {"A2337":"Apple MacBook Air (M1, 13-inch, 2020)","FMVWMU1N77":"Fujitsu LIFEBOOK WU1/M","A1708":"Apple MacBook Pro 13-inch Late 2016 (Two Thunderbolt 3 Ports)","81W1":"Lenovo IdeaPad S540 15API","SEL1030000001":"DELL Latitude 3500","SEL1030000003":"DELL Latitude 3510","SEL1030000004":"DELL Latitude 3510","SEL1030000005":"DELL Latitude 3510","SEL1030000006":"DELL Latitude 3510","SEL1030000007":"DELL Latitude 3510","SEL1030000008":"Dell Latitude 3510","SEL1030000009":"Dell Latitude 3510","SEL1030000002":"DELL Latitude 3500","A6B5DPF85A22":"dynabook B65/DP","A6B5DPF8BA22":"dynabook B65/DP","A6BCHSF8LA21":"dynabook B65/HS","A6BJFSG8B531":"dynabook BJ65/FS","A6BJFSG8K511":"dynabook BJ65/FS","A6BSERL8BA22":"dynabook B65/ER","A6BSERL8LA22":"dynabook B65/ER","PB45HNB11RAAD11":"dynabook B45/H","PB45JNB11RAAD11":"dynabook B45/J","PB65DBADCN7AD11":"dynabook B65/D","PB65MTB44N7AD11":"dynabook B65/M","PB6DNTB41N7BD1":"dynabook B65/DN","2RA41PA#ABJ":"HP ProBook 450 G3","2RA50PA#ABJ":"HP ProBook 450 G3","2RP80PA#ABJ":"HP ProBook 450 G3","3SG20PA#ABJ":"HP ProBook 450 G3","V6E11AV-ADVJ":"HP ProBook 450 G3","4RJ89PA#ABJ":"HP ProBook 450 G5","4RJ92PA#ABJ":"HP ProBook 450 G5","6VV57PA#ABJ":"HP ProBook 450 G5","6VV59P#ABJ":"HP ProBook 450 G5","6VV61PA#ABJ":"HP ProBook 450 G5","7RP23PA#ABJ":"HP ProBook 450 G6","20F93PA#ABJ":"HP ProBook 450 G7","6YY32AV-BHTT":"HP ProBook 450 G7","8WJ31PA#ABJ":"HP ProBook 450 G7","8WJ62PA#ABJ":"HP ProBook 450 G7","4D3Y0AV-AAYS":"HP ProBook 450 G9","7H139PA#ABJ":"HP ProBook 450 G9","3SX14PA-AAET":"HP EliteBook 850 G5","8LA84PA-AAAB":"HP ProBook 850 G6","PC-VK23TXZDU":"NEC VersaPro VK23/TX-D","PC-VK24MXZDX":"NEC VersaPro VK24/MX","PC-VKM17XZG2":"NEC VersaPro VKM17/X-G","PC-VKM17XZG4":"NEC VersaPro VKM17/X-4","PC-VKM17XZG9":"NEC VersaPro VKM17/X-9","PC-VKM44XZGA":"NEC VersaPro VKM44/X-3","PC-VKT16XZG3":"NEC VersaPro VKt16/XZG3","PC-VKT16XZG5":"NEC VersaPro VK16X/RG-5","PC-VKT16XZG7":"NEC VersaPro タイプVF PC-VKT16XZG7","Z15G:MOS1*":"Apple MacBook Pro 14-inch (M1 Max, 2021)","Z15J:MOS1*":"Apple MacBook Pro 14-inch (M1 Pro, 2021)","Z14Y":"Apple MacBook Pro 16-inch (2021, M1 Max)","Z14Y:MOS1*":"Apple MacBook Pro 16-inch (2021, M1 Max)","21105N-TGLABW11-H":"mouse DAIV 5N","20X2S8MG01":"Lenovo ThinkPad L14 Gen 2","20J9S0T500":"Lenovo ThinkPad L570","20LXS03M00":"Lenovo ThinkPad L580","20S1S1UJ2P":"Lenovo ThinkPad T14 Gen 1","20W1S30V24":"Lenovo ThinkPad T14 Gen 2","20W5S1FL28":"Lenovo ThinkPad T15 Gen 2","20KGSDDH00":"Lenovo ThinkPad X1 Carbon (6th Gen)","20KGS09500":"Lenovo ThinkPad X1 Carbon 2018","20XXSB7900":"Lenovo ThinkPad X1 Carbon Gen 9","A6G7FPF2D621":"dynabook G83/FP","G83FP:W10x64":"dynabook G83/FP","G83FP":"dynabook G83/FP","A6G7FPF3D621":"dynabook G83/FP","A6G7FRF2D511":"dynabook G83/FR","G83FR":"dynabook G83/FR","G83FR:W10x64":"dynabook G83/FR","A6G9HSF8D211":"dynabook G83/HS","A6G9HSF8D621":"dynabook G83/HS","G83HS:W10x64":"dynabook G83/HS","G83HS":"dynabook G83/H(S)","A6G9HSFAD621":"dynabook G83/HS","A6S7FRF2F611":"dynabook S73/FR","A6SBHUFAD615":"dynabook S73/HU","PG83MTJBGL7AD21":"dynabook G83/M","PR63HTA4347AD11":"dynabook R63/H","PR63MTC4447AD11":"dynabook R63/M","PR63UEAA547AD11":"dynabook R63/U","PR73BBAAC3CAD81":"dynabook R73/B","PR73JBA1447AD21":"dynabook R73/J","6VV64PA#ABJ":"HP ProBook 430 G5","5JC14AV-AAAA":"HP ProBook 430 G6","7RN98PA#ABJ":"HP ProBook 430 G6","7RP04PA#ABJ":"HP ProBook 430 G6","795P0AV-ACOR":"HP ProBook 630 G10","A9UN1PT#ABJ":"HP ProBook 630 G10","6X729PA#ABJ":"HP ProBook 630 G9","L4Q21AV-APCV":"HP EliteBook 820 G3","2UP88AV-AAFC":"HP EliteBook 830 G5","6J2V8PA#ABJ":"HP EliteBook 830 G8 Notebook PC","1A852PA#ABJ":"HP Elite Dragonfly G1","4UJ31PA-AAAG":"HP EliteBook x360 1030 G3","8RA45PA-AAAF":"HP EliteBook x360 1030 G4","PC-VK23LBZDU":"NEC VersaPro VK23/L","PC-VK25LCZDM":"NEC VersaPro VK25/L","PC-VKM16BZG5":"NEC VersaPro VKM16/BZG-5","PC-VKM17BZG4":"NEC VersaPro VKM17/B-4","VJPB111BCL2B":"VAIO Pro PB VJPB11","VJPF111D":"VAIO Pro PF VJPF111D","VJPG111":"VAIO Pro PG VJPG111","VJPG141":"VAIO Pro PG VJPG141","PG141":"VAIO Pro PG VJPG141","VJPJ111":"VAIO Pro PJ VJPJ11","Z160:MOS1*":"Apple MacBook Air 13-inch (M2, 2022)","TNV-00020":"Microsoft Surface Laptop Go","20WLSAVN00":"Lenovo ThinkPad X13 Gen 2","20VJS17X00":"Lenovo ThinkPad L13 Gen 2","20VJS17Y00":"Lenovo ThinkPad L13 Gen 2","21B4S0C700":"Lenovo ThinkPad L13 Gen 3","20M6S0BD00":"Lenovo ThinkPad L380","20NSS25A00":"Lenovo ThinkPad L390","20T3S86N00":"Lenovo ThinkPad X13 Gen 1","20WLS25Q00":"Lenovo ThinkPad X13 Gen 2","20HMS7C100":"Lenovo ThinkPad X270","20Q1S37F00":"Lenovo ThinkPad X390","20SDS0B500":"Lenovo ThinkPad X390","FMVU14003":"Fujitsu LIFEBOOK U938/S","FMVU24011":"Fujitsu LIFEBOOK U939/B","U939/B":"Fujitsu LIFEBOOK U939/B","FMVU26011":"Fujitsu LIFEBOOK U939/C","3AQ06AV-AAKY":"HP Z2 Mini G4 Workstation","3AQ06AV-AARR":"HP Z2 Mini G4 Workstation","XQC-3.4G-E2124G":"HP Z2 Mini G4 Workstation","3AQ06AV-AATL":"HP Z2 Mini G4 Workstation","X4C-3.4G-E2124G":"HP Z2 Mini G4 Workstation","3AQ06AV-ADLX":"HP Z2 Mini G4 Workstation","3AQ06AV-AENB":"HP Z2 Mini G4 Workstation","3AQ06AV-AFLI":"HP Z2 Mini G4 Workstation","3AQ06AV-AFOJ":"HP Z2 Mini G4 Workstation","5S1R1EC#ABJ":"HP ZBook 15 G8 Mobile Workstation","5S1R1EC#ACF":"HP ZBook 15 G8 Mobile Workstation","618A4EC#ABJ":"HP ZBook 15 G8 Mobile Workstation","6A3U9PA-AABM":"HP ZBook Power G9 Mobile Workstation","60U75PA-AAAA":"HP ZBook Studio G8 Mobile Workstation","20TJS53500":"Lenovo ThinkPad P1 Gen 3","20Y4S3D300":"Lenovo ThinkPad P1 Gen 4","21DDS0G100":"Lenovo ThinkPad P1 Gen 5","10DG":"Lenovo ThinkPad P51s","20LCS0B100":"Lenovo ThinkPad P52s","20N7S1R800":"Lenovo ThinkPad P53s","20YTS0A700":"Lenovo ThinkPad T15g Gen 2","FMVC07007":"Fujitsu FUTRO MU937","JST-00014":"Microsoft Surface Go 2","JST-00014:W10x64":"Microsoft Surface Go 2","PeG/4G/64G/10":"Microsoft Surface Go","TGF-00012":"Microsoft Surface Go 2","TGF-00012:W10x64":"Microsoft Surface Go 2","PeG-4425Y":"Microsoft Surface Go 2","FJU-00014":"Microsoft Surface Pro 4","LPZ-00014":"Microsoft Surface Pro 6","PVR-00014":"Microsoft Surface Pro 7 PVR-00014","1NA-00013":"Microsoft Surface Pro 7+","8PY-00039":"Microsoft Surface Pro 8","1AE80AV-AACD":"HP ProDesk 400 G3 DM","1AE80AV-ANRE":"HP ProDesk 400 G3 DM","2VG42AV-ADEC":"HP ProDesk 600 G4 SF","2VG42AV-ADFN":"HP ProDesk 600 G4 SF","2VG42AV-AFJZ":"HP ProDesk 600 G4 SF","6DX60AV-AACP":"HP ProDesk 600 G5 SF","6DX60AV-AACQ":"HP ProDesk 600 G5 SF","6DX60AV-ETTH":"HP ProDesk 600 G5 SF","6DX60AV-FACE":"HP ProDesk 600 G5 SF","6DX60AV-FALV":"HP ProDesk 600 G5 SF","3C6T1EC#ABJ":"HP ProDesk 600 G6 Desktop Mini","9AW71AV-AAAO":"HP ProDesk 600 G6 Small Form Factor","2YH15AV-AAAW":"HP ProDesk 800 G4 DM","2YH15AV-AAAX":"HP ProDesk 800 G4 DM","6AU21AV-AABU":"HP ProDesk 800 G5 DM","6BD61AV-AAAL":"HP EliteDesk 800 G5 Tower","8WY24AV-BCCS":"HP ProDesk 800 G6 DM","8YM57AV-EBAH":"HP ProDesk 800 G6 Small Form Factor","8YR01AV-AAIW":"HP EliteDesk 800 G6 Tower","550B5AV-AAAJ":"HP ProDesk 800 G9 Mini","W1011DG":"HP ProDesk 800 G9 Mini","4G087AV-AAAC":"HP ProDesk 800 G9 Small Form Factor","XQ-CT44":"Sony Xperia 1 IV","XQ-DC44":"Sony Xperia 10 V","XQ-DC44_Xperia":"Sony Xperia 10 V","XQ-CQ44_Xperia":"Sony Xperia 5 IV","GWL-00009":"Microsoft Surface Pro (5th Gen)","GWP-00009":"Microsoft Surface Pro (5th Gen)","GWL-00009(10P)":"Microsoft Surface Pro (5th Gen)","7010SF(7P)":"Dell OptiPlex 7010 Small Form Factor","10T8S5400G":"Lenovo ThinkCentre M720q Tiny","C8T89AV":"HP ProDesk 600 G1 Small Form Factor","QV985AV(7P)":"HP Compaq Pro 6300 Small Form Factor","Y5W43AV(10P)":"HP ProDesk 400 G4 SF","6DX60AV(10P)":"HP ProDesk 600 G5 SF","6DX60AV":"HP ProDesk 600 G5 SF","2VG42AV(10P)":"HP ProDesk 600 G4 SF","2VG42AV":"HP ProDesk 600 G4 SF","FMVD33001":"Fujitsu ESPRIMO D587/S","HMX-00012(10P)":"Microsoft Surface Book 2 13.5インチ Core i5/8GB/256GB (HMX-00012)","HMX-00012":"Microsoft Surface Book 2 13.5インチ Core i5/256GB モデル","20R4S24L00":"Lenovo ThinkPad L13 Gen 1","20R4S02900":"Lenovo ThinkPad L13 Gen 1","20T3S5TX00":"Lenovo ThinkPad X13 Gen 1","20Q8S0CC00":"Lenovo ThinkPad L590","20AUS3J600":"Lenovo ThinkPad L540","20AUS1AA00":"Lenovo ThinkPad L540","20AUS05800":"Lenovo ThinkPad L540","20UGS24L0G":"Lenovo ThinkPad X13 Gen 1","20UGS2GK00":"Lenovo ThinkPad X13 Gen 1","20J8S02H00":"Lenovo ThinkPad L570","20NKS0Q60Q":"Lenovo ThinkPad T495","20UES23S02":"Lenovo ThinkPad T14 Gen 1","2UP88AV(10P)":"HP EliteBook 830 G5","2UP88AV":"HP EliteBook 830 G5","2ZA83AV":"HP ProBook 450 G5/CT","2ZA83AV(10P)":"HP ProBook 450 G5","2ZA82AV(10P)":"HP ProBook 450 G5","2ZA82AV":"HP ProBook 450 G5","2ZA83AV-AACA":"HP ProBook 450 G5","2VX21AV(10P)":"HP ProBook 650 G4","2VX21AV":"HP ProBook 650 G4","V6E13AV":"HP ProBook 450 G3/CT","B4U96PA#ABJ":"HP ProBook 4530s/CT","K7X94AV":"HP ProBook 450 G2","G7H10PC":"HP ProBook 450 G1","A8G7FPF2D111":"dynabook G83/FP","PB6DNBB44R7FD1":"dynabook B65/DN","PB65MEA43F7AD21":"dynabook B65/M","PR7BNEA4347FC1":"dynabook R73/BN","PV832HAWE43A4X":"dynabook KIRA V832/H","A6G7FPF2D111":"dynabook G83/FP","A6S7FRF2D511":"dynabook S73/FR","PB6DNEA43F7FD1":"dynabook B65/DN","FMVU28011":"Fujitsu LIFEBOOK U9310/D","FMVU24001":"Fujitsu LIFEBOOK U939/B","FMVA26002":"Fujitsu LIFEBOOK A577/S","FMVA26002(10P)":"Fujitsu LIFEBOOK A577/S","FMVU14003(10P)":"Fujitsu LIFEBOOK U938/S","FMVS09001":"Fujitsu LIFEBOOK S937/S","FMVU14013":"Fujitsu LIFEBOOK U938/S","FMVC0700R":"Fujitsu FUTRO MU937 FMVC0700R","FMVU19013(10P)":"Fujitsu LIFEBOOK U939/A","FMVU19013":"Fujitsu LIFEBOOK U939/A","PC-VKT16GVG4":"NEC VersaPro タイプVG VKT16/GV-4","VKT16GVG4":"NEC VersaPro タイプVG VKT16/GV-4","CF-SZ6RFYVS(10P)":"Panasonic Let's note SZ6 CF-SZ6RFYVS","CF-SZ6RDYVS(10P)":"Panasonic Let’s note SZ6 CF-SZ6RDYVS","CF-SZ6R(10P)":"Panasonic Let's note SZ6 CF-SZ6R","CF-SZ6Y28VS(10P)":"Panasonic Let's note SZ6 CF-SZ6Y28VS","CF-SZ6Y28VS":"Panasonic Let’s note SZ6 CF-SZ6Y28VS","VJPG11C11N":"VAIO Pro PG VJPG11C11N","VJPG111(10P)":"VAIO Pro PF VJPG11","UA9R-R38T":"Dospara GALLERIA UA9R-R38T","4Y607PA#ABJ":"HP EliteBook 830 G8 Notebook PC","1Q0V8AV":"HP EliteBook 830 G7 Notebook PC","7WK10AV":"HP Elite Dragonfly","2H6W1AV":"HP Elite Dragonfly G2 Notebook PC","20RES22Q00":"Lenovo ThinkPad E15 Gen 2","A6BJFSFAL511":"dynabook B65/FS","6UP97PA#ABJ":"HP 250 G7 Notebook PC","2ZZ91AV":"HP ProDesk 400 G4 DM","1AE80AV":"HP ProDesk 400 G3 DM","PCN1565AAL":"NEC LAVIE Note Standard NS600/NA","PCN1565AAWE3":"NEC LAVIE Direct N15 (Ryzen 7 4700U 搭載モデル)","PCNS600NAWE3":"NEC LAVIE Note Standard NS600/NA","PCNS600RAB8":"NEC LAVIE Note Standard NS600/RAB","81LW00CNJP":"Lenovo IdeaPad S340 15API","FMVA43F1WG":"Fujitsu FMV LIFEBOOK AH43/F1","FMVA43E3WG":"Fujitsu FMV LIFEBOOK AH43/E3","LQL-00025":"Microsoft Surface Laptop 2","PCN1575AALE3":"NEC LAVIE Note Standard NS750/RA","P3Y4PSEW":"dynabook PZ/HS","PCNX850NAGE3":"NEC LAVIE Note NEXT NX850/NA","FMVA77D1LG":"Fujitsu FMV LIFEBOOK AH77/D1","81LG005UJP":"Lenovo ideapad S540-15IWL","FMVA77D1WG":"Fujitsu FMV LIFEBOOK AH77/D1","P3T7KSBL":"dynabook T7/K","PCNS700RABE3":"NEC LAVIE Note Standard NS700/RA","FMVA53D1WG":"Fujitsu FMV LIFEBOOK AH53/D1","LBI856S1OH":"mouse X5シリーズ (LBI856S1OH)","FMVA77C2B":"Fujitsu FMV LIFEBOOK AH77/C2","PCNS700MARE3":"NEC LAVIE Note Standard NS700/MAR","FMVA53C2W":"Fujitsu FMV LIFEBOOK AH53/C2","PCNS630JAW":"NEC LAVIE Note Standard NS630/JAW","PT75GGS-BEA3":"dynabook PT75/GG","PCNX850JABE3":"NEC LAVIE Note Standard NS850/JAB","PCNS700JABE3":"NEC LAVIE Note Standard NS700/JAB","FMVA50D2WG":"Fujitsu FMV LIFEBOOK AH50/D2","FMVA53B2R":"Fujitsu FMV LIFEBOOK AH53/B2","FMVA77B1RG":"Fujitsu FMV LIFEBOOK AH77/B1","FMVA53B2WG":"Fujitsu FMV LIFEBOOK AH53/B2","PT75DBSBJA3":"dynabook PT75/DB","PT75EGS-BJA3":"dynabook PT75/EG","PT75CGS-BJA3":"dynabook PT75/CGS","PCNS700GABE3":"NEC LAVIE Note Standard NS700/GAB","PCNS750HAW":"NEC LAVIE Note Standard NS750/HAW","20HQCT01WW":"Lenovo ThinkPad X1 Carbon (5th Gen)","PT65EGP-SJA":"dynabook T65/EG","PCNS750FAGE3":"NEC LAVIE Note Standard NS750/FAS","FMVA53A3RG":"Fujitsu FMV LIFEBOOK AH53/A3","FMVA53XR":"Fujitsu FMV LIFEBOOK AH53/XR","FMVA53A3WG":"Fujitsu FMV LIFEBOOK AH53/A3","PCGN338DCA8":"NEC LAVIE Note Standard NS350/DAB","PCNS700EABE3":"NEC LAVIE Note Standard NS700/EAB","PT75UWSBWB3":"dynabook PT75/UWSBWB3","PT75BBS-BJA3":"dynabook PT75/BB","PCNS700EARE3":"NEC LAVIE Note Standard NS700/EAR","PCNS750CARE3":"NEC LAVIE Note Standard NS750/CA","PCNS750EAGE3":"NEC LAVIE Note Standard NS750/EAG","PT75BGSBJA3":"dynabook PT75/BG","PT75UBSBWB3":"dynabook PT75/UB","PT75AGSBJA3":"dynabook PT75/AGS","PT75TGSBWB3":"dynabook PT75/TG","PCGN164JFAF":"NEC LAVIE Note Standard NS600/JA","PAZ45FG-SEF":"dynabook AZ45/FG","PT55UWSBWA3":"dynabook T55/U","PT55TGSBWA3":"dynabook T55/NG","P3T4LSBG":"dynabook PZ35/L","P3T4KSBR":"dynabook B65/R","P3T4KSBG":"dynabook B65/M","FMVA45BSPG":"Fujitsu FMV LIFEBOOK AH45/B2","PCNS300MAR":"NEC LAVIE Note Standard NS300/MAR","FMVA45ASPG":"Fujitsu FMV LIFEBOOK AH45/AS","PCNS350CABE3":"NEC LAVIE Note Standard NS350/CAB","PCNS350CARE3":"NEC LAVIE Note Standard NS350/CA","80XH006CJP":"Lenovo ideapad 320 15ISK","PCNS100K2W":"NEC LAVIE Note Standard NS100/K2W","PCNS150KAW":"NEC LAVIE Note Standard NS150/K","80TT00ADJP":"Lenovo IdeaPad 310-15IAP","81DE02MSJP":"Lenovo ideapad 330-15IGM","FMVA42B2W":"Fujitsu FMV LIFEBOOK AH42/B2","FMVA42B1G":"Fujitsu FMV LIFEBOOK AH42/B1","PT45CBS-SJA3":"dynabook T45/CBS","PT45GWSSEC3":"dynabook T45/GSS","PCNS150GAB":"NEC LAVIE Note Standard NS150/G","FMVA42YR":"Fujitsu FMV LIFEBOOK AH42/Y","PCNS600MAWE3":"NEC LAVIE Note Standard NS600/MAW","PCNS10EM2W":"NEC LAVIE Note Standard NS100/EM","PCNS10EK2S":"NEC LAVIE Note Standard NS100/EK","PCNS20AM2W":"NEC LAVIE Note Standard NS150/NA","FMVA30D3W2":"Fujitsu FMV LIFEBOOK AH30/D3","FMVA30D3B4":"Fujitsu FMV LIFEBOOK AH30/D3","FJR00016":"Microsoft Surface Pro (5th Gen) Core m3/4GB/128GB","MT-WN1201SN-A":"mouse computer MT-WN1201SN-A","PCNM150GAL":"NEC LAVIE Direct NM (PC-NM150GAL)","V8U08AV":"HP EliteBook Folio G1","FMVF90BBG2":"Fujitsu ESPRIMO FH90/B2","FMVF77C2KG":"Fujitsu ESPRIMO FH77/C2","FMVF77XDB":"Fujitsu ESPRIMO FH77/XD","PCDA770DABE3":"NEC LAVIE Desk All-in-one DA770/DAB","PCDA570EABE3":"NEC LAVIE Desk All-in-one DA570/EAB","FMVWB1F17D":"Fujitsu ESPRIMO WF1/B1","FMVF59D3WK":"Fujitsu ESPRIMO FH59/D3","FMVF53YWG":"Fujitsu ESPRIMO FH53/YW","PCHA370RAWE3":"NEC LAVIE All-in-one DA370/RAW","PCGD18CUCAB":"NEC LAVIE Direct DA(S) All-in-one PC","FMVF52B3PG":"Fujitsu ESPRIMO FH52/B3","PCDA370GARE3":"NEC LAVIE Direct DA(S) DA370/GAS","FMVF53B3BJ":"Fujitsu ESPRIMO FH53/B3","FMVF52B1GG":"Fujitsu ESPRIMO FH52/B1","FMVF67E3WZ":"Fujitsu ESPRIMO FH67/E3","MacBookPro18.1":"Apple MacBook Pro 16-inch 2021","MacBookPro18.3":"Apple MacBook Pro 14-inch 2021","MacBookPro18.4":"Apple MacBook Pro 14-inch 2021","VWRJX23HM4":"Apple MacBook Pro 14-inch 2021","FR4P616LHG":"Apple MacBook Pro 14-inch 2021","MacBookPro17.1":"Apple MacBook Pro 13-inch (M1, 2020)","MacBookAir10.1":"Apple MacBook Air 13-inch (M1, 2020)","XQ-DQ44":"Sony Xperia 1 V","XQ-CT44_Xperia":"Sony Xperia 1 IV","HQ637L09ED":"Sony Xperia 10 V","1S3-00013(10P)":"Microsoft Surface Pro 7+","FJU-00014(10P)":"Microsoft Surface Pro (5th Gen)","QV985AV":"HP Compaq Pro 6300 Small Form Factor","Y5W43AV":"HP ProDesk 400 G4 SF","20J8S02H00(10P)":"Lenovo ThinkPad L570","PC1ZR1RB":"Lenovo ThinkPad X13 Gen 1","2ZA83AV10P":"HP ProBook 450 G5","PB6DNTB4127FD1":"dynabook B65/DN","FMVU24011(10P)":"Fujitsu LIFEBOOK U939/B","FMVU14013(10P)":"Fujitsu LIFEBOOK U938/S","VKT16/GV-4":"NEC VersaPro Type VG VKT16/GG-4","CF-33ABHAQVJ":"Panasonic TOUGHBOOK CF-33ABHAQVJ","VJS132C12N":"Sony VAIO S13 VJS132C12N","727-F":"Apple MacBook Pro 14-inch (2021, Apple M1 Pro)","FVFHQ35XQ05P":"Apple MacBook Pro 13-inch (M1, 2020)","A2602":"Apple iPad (9th generation) Wi‑Fi 64GB Space Gray","A1822":"Apple iPad (5th generation) Wi‑Fi 32GB","P138G":"DELL Latitude 5330","21FHS40400":"Lenovo ThinkPad L13 Gen 4","6D6L3PA#ABJ":"HP ProBook 430 G8","20VH006PJP":"Lenovo ThinkPad L13 Gen 2 (20VH)","VKT40C-9":"NEC VersaPro タイプVC VKT40/C","PC-VKT40CGG63N9":"NEC VersaPro VKT40/C","20T3S3FK00":"Lenovo ThinkPad X13 Gen 1 (20T3)","FMVU2803LP":"Fujitsu LIFEBOOK U9310/DX","FMVU2803PP":"Fujitsu LIFEBOOK U9310/DX","VKT10C-6":"NEC VersaPro Type VS VKT10/C","PC-VKT10CZG6":"NEC VersaPro VKT10/C-6","P96G":"Dell Latitude 5300 2-in-1","P114G":"Dell Latitude 3301","4UJ36PA#ABJ":"HP EliteBook x360 1030 G3","5TV89AV":"HP EliteBook 830 G6","5TV87AV":"HP EliteBook 830 G6","7WK08AV":"HP Elite Dragonfly 13.3インチ Notebook PC","7WK09AV":"HP Elite Dragonfly 13.3インチ (7WK09AV)","9FM64PA#ABJ":"HP Elite Dragonfly G1","20Q1S4E300":"Lenovo ThinkPad X390 20Q1S4E300","20KEA006JP":"Lenovo ThinkPad X280 20KEA006JP","20KEA059JP":"Lenovo ThinkPad X280 20KEA059JP","VJT13H-4":"NEC VersaPro J タイプVF VJT13/H","PC-VJT13HGG6364":"NEC VersaPro J タイプVF VJT13/H","NJ4300BML1":"EPSON Endeavor NJ4300E","5JC13AV":"HP ProBook 430 G6","P93F":"Dell Precision 7560","P91F":"DELL Precision 5570","469N3PA#ABJ":"HP ZBook Firefly 14 G7 Mobile Workstation","P98G":"Dell Latitude 5401","8DV14PA#ABJ":"HP ZBook 15 G6","4KT82PA#ABJ":"HP ZBook 15v G5","5PF36AV":"HP ProBook 650 G5","M9R62AV":"HP ZBook 15 G3","T9S46PA#ABJ":"HP ZBook 15 G3","P104F":"DELL Latitude 5530","6W846PA#ABJ":"HP EliteBook 650 G9","6X2X1PA#ABJ":"HP ProBook 450 G9","P144G":"DELL Latitude 3420","22Y68PA#ABJ":"HP EliteBook 850 G7 Notebook PC","6YY33AV":"HP ProBook 450 G7","9LY78PA#ABJ":"HP 340S G7 Notebook PC","9LY84PA#ABJ":"HP 340S G7 Notebook PC","1K4B5AV":"HP 250 G7 Notebook PC","20U4S0ME00":"Lenovo ThinkPad L15 Gen 1","20U3001LJP":"Lenovo ThinkPad L15 Gen 1 (20U3)","A6BJFSF8L511":"dynabook BJ65/FS","VKM17X-9":"NEC VersaPro VK17X/M","VKM17X-7":"NEC VersaPro VK17X/M","PC-VKM17XZG7":"NEC VersaPro VK17X/M","VUT16F-9":"NEC VersaPro Type VF VUT16/F","PC-VUT16FBGS3J9":"NEC VersaPro Type VB VUT16/F","VJT16F-9":"NEC VersaPro Type VB VJT16/F","PC-VJT16FZG9":"NEC VersaPro VJ16T/F-9","P86F":"DELL Latitude 3500","5PF33AV":"HP ProBook 650 G5","7PJ63PA#ABJ":"HP ProBook 450 G6","7PJ54PA#ABJ":"HP ProBook 450 G6","7PJ69PA#ABJ":"HP ProBook 450 G6","5KX42AV":"HP 250 G7 Notebook PC","4ZE26PA#ABJ":"HP EliteBook 840 G5","20KGA00SJP":"Lenovo ThinkPad X1 Carbon (5th Gen) 20KGA00SJP","20LGS00L00":"Lenovo ThinkPad X1 Yoga (3rd Gen)","PG83MMJ4GL7AD21":"dynabook G83/M","PB65MTB41R7AD21":"dynabook B65/M","A6BSEPL8B9C1":"dynabook B65/EP","A6BSEPL8B971":"dynabook B65/EP","FMVA6402DP":"Fujitsu LIFEBOOK A579/BX","FMVA6401RP":"Fujitsu LIFEBOOK A579/BX","FMVA6401MP":"Fujitsu LIFEBOOK A579/BX","FMVA6401NP":"Fujitsu LIFEBOOK A579/BX","FMVA62001":"Fujitsu LIFEBOOK A579/A","FMVA8204TP":"Fujitsu LIFEBOOK A5510/DX","A6BSEPN8B9C1":"dynabook B65/EP","A6BSEPN859C1":"dynabook B65/EP","FMVA41007P":"Fujitsu LIFEBOOK A359/BX","VRL21F-6":"NEC VersaPro VRL21/F","PC-VRL21FBGR3R6":"NEC VersaPro VL21F/B","FMVA82027":"Fujitsu LIFEBOOK A5510/D","2CA60AV":"HP ProBook 450 G5","FMVA2201VP":"Fujitsu LIFEBOOK A577/RX","5NW34AV":"HP EliteOne 800 G5 23.8-in All-in-One","2V827AV":"HP ProOne 600 G6 22 All-in-One PC","PYT2554TCN":"Fujitsu PRIMERGY TX2550 M4","MGA G200EH":"HP ProLiant DL360p Gen8","PYT1334TNM":"Fujitsu PRIMERGY TX1330 M4","PYR1334R2M":"Fujitsu PRIMERGY RX1330 M4","PYT1324ZFY":"Fujitsu PRIMERGY TX1320 M4","TQ-X1D-P21542-B21":"Hitachi HA8000V/ML30 Gen10","TQ-X1D-P07065-B21":"HITACHI HA8000V/ML30 Gen10","D02T":"DELL Precision 7820 Tower","2YW30AV":"HP Z2 Small Form Factor G4 Workstation","L8T14AV":"HP Z240 SFF Workstation","F5W13AV":"HP Z440 Workstation","6BD61AV":"HP EliteDesk 800 G5 TWR","6AU21AV":"HP EliteDesk 800 G5 DM","FMVD4500LP":"Fujitsu ESPRIMO D588/CX","Y2Z63AV":"HP EliteDesk 800 G3 SFF","PC-MKH36EZG1":"NEC Mate MKH36/E","MKH36E-1":"NEC Mate MK36E/E","8YM57AV":"HP EliteDesk 800 G6 Small Form Factor PC","6C2G8PA#ABJ":"HP ProDesk 400 G7 SFF","11DUS1MY00":"Lenovo ThinkCentre M70q","PC-MRT29LZ7AK2Y":"NEC Mate MRT29L/Y","6BD64AV":"HP EliteDesk 800 G5 SFF","8EN96PA#ABJ":"HP ProDesk 600 G5 SFF","8EN90PA#ABJ":"HP ProDesk 600 G5 SFF","8FK52PA#ABJ":"HP ProDesk 600 G5 Small Form Factor","6EF24AV":"HP ProDesk 400 G6 SFF","FMVD4500TP":"Fujitsu ESPRIMO D588/CX","FMVD45049P":"Fujitsu ESPRIMO D588/CX","FMVD45010P":"Fujitsu ESPRIMO D588/CX","FMVD45011P":"Fujitsu ESPRIMO D588/CX","FMVD4506BP":"Fujitsu ESPRIMO D588/CX","FMVD4303LP":"Fujitsu ESPRIMO D588/BX","FMVD4300KP":"Fujitsu ESPRIMO D588/BX","FMVD4303MP":"Fujitsu ESPRIMO D588/BX","2US83AV":"HP EliteDesk 800 G4 SFF","10SUS26V00":"Lenovo ThinkCentre M720s","PC-MKM30BZG4":"NEC Mate MKM30/B","MKM30B-4":"NEC Mate MK30B/B","FMVD4000WP":"Fujitsu ESPRIMO D588/VX","FMVD4004NP":"Fujitsu ESPRIMO D588/VX","FMVD40018P":"Fujitsu ESPRIMO D588/VX","FMVD3802NP":"Fujitsu ESPRIMO D588/TX","PC-MUM28LZGCCS4":"NEC Mate MK28L/B","PC-MUM28LZ7CCS4":"NEC Mate MK28L/L","PC-MUM28LZ6CCS4":"NEC Mate MK28L/L","PC-MRM28LZ71CS4":"NEC Mate MRM28/L","MR4800BML1":"EPSON Endeavor MR4800E","9DF60AV":"HP ProDesk 400 G7 Small Form Factor PC","8EN83PA#ABJ":"HP ProDesk 600 G5 SFF","FMVD45018P":"Fujitsu ESPRIMO D588/CX","FMVD43018P":"Fujitsu ESPRIMO D588/BX","FMVD43014P":"Fujitsu ESPRIMO D588/BX","FMVD43013P":"Fujitsu ESPRIMO D588/BX","FMVB13001":"Fujitsu ESPRIMO Q588/B","PC-MRL36LZG1CS5":"NEC Mate ML36L/L","7NY63PA#ABJ":"HP ProDesk 600 G4 SFF","5XD13PA#ABJ":"HP ProDesk 600 G4 SFF","10STA016JP":"Lenovo ThinkCentre M720s","10STS0T300":"Lenovo ThinkCentre M720s","PC-MUL36LZ6CCS4":"NEC Mate ML36L/C","PC-MKL36LZG1CS3":"NEC Mate MKL36/L","10KY-CTO1WW":"Lenovo ThinkCentre M700 Tower","10M8S1KN00":"Lenovo ThinkCentre M710s","10NM-CTO1WW":"Lenovo ThinkCentre M710s","90BJ0033JP":"Lenovo ideacentre 300-20ISH","90G9006YJP":"Lenovo IdeaCentre AIO 330-20AST","90GB00DDJP":"Lenovo V520s Small Desktop","N8100-2738Y":"NEC Express5800/GT110i","FMVB04022Z":"Fujitsu ESPRIMO D586/P","FMVB0602PZ":"Fujitsu ESPRIMO D586/P","FMVB1000FZ":"Fujitsu ESPRIMO D587/RF","FMVB1200CZ":"Fujitsu ESPRIMO D588/TW","FMVB1500CZ":"Fujitsu ESPRIMO D7510/CX","FMVD04012":"Fujitsu ESPRIMO D551/G","FMVD0502SP":"Fujitsu ESPRIMO D550/C","FMVD13070":"Fujitsu ESPRIMO Dシリーズ FMVD13070","FMVD1502KZ":"Fujitsu ESPRIMO D750/K","FMVD1504P":"Fujitsu ESPRIMO D750/AX","FMVD2102TZ":"Fujitsu ESPRIMO D586/RX","FMVD30012P":"Fujitsu ESPRIMO D588/VW","FMVD3401BD":"Fujitsu ESPRIMO D3400/B","FMVD3800SZ":"Fujitsu ESPRIMO D588/TW","FMVD38039P":"Fujitsu ESPRIMO D588/VW","FMVD4002RZ":"Fujitsu ESPRIMO D588/TW","FMVD43022Z":"Fujitsu ESPRIMO D588/VW","FMVD4500RP":"Fujitsu ESPRIMO D588/VW","FMVD4501BP":"Fujitsu ESPRIMO D587/R","FMVD4501LP":"Fujitsu ESPRIMO D5810/DX","FMVD4502KZ":"Fujitsu ESPRIMO D588/VW","FMVD4505VP":"Fujitsu ESPRIMO D588/VW","FMVD47038Z":"Fujitsu ESPRIMO D7010","FMVD48004Z":"Fujitsu ESPRIMO D588/VX","FMVD5200MP":"Fujitsu ESPRIMO D582/T","FMVDJ3TK1":"Fujitsu ESPRIMO D751/T","FMVWC1D2S7":"Fujitsu ESPRIMO D586/RW","PC-MJ27MLZ6RDSU":"NEC Mate MJ27M/L","PC-MJ37LLZL1BSN":"NEC Mate MJ37L/L","PC-MJL36LZ6RBS3":"NEC Mate MJ36L/L","PC-MJM27LZ6RDS1":"NEC Mate MJ27L/L","PC-MKM28LZ7AAS3":"NEC Mate MK28L/L","PC-MUM29LZ6RDS5":"NEC Mate MK29L/R","81AX":"Lenovo IdeaPad 320S-13IKB","81DC":"Lenovo IdeaPad 320 15IKB","81Y3":"Lenovo IdeaPad Slim 350 15IIL05","82LM00JXJP":"Lenovo IdeaPad Slim 550 15ALC05","FMVA04TK1":"Fujitsu LIFEBOOK A744/H","FMVA0900J":"Fujitsu LIFEBOOK A574/H","FMVA1101G":"Fujitsu LIFEBOOK A576/P","FMVA12TK1":"Fujitsu LIFEBOOK A576/P","FMVA15011":"Fujitsu LIFEBOOK A576/P","FMVA15TK1":"Fujitsu LIFEBOOK A576/P","FMVA16TK1":"Fujitsu LIFEBOOK AH42/T","FMVA18TK1":"Fujitsu LIFEBOOK AH53/B1","FMVA18TK2":"Fujitsu LIFEBOOK AH45/B2","FMVA2101GD":"Fujitsu LIFEBOOK A576/P","FMVA21TK1":"Fujitsu LIFEBOOK A576/PW","FMVA22TK1":"Fujitsu LIFEBOOK AH42/TK","FMVA26TK1":"Fujitsu LIFEBOOK AH42/B2","FMVA27TK1":"Fujitsu LIFEBOOK A577/RW","FMVA41002P":"Fujitsu LIFEBOOK A7410","FMVA62TK1":"Fujitsu LIFEBOOK AH42/T","FMVA64TK1":"Fujitsu LIFEBOOK AH45/T","FMVA82TK1":"Fujitsu LIFEBOOK AH42/T1","FMVA84TK1":"Fujitsu LIFEBOOK AH45/T1","FMVNB40S":"Fujitsu FMV-BIBLO NB40S","FMVS04001":"Fujitsu LIFEBOOK S936/R","FMVS10TK1":"Fujitsu LIFEBOOK S10/TK","FMVU08TK1":"Fujitsu LIFEBOOK U937/R","FMVU09TK1":"Fujitsu LIFEBOOK U937/R","FMVU19TK1":"Fujitsu LIFEBOOK U9310X/C","FMVU28TK1":"Fujitsu LIFEBOOK U9311X/C","FMVU32TK1":"Fujitsu LIFEBOOK U9311X/C","FMVWA3A13W":"Fujitsu LIFEBOOK A576/PW","GK104GLM":"HP ZBook 17 G2","NJ3500EAO1":"EPSON Endeavor NJ3500E","PC-LL970DS":"NEC LAVIE Note Standard LL970/DS","PC-VJ20LFWL1SRN":"NEC VersaPro J タイプVF VJ20/LF","PC-VJ23TGV74R6U":"NEC VersaPro VJ23T/G","PC-VRT25FB6S3R5":"NEC VersaPro Type VT VRT25/FB","P82G003":"DELL XPS 13 9300","FMVF70B3BZ":"Fujitsu ESPRIMO FH70/B3","FMVF93B3BZ":"Fujitsu ESPRIMO FH93/B3","PC-DA770KAR-J":"NEC LAVIE Desk All-in-one DA770/KAR","PC-VN770MSR-Y":"NEC VALUESTAR N VN770/MSR","A6BDHSF8LN72":"dynabook B55/HS","A6BJFSS8ED21":"dynabook BJ65/FS","A6BSEPN8BA71":"dynabook B65/EP","A6BSERL8LA21":"dynabook B65/ER","PB65DBAD4RCAD81":"dynabook B65/D","PB65FAB4CNCAD91":"dynabook B65/F","PB65FBB11NCAD91":"dynabook B65/F","PB65JAJ4CN7AD11":"dynabook B65/J","PB65JTB41N7AD11":"dynabook B65/J","PB65MAB4CN7AD21":"dynabook B65/M","PB65MTJ44N7AD11":"dynabook B65/M","PB6DNTB44N7BD1":"dynabook B65/DN","PR73FBA448CAD91":"dynabook R73/F","659R5PA#ABJ":"HP 250 G8 Notebook PC","9S0R4PT#ABJ":"HP ProBook 450 G10","2RA37PA#ABJ":"HP ProBook 450 G3","T3M13PT#ABJ":"HP ProBook 450 G3","V6E10AV-AAZT":"HP ProBook 450 G3","V6E11AV-AHNS":"HP ProBook 450 G3","V6E14AV-ACFZ":"HP ProBook 450 G3","2ZA83AV-AAGE":"HP ProBook 450 G5","4CA63PA#ABJ":"HP ProBook 450 G5","4QF86AV-AAXZ":"HP ProBook 450 G5","3D3X8PA#ABJ":"HP ProBook 450 G8","6X2X0PA#ABJ":"HP ProBook 450 G9","6X705PA#ABJ":"HP ProBook 450 G9","704Y0PA#ABJ":"HP ProBook 450 G9","B4TG5PT#ABJ":"HP ProBook 460 G11","VK23TXZDU":"NEC VersaPro VK23T/X","PC-VK26TXZDN":"NEC VersaPro VK26T/X","PC-VKT16XBGM":"NEC VersaPro VK16X/B","VKT16XZG3":"NEC VersaPro VK16X/Z","VKT16XZG4":"NEC VersaPro VK16X/Z","VKT16XZG5":"NEC VersaPro VT16/X","21054P-TGL":"mouse DAIV 4P","I7I01SR-A":"mouse DAIV Z4-I7I01SR-A","20U4S64P00":"Lenovo ThinkPad L15 Gen 1","20Q8S0HH00":"Lenovo ThinkPad L590","20W5S1FL0F":"Lenovo ThinkPad T15 Gen 2","20UAS4J000":"Lenovo ThinkPad X1 Carbon Gen 8","20QES3FP00":"Lenovo ThinkPad X1 Carbon 2019 (20QE)","21CCS22U00":"Lenovo ThinkPad X1 Carbon Gen 10","FMVA82001":"Fujitsu LIFEBOOK A5510/D","A6G2LWD7621A":"dynabook G83/LW","A6G2LYD7191A":"dynabook G83/LY","A6G2LYD7291A":"dynabook G83/LY","A6G9HUFAD595":"dynabook G83/HU","A6G9HUFAD626":"dynabook G83/HU","G83HU":"dynabook G83/HU","A6G9HUFAD6D6":"dynabook G83/HU","A6G9HVFAD6D5":"dynabook G83/HV","A6GNKUECH515":"dynabook G83/KU","A6GNKWLCD6DA":"dynabook G83/KW","A6S3DPF25511":"dynabook dynabook S73/DP","A6SBHSF8D611":"dynabook S73/HS","A6SFHSF8D511":"dynabook dynabook S73/HS","PG8DNTCCGPBFD1":"dynabook G83/DN","PR63MBA4447AD21":"dynabook R63/M","PR6DNTC4447BD1":"dynabook R63/DN","PR73MBA4187AD21":"dynabook R73/M","PR73MBC4487AD21":"dynabook R73/M","2YZ04AV-AABC":"HP ProBook 430 G5","26P78PA#ABJ":"HP ProBook 430 G7","795P0AV-AAAV":"HP ProBook 630 G10","795P0AV-AADH":"HP ProBook 630 G10","L4Q21AV-AAEL":"HP EliteBook 820 G3","20M93PA#ABJ":"HP EliteBook 830 G7","577X5PA#ABJ":"HP EliteBook 830 G8 Notebook PC","5A1N8AV-AAEG":"HP EliteBook 830 G8 Notebook PC","5A1N8AV-BCXO":"HP EliteBook 830 G8 Notebook PC","2J550PA#ABJ":"HP Elite Dragonfly G1","2J550PA":"HP Elite Dragonfly","398A4PA#ABJ":"HP Elite Dragonfly G2","6U8H1PA#ABJ":"HP Elite Dragonfly G2","VK23LBZDU":"NEC VersaPro VK23L/B","VKM16BZG5":"NEC VersaPro VM16/B","PC-VKM17BZG9":"NEC VersaPro VKM17/B","VKT10CZG6":"NEC VersaPro Type VT VKT10/CZG","VKT12HZG3":"NEC VersaPro VKT12/H","PC-VKT12HZG3":"NEC VersaPro VT12/H","PC-VKT13HZG4":"NEC VersaPro VT13H/Z","VKV15HZG4":"NEC VersaPro VK15H/Z","VJPG1113":"VAIO Pro PG","VJPG131":"VAIO Pro PG VJPG131","VJPG214":"VAIO Pro PG VJPG214","5BL-00016":"Microsoft Surface Laptop 4","20R4S2F900":"Lenovo ThinkPad L13 (20R4)","20T3S96F00":"Lenovo ThinkPad X13 Gen 1","20WLS2MG00":"Lenovo ThinkPad X13 Gen 2 (20WLS2MG00)","20W9S0XC0W":"Lenovo ThinkPad X13 Yoga Gen 2","21HNS0KD00":"Lenovo ThinkPad X1 Carbon Gen 11","AT-x530L-10GHXm":"Allied Telesis AT-x530L-10GHXm","3V8G6EC#ABJ":"HP Z2 Tower G5 Workstation","2YW27AV-AWZQ":"HP Z2 Tower G4 Workstation","4Y0H8AV-AAFP":"HP Z2 Tower G9 Workstation","4Y0H8AV-APPZ":"HP Z2 Tower G9 Workstation","XQC-3.6G-W2123":"HP Z4 G4 Workstation","5D6T8PA-AAAA":"HP ZBook Firefly 14 inch G8 Mobile Workstation","8UQ93EC#ABJ":"HP ZBook 15 G6","1X9B9PA-AAAA":"HP ZBook Studio G7 Mobile Workstation","30BYS1HV00":"Lenovo ThinkStation P520c","X6C-3.6G-W2133":"Lenovo ThinkStation P520c","FMN-00019":"Microsoft Surface Pro Type Cover (Black)","PF3-00010":"Microsoft Surface Pro 3/Pro 4用 Surface Dock (PF3-00010)","1PX76PA#ABJ":"HP Elite x2 1012 G2","4UJ44PA#ABJ":"HP Elite x2 1013 G3","8QU70PA#ABJ":"HP Elite x2 G4","MK2L3J/A":"Apple iPad (第9世代) Wi‑Fi 64GB シルバー","6EF24AV-AAJK":"HP ProDesk 400 G6 SF","7E8K2AV-AADJ":"HP ProDesk 400 G9 Mini","7E8Y0AV-AABM":"HP ProDesk 400 G9 Small Form Factor","W10W11DG":"HP ProDesk 400 G9 SFF","7E8Y0AV-AABN":"HP ProDesk 400 G9 SFF","Y3F34AV-BYDM":"HP ProDesk 600 G3 SF","2VG42AV-AEAQ":"HP ProDesk 600 G4 SF","9AW71AV-EMHN":"HP ProDesk 600 G6 SF","4K1Q5PA#ABJ":"HP ProDesk 600 G6 Small Form Factor","54K52AV-AAGD":"HP ProDesk 600 G9 Small Form Factor","2US83AV-ACZI":"HP ProDesk 800 G4 SF","6BD61AV-CYPM":"HP EliteDesk 800 G5 Tower","4G087AV-DHKJ":"HP ProDesk 800 G9 Small Form Factor","519Q1AV-BWZF":"HP EliteDesk 800 G9 TWR","PC-MK32MBZDU":"NEC Mate MK32M/B","PC-MK32MBZGT":"NEC Mate MK32M/B","PC-MK32MBZGU":"NEC Mate MK32M/B","PC-MK37LBZDN":"NEC Mate MK37L/B","PC-MK37LBZDU":"NEC Mate MK37L/B","PC-MKH32BZG4":"NEC Mate MKH32/B","PC-MKL36BZG4":"NEC Mate MKL36/B","PC-MKL36BZG5":"NEC Mate MKL36/B","PC-MKL36BZG7":"NEC Mate MKL36/B","10UQS0B400":"Lenovo ThinkCentre M710e","A1550":"Apple iPad mini 4 Cellular 64GB (A1550)","A1779":"Apple iPhone 7 32GB (A1779) Silver","728-A":"Apple iPhone 7 32GB (A1779) Silver","F17VV3AUHG7Y":"Apple iPhone 7 32GB Silver (A1779)","728-B":"HP Pavilion 23bw 液晶モニタ 23インチ","LCD-MF234XBR2-S":"I-O DATA LCD-MF234XBR2-S 23.8型液晶モニター","21CCS2EG00":"Lenovo ThinkPad X1 Carbon Gen 10","21CBCTO1WW":"Lenovo ThinkPad X1 Carbon Gen 10 (21CB)","20NSS17R00":"Lenovo ThinkPad L390 20NSS17R00","54J99PA#ABJ":"HP ENVY x360 Convertible 13-bd0xxx 54J99PA#ABJ","20KES0GJ00":"Lenovo ThinkPad X280 20KE","20KGS4CL00":"Lenovo ThinkPad X1 Carbon 6th Gen (2018)","20KH004UJP":"Lenovo ThinkPad X1 Carbon 6th Gen (2018)","20R9":"Lenovo ThinkBook 13s-IWL (20R9)","81N4":"Lenovo IdeaPad C340-14IWL 81N4","4ME10PA#ABJ":"HP ENVY x360 13-ag0xxx (4ME10PA#ABJ)","82KU":"Lenovo IdeaPad 3 15ALC6 82KU","20RR":"Lenovo ThinkBook 13s-IML 20RR","81TK":"Lenovo IdeaPad C340-14IML 81TK","NA710SP":"EPSON Endeavor NA710SP","81UM":"Lenovo IdeaPad S340-13IML 81UM","20K5A08SJP":"Lenovo ThinkPad X270 (20K5)","81B5":"Lenovo Yoga 720-12IKB (81B5)","728-D":"Lenovo Yoga 720-12IKB (81B5)","P202YAZY":"Lenovo YOGA 720-12IKB (81B5)","E6S28AV":"HP ProBook 430 G1","20NLCTO1WW":"Lenovo ThinkPad X395 20NLCTO1WW","CFSZ5-2L":"Panasonic Let’s note SZ5 CF-SZ5HD6KS","10TVCTO1WW":"Lenovo ThinkCentre M720s SFF CTO (10TVCTO1WW)","FMVA16020P":"Fujitsu LIFEBOOK A576/P","PC-MKL37LZ6CAS1":"NEC Mate MKL37/L","FMVXDF6L2Z":"Fujitsu ESPRIMO D582/E","9AG52AV":"HP ProDesk 400 G6 Desktop Mini PC","PC-MK27ELZZ1FSH":"NEC Mate MK27E/L","FMVD0502PP":"Fujitsu ESPRIMO D0502/P (FMVD0502PP)","5KX42AV#ABJ":"HP 250 G7 Notebook PC","FARQ18004":"Fujitsu ARROWS Tab QH30/W","MacBookPro16.1":"MacBook Pro 16 2019","MacBookPro15.2":"MacBook Pro 13 2018 (Four Thunderbolt 3 ports)","MacBookPro15.1":"MacBook Pro 15 2018","MacBookPro14.1":"MacBook Pro 13 2017 (Two Thunderbolt 3 ports)","MacBookPro14.3":"MacBook Pro 15 2017","MacBookPro14.2":"MacBook Pro 13 2017 (Four Thunderbolt 3 ports)","MacBookAir7.2":"MacBook Air 13 2017","FVHYWBH9J1WK":"MacBook Air 13 2017","MacBookPro13.1":"MacBook Pro 13 2016 (Two Thunderbolt 3 ports)","MacBookPro13.3":"MacBook Pro 15 2016","MacBookPro13.2":"MacBook Pro 13 2016 (Four Thunderbolt 3 ports)","MacBook9.1":"MacBook 12-inch Early 2016","MacBookPro11.4":"MacBook Pro 15 2015","MacBookAir6.2":"MacBook Air 13 2014 Early","728-E":"MacBook Pro 13 2014","MacBookAir5.2":"MacBook Air 13 2012","EMC3164":"MacBook Pro 13 2017 (A1708)","A1398":"MacBook Pro 15 2016","EMC 2909":"MacBook Pro 15 2015","EMC 3164":"MacBook Pro 13 2017","C07YQ068JYVW":"Apple Mac mini 2018 (Macmini8,1)","iMac14.1":"Apple iMac 21.5-inch Late 2013","PC-GN287RVDS":"NEC LAVIE Direct N15 GN287/RVDS","FRGHLB650/983D":"FRONTIER GHシリーズ FRGHLB650/983D","H5-LC-ADLABW11":"mouse DAIV H5-LC","PCNX850NABE3":"NEC LAVIE Note Standard NS850/NAB","FMVA53D3RG":"Fujitsu LIFEBOOK AH53/D3","FMVA50D3WP":"Fujitsu LIFEBOOK AH50/D3","FMVA53D3BG":"Fujitsu LIFEBOOK AH53/D3","FMVA53D1RG":"Fujitsu LIFEBOOK AH53/D1","FMVA77D1BG":"Fujitsu LIFEBOOK AH77/D1","PT75GGSBEA3":"dynabook T75/GG","PCNS700JARE3":"NEC LAVIE Note Standard NS700/JAR","FMVA77C2WG":"Fujitsu LIFEBOOK AH77/C2","81DE014GJP":"Lenovo IdeaPad 330 15IKB","FMVA53B2RG":"Fujitsu LIFEBOOK AH53/B2","PCNS700GABJ":"NEC LAVIE Note Standard NS700/GA","PCNS750GAWE3":"NEC LAVIE Note Standard NS750/GAW","PCNS750GABE3":"NEC LAVIE Note Standard NS750/GAB","PT75DGS-BJA3":"dynabook T75/DGS","PT75ERS-BJA3":"dynabook T75/ERS","PCNS700FAWE3":"NEC LAVIE Note Standard NS700/FAW","PT75DBS-BJA3":"dynabook T75/DBS","PT65DGP-RJA":"dynabook T65/DGP","PT75DRS-BJA3":"dynabook T75/DRS","PCNS700GARE3":"NEC LAVIE Note Standard NS700/GA","FMVA50A3WP":"Fujitsu LIFEBOOK AH50/A3","FMVA53XRG":"Fujitsu LIFEBOOK AH53/X (FMVA53XRG)","FMVA77YWG":"Fujitsu LIFEBOOK AH77/YW","FMVA50XWP":"Fujitsu LIFEBOOK AH50/XW","PCNS750DAWE3":"NEC LAVIE Note Standard NS750/DAW","PT75ABS-BJA3":"dynabook T75/ABs","PCNS700EAR":"NEC LAVIE Note Standard NS700/EAR","PCNS750EAWE3":"NEC LAVIE Note Standard NS750/EAW","PCNS750DAGE3":"NEC LAVIE Note Standard NS750/DAG","PT75AGS-BJA3":"dynabook T75/AGs","PCNS750DAR":"NEC LAVIE Note Standard NS750/DAR","PT75TGS-BWAT3":"dynabook T75/TG","81LG007AJP":"Lenovo IdeaPad L340 15IWL","PT55GWSSEA3":"dynabook T55/GW","PT55GBSSEA3":"dynabook T55/GBS","PT55DBS-BJA3":"Toshiba dynabook T55/DBS","PCGN254FRAB":"NEC LAVIE Note Standard NS350/FAB","FMVU75B1BG":"Fujitsu LIFEBOOK U75/B1","PT55ABSBJA3":"dynabook T55/AB","PCNS300NABE3":"NEC LAVIE Note Standard NS300/NAB","PCNS300NAWE3":"NEC LAVIE Note Standard NS300/NA","FMVA45B3WG":"Fujitsu LIFEBOOK AH45/B3","FMVA45B3GG":"Fujitsu LIFEBOOK AH45/B3","FMVA45B3B":"Fujitsu LIFEBOOK AH45/B3","FMVA45D1WG":"Fujitsu LIFEBOOK AH45/D1","PCNS350FABE3":"NEC LAVIE Note Standard NS350/FA","PCNS350GAWE3":"NEC LAVIE Note Standard NS350/GAW","PCNS300HAW":"NEC LAVIE Note Standard NS300/HAW","FMVA45B2WG":"Fujitsu LIFEBOOK AH45/B2","PT45DGS-SJB3":"dynabook T45/DGS","PT45EGSSJB3":"dynabook T45/EGB","PCNS350HAWE3":"NEC LAVIE Note Standard NS350/HAW","PCNS350HABE3":"NEC LAVIE Note Standard NS350/HAB","PCNS350GAW":"NEC LAVIE Note Standard NS350/GAW","PCGN242FRDB":"NEC LAVIE Note Standard NS350/FAR","81DE00J7JP":"Lenovo IdeaPad 330 15IKB","PCNS300MAWE3":"NEC LAVIE Note Standard NS300/MAW","PCNS300KAB":"NEC LAVIE Note Standard NS300/KAB","PCNX350JAB":"NEC LAVIE Note Standard NS350/JAB","PCNS350EAR":"NEC LAVIE Note Standard NS350/EAR","FMVA45A3WG":"Fujitsu LIFEBOOK AH45/A3","FMVA45XBG":"Fujitsu LIFEBOOK AH45/XB","PCNS350CAWY":"NEC LAVIE Note Standard NS350/CAW","FMVA45A3BG":"Fujitsu LIFEBOOK AH45/A3","PB55BFAD4RAAD11":"dynabook Satellite B55/B","FMVA2004JP":"Fujitsu LIFEBOOK AH42/A2","PCVK25LANNN":"NEC VersaPro VK25L/A","PCNS150KAB":"NEC LAVIE Note Standard NS150/KAB","FMVL55C2WG":"Fujitsu LIFEBOOK LH55/C2","PCNS150HAR":"NEC LAVIE Note Standard NS150/HAR","PT45GWS-SEC3":"dynabook T45/GWS","PCNS150FAW":"NEC LAVIE Note Standard NS150/FAB","PT45AWSSJA3":"dynabook T45/AW","PCNS150EAR":"NEC LAVIE Note Standard NS150/EAR","PCNS150GAR":"NEC LAVIE Note Standard NS150/GAR","PCNS150EAB":"NEC LAVIE Note Standard NS150/EAB","PCNS150EAW":"NEC LAVIE Note Standard NS150/EAW","FMVA42A3G":"Fujitsu LIFEBOOK AH42/A3","PCNS150GAW":"NEC LAVIE Note Standard NS150/GAB","PT45TGSSWA3":"dynabook T45/TG","PCNS150DAW":"NEC LAVIE Note Standard NS150/DAB","FMVA43E1WG":"Fujitsu LIFEBOOK AH43/E1","FMVA40C1BJ":"Fujitsu LIFEBOOK AH40/C1","MCZ-00032":"Microsoft Surface Go (MCZ-00032)","PCNM560KABE1":"NEC LAVIE Hybrid ZERO HZ550/KAB","PCHZ550GAS":"NEC LAVIE Hybrid ZERO HZ550/G","FMVS90WWG":"Fujitsu LIFEBOOK S90/W","FMVS55WWP":"Fujitsu LIFEBOOK S55/W","FMVF77D3KG":"Fujitsu ESPRIMO FH77/D3","FMVF70C2BZ":"Fujitsu ESPRIMO FH70/C2","FMVF90A3BG":"Fujitsu ESPRIMO FH90/A3","FMVF90A3B":"Fujitsu ESPRIMO FH90/A3","PCDA770CABE3":"NEC LAVIE Desk All-in-one DA770/CAB","PD71TBSBWA3":"dynabook REGZA PC D71/TB","PCGD242TCAD":"NEC LAVIE Desk All-in-one DA370/CAB","FMVF52C2PG":"Fujitsu ESPRIMO FH52/C2","FMVF52B2GG":"Fujitsu ESPRIMO FH52/B2","PCDA370GAW":"NEC LAVIE Desk All-in-one DA370/GAW","MV9W13VGJP":"MacBook Pro 14 2023","MacBookPro18.2":"MacBook Pro 16 2021","Mac14.2":"MacBook Air M2 2022","FVFG72ECQ6LT":"MacBook Air M1 2020","A1419":"Apple iMac 27-inch 2017 (A1419 / iMac18,3)","A1418":"iMac 21.5 2017","A1631":"Microsoft Surface Pro 3","A1824":"Microsoft Surface Go 2018","P1-K1UP-TG":"dynabook K1/U1P (P1-K1UP-TG)","FARQ22015":"Fujitsu ARROWS Tab QH30/J","CF-20E0385VJ":"Panasonic TOUGHBOOK CF-20","PC-VKT12SGG3":"NEC VersaPro VKT12/S-3","FZG1-4":"Panasonic TOUGHBOOK G1 FZG1-4","11H10002JP":"Lenovo ThinkCentre M90n-1 Nano","10EW0017JP":"Lenovo ThinkCentre M710s SFF","MacBookAir5,1":"MacBook Air 11-inch Mid 2012","MacBookAir6,1":"MacBook Air 11-inch 2013-2014 (MacBookAir6,1)","MacBookAir6，1":"MacBook Air 13 2013-2014 (MacBookAir6,1)","C02MK07WF5YW":"Apple MacBook Air 11-inch Mid 2013","MacBookAir6,2":"MacBook Air 13-inch 2013-2014 (MacBookAir6,2)","MacBookPro11,2":"Apple MacBook Pro 15-inch 2014 (MacBookPro11,2)","F0CL000PJP":"Lenovo IdeaCentre AIO 330-20IGM","PC-MK36LGGEM":"NEC Mate MK36L/G","SVT21218DJB":"Sony VAIO Tap 21 SVT21218DJB","FMVK07001":"Fujitsu ESPRIMO K557/R","FMVF77B3KG":"Fujitsu ESPRIMO FH77/B3","FMVF77D1KG":"Fujitsu ESPRIMO FH77/D1","A1898":"Apple iPhone 8 Plus (A1898) 64GB Space Gray","XQ-CQ44":"SONY Xperia 5 IV SIMフリー (XQ-CQ44)","F71D20A0HG7Y":"Apple iPhone 7 32GB Silver (A1779)","DNPSMX0PHG7Y":"Apple iPhone 7 32GB (A1779) Silver","F17SV3C4HG7Y":"Apple iPhone 7 32GB Silver (A1779)","FNNRX1RTG5MR":"Apple iPhone 6 64GB Space Gray (A1586)","M7J000455":"EPSON Endeavor NA710SP","PC0M51PA":"Lenovo ThinkPad X270","80V6":"Lenovo YOGA 710-11IKB (80V6)","CF-SZ5HD6KS":"Panasonic Let’s note SZ5 CF-SZ5HD6KS","MacBookPro16.2":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","C02F73ASML7H":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","MacBookPro16,2":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","MacBookPro15,2":"MacBook Pro 13 2019 (Four Thunderbolt 3 ports)","MacBookPro14,2":"MacBook Pro 13 2017 (Four Thunderbolt 3 ports)","MacBookPro13,2":"Apple MacBook Pro 13 2016 (Four Thunderbolt 3 ports)","C02TG3GHGTHT":"MacBook 12-inch Early 2016 (MacBook9,1)","MacBookPro11,4":"MacBook Pro 15 2015","MacBookAir6.1":"MacBook Air 11 2013","MacBookPro11.1":"Apple MacBook Pro 13-inch Retina Mid 2014","Macmini8,1":"Apple Mac mini 2018 (Macmini8,1)","PF197QA4":"Lenovo IdeaPad 330 15IKB","D4WNZT3":"Dell Vostro 15 3510","UX393EA":"ASUS ZenBook UX393EA","BMQVW33":"Dell Latitude 7300","PF3C6NDW":"Lenovo IdeaPad 3 15ALC6 (82KU)","MP1QG3EF":"Lenovo IdeaPad C340-14IML (81TK)","MP1QNJP4":"Lenovo IdeaPad C340-14IML 81TK","5T8WPZ3":"Dell Vostro 15 3530","C02F911NML7H":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","MacBookPro16.3":"MacBook Pro 13 2020 (Two Thunderbolt 3 ports)","FVFXD149HV2J":"MacBook Pro 13 2017 (Two Thunderbolt 3 ports)","C02RT03BGF1L":"iMac 21.5-inch Late 2015","iMac14.3":"Apple iMac 21.5-inch Late 2013 (iMac14,3)","C02PQ0DGF8J8":"Apple iMac 21.5-inch Late 2013 (iMac14,3)","FVHHDG8LQ6L4":"MacBook Air 13 2020 M1","Mac14.7":"MacBook Pro 13 2022 M2","VD729RHVYD":"MacBook Pro 13 2022 (M2)","MacBookPro18,2":"MacBook Pro 16 2021","NVN6J9X44P":"MacBook Pro 16 2021","Mac14,2":"MacBook Air 13 M2 2022","MacBookAir10,1":"MacBook Air 13 2020 M1","iMac18,2":"Apple iMac 21.5-inch 2017","PC-VKT12/S-3":"NEC VersaPro VKT12/S-3","PF2YRF6L":"Lenovo ThinkCentre M90n-1 Nano (11H10002JP)","GK208B":"Dell Vostro 3671","FMVB1300CZ":"Fujitsu ESPRIMO B1300/CZ","FMVD05001":"Fujitsu ESPRIMO D550/B","FMVD0701G":"Fujitsu ESPRIMO D0701G","FMVD0701J":"Fujitsu ESPRIMO D0701/J","FMVD1300G":"Fujitsu ESPRIMO D583/G","FMVD1504V":"Fujitsu ESPRIMO D586/MX","FMVD21013":"Fujitsu ESPRIMO D586/M","FMVD26052P":"Fujitsu ESPRIMO D586/P","FMVD3002PZ":"Fujitsu ESPRIMO D3002/PZ","FMVD37001":"Fujitsu ESPRIMO D3700/E","FMVD38001":"Fujitsu ESPRIMO D588/B","FMVD4300EP":"Fujitsu ESPRIMO D4300/E (FMVD4300EP)","FMVD44004Z":"Fujitsu ESPRIMO D588/BX","FMVD45001":"Fujitsu ESPRIMO D4500/E (FMVD45001)","FMVD4500SP":"Fujitsu ESPRIMO D4500/S (FMVD4500SP)","FMVD52038Z":"Fujitsu ESPRIMO D520/38Z","10VGCTO1WW":"Lenovo ThinkCentre M715q Tiny","10Y3CTO1WW":"Lenovo ThinkCentre M715q Tiny","90J0008JJP":"Lenovo IdeaCentre 510A-15ARR","H110M4-M01":"mouse computer デスクトップPC（H110M4-M01）","IStDXi-S0B6":"mouse G-Tune UNKNOWN","NF8100-261S11Y":"NEC iStorage NS100Tj","MJ28EL-J":"NEC Mate MJ28E/L","MJ33LLZT1FXE":"NEC Mate MJ33L/L","MRL36L-4":"NEC Mate MRL36L-4","PC-GD308ZZLG":"NEC Mate GD308/ZL","PC-MJ27MLZ7RDST":"NEC Mate MJ27M/L","PC-MKL36LZGAAS3":"NEC Mate MKL36L/ZGAAS3","PC-MRT29LZ7ACS9":"NEC Mate MT29L/Z7","PC-MUM29LZ6RDM5":"NEC Mate MU29L/Z6","PC-MUM29LZ7RDM5":"NEC Mate MU29L/Z7","FMVA03TK1":"Fujitsu LIFEBOOK A03/TK1","FMVA07TK1":"Fujitsu LIFEBOOK A574/KX","FMVA09TK1":"Fujitsu LIFEBOOK A574/KX","FMVA22TK2":"Fujitsu LIFEBOOK AH22/TK2","FMVA50D1WP":"Fujitsu LIFEBOOK AH50/D1","FMVA55E3GC":"Fujitsu LIFEBOOK AH55/E3","FMVA62TK2":"Fujitsu LIFEBOOK AH62/TK2","FMVA82TK2":"Fujitsu LIFEBOOK AH82/TK2","FMVN90D2B":"Fujitsu LIFEBOOK NH90/D2","FMVS02TK1":"Fujitsu LIFEBOOK S904/KX","FMVU14TK1":"Fujitsu LIFEBOOK U748/TX","FMVU19001":"Fujitsu LIFEBOOK U939/B","20J8A01DJP":"Lenovo ThinkPad L470","F7-i5ICLAS-A":"mouse UNKNOWN","IStNXi-15FH050":"mouse computer iStNXi-15FH050","PC-NS750BAB":"NEC LAVIE Note Standard NS750/BAB","PC-VJ23TLZGT":"NEC VersaPro VJ23T/L-G","PC-VK17HBBCD":"NEC VersaPro VK17H/B","PC-VKT25FB7R3R3":"NEC VersaPro VK25T/B","VK24LFWZ3TZG":"NEC VersaPro VK24L/FW","FMVF70B3W":"Fujitsu ESPRIMO FH70/B3","FMVF90B3B":"Fujitsu ESPRIMO FH90/B3","FMVF56B1LB":"Fujitsu ESPRIMO FH56/B1","FMVF77B3B":"Fujitsu ESPRIMO FH77/B3","FMVF52B1W":"Fujitsu ESPRIMO FH52/B1","FMVF90D2B":"Fujitsu ESPRIMO FH90/D2","FMVF77B1B":"Fujitsu ESPRIMO FH77/B1","FMVF70C2W":"Fujitsu ESPRIMO FH70/C2","FMVF52WW":"Fujitsu ESPRIMO FH52/WW","FMVF90B3B2":"Fujitsu ESPRIMO FH90/B3","81VV":"Lenovo IdeaPad Slim 350i 15IIL05","FMVU14008":"Fujitsu LIFEBOOK U747/R","FMVF77D1B":"Fujitsu ESPRIMO FH77/D1","FMVF70D3W":"Fujitsu ESPRIMO FH70/D3","FMVF77C2B":"Fujitsu ESPRIMO FH77/C2","FMVF90C3B":"Fujitsu ESPRIMO FH90/C3","FMVF77B1BK":"Fujitsu ESPRIMO FH77/B1","FMVF70D1W":"Fujitsu ESPRIMO FH70/D1","FMVK09001":"Fujitsu ESPRIMO K09001","FMVF90B2B":"Fujitsu ESPRIMO FH90/B2","FMVF77E3BB":"Fujitsu ESPRIMO FH77/E3","FMVF77B1WK":"Fujitsu ESPRIMO FH77/B1","MB-4H751ABW11-CT":"mouse computer MousePro MB-4H7","FMVA58A3WN":"Fujitsu LIFEBOOK AH58/A3","FMVA42C2R":"Fujitsu LIFEBOOK AH42/C2","PC-VKT16BZG6":"NEC VersaPro VKT16/B-6","FMVA77B1B":"Fujitsu LIFEBOOK AH77/B1","FMVS16001":"Fujitsu LIFEBOOK S938/S","82R9":"Lenovo IdeaPad Slim 5 14ALC6","PC-VK20EANEK":"NEC VersaPro VK20E/A-NE-K","FMVA45G2W":"Fujitsu LIFEBOOK AH45/G2","FMVNFC50W":"Fujitsu FMV-BIBLO NF/C50W","PT57-43MSXB":"Toshiba dynabook T57/43M","FMVA40RWJ":"Fujitsu LIFEBOOK AH40/RW","FMVS90B1W":"Fujitsu LIFEBOOK S90/B1","FMVA45SBP":"Fujitsu LIFEBOOK AH45/SB","FMVS75WWP":"Fujitsu LIFEBOOK S75/W","FMVWA3A25B":"Fujitsu LIFEBOOK WA3/A2","FMVA77YB":"Fujitsu LIFEBOOK AH77/YB","FMVA53UB":"Fujitsu LIFEBOOK AH53/UB","PT67TGP-SWA":"dynabook T67/TG","FMVA53A3B":"Fujitsu LIFEBOOK AH53/A3","P2T7KPBG":"dynabook T7/KP","FMVS90TW":"Fujitsu LIFEBOOK SH90/TW","PC-VY22MAZ79":"NEC VersaPro VY22M/A","PC-VK25LXZNN":"NEC VersaPro VK25L/X-NN","FMVA45C2G2":"Fujitsu LIFEBOOK AH45/C2","PT75AGP-BJA2":"dynabook T75/AGP","PC-VK24LXZNH":"NEC VersaPro VK24L/X-NH","FMVA47UWC":"Fujitsu LIFEBOOK AH47/UW","FMVA77MR":"Fujitsu LIFEBOOK AH77/M","FMVA26004":"Fujitsu LIFEBOOK A576/N","PC-NM550RAW":"NEC LAVIE Note Mobile NM550/RAW","FMVA6602BP":"Fujitsu LIFEBOOK AH66/D2","PT75UGS-BWB3":"dynabook T75/UG","PT75VGP-BJA":"Toshiba dynabook T75/VG","FMVA51E1WN":"Fujitsu LIFEBOOK AH51/E1","FMVA50B3W2":"Fujitsu LIFEBOOK AH50/B3","PT75TRP-BWA":"dynabook T75/TRP","PC-VK19EXZDH":"NEC VersaPro VK19E/X-DH","FMVA42D1W":"Fujitsu LIFEBOOK AH42/D1","FMVU55MLY":"Fujitsu LIFEBOOK U55/ML","PC-VK25TXZGV":"NEC VersaPro VK25T/X-G","PC-GN16CJSA9":"NEC LAVIE Note Standard GN16C/JS","FMVS90WW":"Fujitsu LIFEBOOK S936/W","FMVA53A3W":"Fujitsu LIFEBOOK AH53/A3","FMVA77WB":"Fujitsu LIFEBOOK AH77/WB","FMVA78WBZ2":"Fujitsu LIFEBOOK AH78/WB","FMVF73D1BK":"Fujitsu ESPRIMO FH73/D1","FARR77B1":"Fujitsu ARROWS Tab R727/B1","FMVF55B1WC":"Fujitsu ESPRIMO FH55/B1","FMVF70B3BK":"Fujitsu ESPRIMO FH70/B3","PC-GD242TCAA":"NEC LAVIE Desk All-in-one DA370/CAB","FMVS90TWD1":"Fujitsu LIFEBOOK SH90/TW","FMVE0600M":"Fujitsu ESPRIMO E0600/M","FMVU75B3R":"Fujitsu LIFEBOOK UH75/B3","A1502":"MacBook Pro 13 2013/2014 (A1502)","GI7j-C91/T":"TSUKUMO G-GEAR mini GI7j-C91/T","10UR001WJP":"Lenovo ThinkCentre M710s","PC-MRL36LZAAS5":"NEC Mate MRL36L/ZA","10B7007NJP":"Lenovo ThinkCentre M73 Tiny","FMVD3300YP":"Fujitsu ESPRIMO D3300/YX","PC-MRL36LZ6AAS5":"NEC Mate MRL36L/6A","PB354KBB482JD7Y":"dynabook Satellite B35/R","FMVA58A3BN":"Fujitsu LIFEBOOK AH58/A3","81VR":"Lenovo IdeaPad 330-15AST","FMVA53UR":"Fujitsu LIFEBOOK AH53/U","FMVA30C3B4":"Fujitsu LIFEBOOK AH30/C3","PC-GN234FSA8":"NEC LAVIE Note Standard GN234FSA8","FMVA36018":"Fujitsu LIFEBOOK AH36/A","FMVA77YR":"Fujitsu LIFEBOOK AH77/Y","FMVA30A3W5":"Fujitsu LIFEBOOK AH30/A3","A1466":"MacBook Air 13 2015","B5-R7RENBSW11":"mouse computer MousePro NB5 (B5-R7RENBSW11)","FMVA0501MP":"Fujitsu LIFEBOOK A50/01MP","PC-VKT16BZG5":"NEC VersaPro VKT16/B-5","PC-VJ20MANCFHAXA":"NEC VersaPro VJ20M/A","VK25TXZGV":"NEC VersaPro VK25T/X-GV","PC-VK19EXDH":"NEC VersaPro VK19E/X-DH","A1311":"Apple iMac 27-inch Mid 2011 (A1311)","FMVWC2F17D":"Fujitsu ESPRIMO FHシリーズ","A2681":"MacBook Air M2 2022","A6B9DPV4B522":"dynabook B45/DP","A6BCHUEAPA25":"dynabook B65/HU","A6BCHUF8LN25":"dynabook B65/HU","A6BSERN8BA21":"dynabook B65/ER","A6BSERN8BA71":"dynabook B65/ER","PB65JAB44N7AD11":"dynabook B65/J","PB65MDB44N7AD11":"dynabook B65/M","PB65MTB41N7AD11":"dynabook B65/M","PB6DNDB4CN7BD1":"dynabook B65/DN","PB6DNDJ4CN7FD1":"dynabook B65/DN","PB6DNTB44R7FD1":"dynabook B65/DN","PB6DNTJ44N7BD1":"dynabook B65/DN","PR63FBA4447AD11":"dynabook R63/F","N8K04AV-AACS":"HP ProBook 450 G3","T9R66PT#ABJ":"HP ProBook 450 G3","20F36PA#ABJ":"HP ProBook 450 G7","CU7-155U-155U":"HP ProBook 460 G11","PC-VK25LXZCJ":"NEC VersaPro VK25L/X-CJ","PC-VKT16XBGMAT6":"NEC VersaPro VKT16/X-B","20U4S0MH00":"Lenovo ThinkPad L15 Gen1","21JQS3AP00":"Lenovo ThinkPad E16 Gen1 (Intel)","20LW001BJP":"Lenovo ThinkPad L580","20W1S30V2P":"Lenovo ThinkPad T14 Gen2","20QES8UR00":"Lenovo ThinkPad X1 Carbon Gen7 2019","20UAS18U00":"Lenovo ThinkPad X1 Carbon Gen8","20UAS9YA00":"Lenovo ThinkPad X1 Carbon Gen8","20XXS45K00":"Lenovo ThinkPad X1 Carbon Gen9","20A8S0V100":"Lenovo ThinkPad X1 Carbon Gen2","21CCS0RE00":"Lenovo ThinkPad X1 Carbon Gen10","21CCS1R200":"Lenovo ThinkPad X1 Carbon Gen10","A6SBHSFAD611":"dynabook S73/HS","A6A1XYL7611A":"dynabook GA83/XY","A6G2LWKD561A":"dynabook G83/LW","A6G2LYD8131A":"dynabook G83/LY","A6G4MYKD1F1A":"dynabook G83/MY","PG83MTCCGPBAD21":"dynabook G83/M","PR63DEAA54CAD81":"dynabook R63/D","PU63DBCAUPBAD11":"dynabook U63/D","7RP04PA":"HP ProBook 430 G6","678W1PA#ABJ":"HP ProBook 430 G8","678W1PA":"HP ProBook 430 G8","836C9PA-AAAE":"HP ProBook 445 G10","926J2PA#ABJ":"HP ProBook 630 G10 (926J2PA#ABJ)","B4TG2PT#ABJ":"HP ProBook 630 G11","6X729PA#ABJ:W10":"HP ProBook 630 G9","7K389PA#ABJ":"HP EliteBook 830 G9 (7K389PA#ABJ)","PC-VK23TGWGU":"NEC VersaPro VK23T/G","VKT13HZG4":"NEC VersaPro VKT13/H-4","PC-VKT16BZG9":"NEC VersaPro VKT16/BZG9","PC-VKV15HZG4":"NEC VersaPro VKV15H/ZG4","Z15W:MOS1*":"MacBook Air M2 2022","MWP72J/A":"MacBook Pro 13 2019","20R4S2F800":"Lenovo ThinkPad L13 Gen1","21B4S0GH00":"Lenovo ThinkPad L13 Gen3","21FHS05400":"Lenovo ThinkPad L13 Gen4","20T3S0EJ00":"Lenovo ThinkPad X13 Gen1","20WLS8PL00":"Lenovo ThinkPad X13 Gen2","20WLSA2X00":"Lenovo ThinkPad X13 Gen2","21BQS0N000":"Lenovo ThinkPad X13 Gen3","21BQS9XQ00":"Lenovo ThinkPad X13 Gen3","21EYS07Y00":"Lenovo ThinkPad X13 Gen4","20KES06400":"Lenovo ThinkPad X280","20KES72X00":"Lenovo ThinkPad X280","21HNS15A00":"Lenovo ThinkPad X1 Carbon Gen11","21HNS06F00":"Lenovo ThinkPad X1 Carbon Gen11","FMVU19011":"Fujitsu LIFEBOOK U939/A","FMVU34017":"Fujitsu LIFEBOOK U9311/F","J9980A#ACF":"HP Aruba 1820-24G Switch (J9980A#ACF)","J9777A#ACF":"HP Aruba 2530 8G Switch (J9777A#ACF)","C841M-4X-JAIS/K9":"Cisco 841M ISR (C841M-4X-JAIS/K9)","X4C-3.4G-E2224":"Dell Precision 3431 SFF","X28C-2.7G*2-8280M":"Dell Precision 7920 Tower","X4C-3.3G-E31225v5":"Dell Precision T3620 Workstation","XQC-3.5G-E31240v5":"Dell Precision Tower 3620","L8T12AV-AABR":"HP Z240 Workstation","XQC-3.3G-E31225v5":"HP Z240 Workstation","9JD40AV-ACNX":"HP Z2 Mini G5 Workstation","X6C-4.1-W1250P":"HP Z2 Mini G5 Workstation","A4JC2PA#ABJ":"HP Z2 Mini G9 Workstation","1JP11AV-AVGX":"HP Z4 G4 Workstation","X4C-3.6G-W2123":"HP Z4 G4 Workstation","1JP11AV-BAVM":"HP Z4 G4 Workstation","X8C-3.7G-W2145":"HP Z4 G4 Workstation","1JP11AV-BWAR":"HP Z4 G4 Workstation 1JP11AV-BWAR","1JP11AV-CXNU":"HP Z4 G4 Workstation","X4C-3.6G-W2223":"HP Z4 G4 Workstation","1JP11AV-DJIC":"HP Z4 G4 Workstation","1JP11AV-DNOO":"HP Z4 G4 Workstation","Z3Z16AV-BRJW":"HP Z8 G4 Workstation","18N67PA-AAAA":"HP ZBook Firefly 14 G7","81D06PA-AAAB":"HP ZBook Firefly 14 G10","3WN84PA-AAAB":"HP ZBook 14u G5","3AX06AV-AABM":"HP ZBook 15 G5","1Y2G3PA-AAAB":"HP ZBook Studio G7","4N7X8PA-AAAA":"HP ZBook Studio G8","20W7S0P400":"Lenovo ThinkPad P15s Gen2","21AAS0SV00":"Lenovo ThinkPad P15v Gen2","JY682A":"HP Aruba AP-303H (JP) Unified AP","15-A9X/11":"Apple iPad Pro 12.9 2016 Wi‑Fi 32GB (ML0F2J/A)","EIG-00026":"Microsoft Surface Pro 8","QBS1250":"Dell Pro Slim Plus QBS1250","4G4N8AV-AFBS":"HP ProDesk 400 G9 DM Mini","7E8K2AV-AADK":"HP Pro Mini 400 G9 (7E8K2AV-AADK)","7E8Y0AV-AABL":"HP ProDesk 400 G9 SFF","Y3F34AV-ABTW":"HP ProDesk 600 G3 SFF","2VG42AV-AEAP":"HP ProDesk 600 G4 SFF","4K1Q8PA#ABJ":"HP ProDesk 600 G6 SFF (4K1Q8PA#ABJ)","54K52AV-AABF":"HP ProDesk 600 G9 SFF","54K52AV-BLPI":"HP ProDesk 600 G9 SFF","Z9Y29AV-AFWY":"HP EliteDesk 800 G3 DM","Y2Z63AV-AZAZ":"HP EliteDesk 800 G3 SF","Y2Z63AV-BFWC":"HP EliteDesk 800 G3 SFF","2US83AV-AMVP":"HP EliteDesk 800 G4 SFF","6AU21AV-BTWS":"HP EliteDesk 800 G5 DM","6AU21AV-BTYP":"HP EliteDesk 800 G5 DM","6BD64AV-AAAS":"HP EliteDesk 800 G5 SFF","6BD64AV-CUCF":"HP EliteDesk 800 G5 SFF","8YM57AV-CMFZ":"HP EliteDesk 800 G6 SFF","27P59AV-ABWD":"HP EliteDesk 800 G8 Tower Workstation (TW)","27P59AV-ABWF":"HP EliteDesk 800 G8 Tower Workstation (TW)","550B5AV-BHWG":"HP Elite Mini 800 G9 (550B5AV-BHWG)","4G087AV-BXDN":"HP EliteDesk 800 G9 SFF","519Q1AV-AAAC":"HP Elite Tower 800 G9 (519Q1AV-AAAC)","QV996AV-BIUE":"HP Elite 8300 SF (QV996AV-BIUE)","F0S60PA":"HP Pro 6300 SFF","PC-MKL36BZG6":"NEC Mate MKL36/B","PC-MKM21CZG3":"NEC Mate MKM21C/C","PC-MKM27CZG1":"NEC Mate MKM27/C","EF-9999DAA":"EPSON Endeavor ST200E","10SUS4SN00":"Lenovo ThinkCentre M720s","MacBookAir9,1":"MacBook Air 13 2020","QF2-00014":"Microsoft Surface Pro 3 QF2-00014","3050SFF(10P)":"Dell OptiPlex 3050 SFF","5050SFF(10P)":"Dell OptiPlex 5050 SFF","OPTIPLEX7050SFF":"Dell OptiPlex 7050 SFF","AS10T8S5400G":"Lenovo ThinkCentre M720q Tiny","1AE80AV(10P)":"HP ProDesk 400 G3 DM","3580-I5-7200U":"Dell Latitude 3580","JB1BVT2":"Dell Latitude 5490","20HMS40F00":"Lenovo ThinkPad X270","20AWS27D00":"Lenovo ThinkPad T440p","20AUS1MG00":"Lenovo ThinkPad L540","20J8S01L00":"Lenovo ThinkPad L570","21CNS0G30J":"Lenovo ThinkPad X13 Gen3 AMD","20U4S0CT00":"Lenovo ThinkPad L15 Gen1","20QGS04P00":"Lenovo ThinkPad X1 Yoga Gen3","2VX21AV-AAAB":"HP ProBook 650 G4","N8K04AV":"HP ProBook 450 G3","V6E11AV(10P)":"HP ProBook 450 G3","4QA81AV-AAAC":"HP ProBook 430 G5","PR63PBAA637AD11":"dynabook R63/P","PG83MTACG37AD21":"dynabook G83/MT","PB65HEB44F7AD11":"dynabook B65/H","PR73MEA4447AD21":"dynabook R73/M","A6B5DPG8C921":"dynabook B65/DP (A6B5DPG8C921)","CF-XZ6RD3VS":"Panasonic Let’s note XZ6 CF-XZ6RD3VS","9FKSC88477":"Panasonic Let’s note SZ6 CF-SZ6RDYVS","21BQS5XH00":"Lenovo ThinkPad X13 Gen3","20WKS05D00":"Lenovo ThinkPad X13 Gen2","20R1S0PS00":"Lenovo ThinkPad X1 Carbon Gen7","VJPG13C11N":"VAIO Pro PG (VJPG13)","FMVA64001":"Fujitsu LIFEBOOK A640/D","20QDCTO1WW":"Lenovo ThinkPad X1 Carbon Gen7","20KHCTO1WW":"Lenovo ThinkPad X1 Carbon Gen6","PF176SPK":"Lenovo ThinkPad X1 Carbon Gen6","PF176SRK":"Lenovo ThinkPad X1 Carbon 6th Gen (2018)","CFSZ5-3":"Panasonic Let's note SZ5 CF-SZ5PDQ6S","CF-SZ5PDQ6S":"Panasonic Let’s note SZ5 CF-SZ5PDQ6S","3443CTO":"Lenovo ThinkPad X1 Carbon (1st Gen)","20BTCTO1WW":"Lenovo ThinkPad X1 Carbon Gen3","PC-VRL23FBGS4R5":"NEC VersaPro VRL23F/B","PC-VRL23FBGS4R4":"NEC VersaPro VRL23F/B","L1G77AV":"HP EliteDesk 800 G2 TWR","FMVD43001":"Fujitsu ESPRIMO D430/M","PC-MRL36LZGAAS6":"NEC Mate MRL36L/G","iMac20.1":"Apple iMac 27 2020 (iMac20,1)","Core i7-1068NG7":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","C02G614CML87":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","1068NG7":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","C02DX9AQML7H":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","C02F61L6MD6T":"MacBook Pro 16 2019","C02DW2MEMD6T":"MacBook Pro 16 2019","C02GL0ANMD6R":"MacBook Pro 16 2019","C02F910PML7H":"MacBook Pro 13 2020 (Four Thunderbolt 3 ports)","MacBookAir9.1":"MacBook Air 13 2020","MacBookPro15.4":"MacBook Pro 13 2019 (Two Thunderbolt 3 ports)","MacBookAir8.2":"MacBook Air 13 2019","MacBookAir8.1":"MacBook Air 13 2018","MacBookPro14,1":"MacBook Pro 13 2017 (Two Thunderbolt 3 ports)","C02VT1A8HV2J":"MacBook Pro 13 2017 (Two Thunderbolt 3 ports)","MacBookPro12.1":"MacBook Pro 13 2015","C02SY1G3FVH4":"Apple MacBook Pro 13 Early 2015 (MacBookPro12,1)","FMVA51J3BN":"Fujitsu LIFEBOOK AH51/J3","PC-GN20A3JGZ":"NEC LAVIE N16 N1675/JAL","PC-GN20A3JAZ":"NEC LAVIE N16 N1675/JAL","ZA9C-R37T":"dospara GALLERIA ZA9C-R37T","P3C5XSEE":"dynabook C5/X (P3C5XSEE)","FMVA53E2BG":"Fujitsu LIFEBOOK AH53/E2","FMVA77E2BG":"Fujitsu LIFEBOOK AH77/E2","P1E9MJBL":"dynabook T9/E (P1E9MJBL)","PCNS700KARE3":"NEC LAVIE Note Standard NS700/KAR","FMVA51C3W2":"Fujitsu LIFEBOOK AH51/C3","FMVA77B1WG":"Fujitsu LIFEBOOK AH77/B1","PCNS650GAW":"NEC LAVIE Note Standard NS650/GAW","PCNS750GARE3":"NEC LAVIE Note Standard NS750/GAE3","PT75DGSBJA3":"dynabook T75/DGS","PT75DWSBJA3":"dynabook T75/DW","PCNS700FARE3":"NEC LAVIE Note Standard NS700/FAR","FMVA53A3BG":"Fujitsu LIFEBOOK AH53/A3","PT75BGS-BJA3":"dynabook T75/BGS","PCNS750EARE3":"NEC LAVIE Note Standard NS750/EA","PTEX-85ABJG":"dynabook EX/85ABJG","PT75AWSBJA3":"TOSHIBA dynabook T75/AW","PT75BWSBJA3":"dynabook T75/BW","PAZ75VGBJA":"dynabook AZ75/VGB PAZ75VGBJA","PCNS750DABE3":"NEC LAVIE Note Standard NS750/DAB-E3","PCNS750EABE3":"NEC LAVIE Note Standard NS750/EAB","PT55FBS-SJA3":"dynabook T55/FBS","PT55VWSBJA3":"TOSHIBA dynabook T55/VW","PT55VRSBJA3":"TOSHIBA dynabook T55/VRS","FMVA10005":"Fujitsu LIFEBOOK A574/H","PCNS300NARE3":"NEC LAVIE Note Standard NS300/NA","PCNS350NABE3":"NEC LAVIE Note Standard NS350/NAB","PCNS350GAB":"NEC LAVIE Note Standard NS350/GAB","PCNS350HAR":"NEC LAVIE Note Standard NS350/HA","PCNS350HARE3":"NEC LAVIE Note Standard NS350/HA","PCNS300MAW":"NEC LAVIE Note Standard NS300/MAW","PCNS300KARE3":"NEC LAVIE Note Standard NS300/KAR","PCNS300KAWE3":"NEC LAVIE Note Standard NS300/KAW","PCNS300KABE3":"NEC LAVIE Note Standard NS300/KAB","PCNS300MARE3":"NEC LAVIE Note Standard NS300/MAR","FMVA45A3W":"Fujitsu LIFEBOOK AH45/A3","PCNS350EABE3":"NEC LAVIE Note Standard NS350/EAB","PCNS350DAWE3":"NEC LAVIE Note Standard NS350/DAW","PCNS350EAWE3":"NEC LAVIE Note Standard NS350/EAW","80E502UBJP":"Lenovo IdeaPad 100 15IBD","LBC410E6HB2021":"mouse computer LBC410E6HB2021 UNKNOWN","PCGN11FLRAD":"NEC LAVIE Note Standard NS150/FAR","PCNS100K2WH6":"NEC LAVIE Note Standard NS100/K2","P1B2LSEB":"dynabook B25/L (P1B2LSEB)","PT45DGSSJA3":"dynabook T45/DG","PCNS150HAB":"NEC LAVIE Note Standard NS150/HAB","PT45CGS-SJA3":"dynabook T45/CGS","PCNS150FAR":"NEC LAVIE Note Standard NS150/FAR","PCNS150GARKS":"NEC LAVIE Note Standard NS150/GAR","PCNS100F2W-H4":"NEC LAVIE Note Standard NS100/F2W-H4","VJF156C11N":"VAIO Fit 15E VJF156C11N","PB2533BRJB":"dynabook Satellite B25/33B","FMVA42WR":"Fujitsu LIFEBOOK AH42/W","PB35RNAD483AD51":"TOSHIBA dynabook Satellite B35/RN","FMVA42WB":"Fujitsu LIFEBOOK AH42/WB","PCGN21DJSA9":"NEC LAVIE Note Standard NS150/DJ","FMVA43D3BG":"Fujitsu LIFEBOOK AH43/D3","FMVA43D1BP":"Fujitsu LIFEBOOK AH43/D1","FMVA30C2W":"Fujitsu LIFEBOOK AH30/C2","FMVU90C3RG":"Fujitsu LIFEBOOK UH90/C3","CFSZ6P2LLC":"Panasonic Let’s note SZ6 CF-SZ6P2LLC","FMVU55B3LB":"Fujitsu LIFEBOOK U55/B3","PCHZ350GAB":"NEC LAVIE Hybrid ZERO HZ350/GAB","PCNM150MAW":"NEC LAVIE Note Mobile NM150/M","FMVF77B1KG":"Fujitsu ESPRIMO FH77/B1","FMVF90B2BG":"Fujitsu FMV ESPRIMO FH90/B2","PCDA570GABE3":"NEC LAVIE Desk All-in-one DA570/GAB","PCDA570FABJ":"NEC LAVIE Desk All-in-one DA570/FABJ","PCDA770EARE3":"NEC LAVIE Desk All-in-one DA770/EAR","FMVW77WB":"Fujitsu ESPRIMO FH77/WB","FMVF52E1WG":"Fujitsu ESPRIMO FH52/E1","PCDA370MAB":"NEC LAVIE Desk All-in-one DA370/MAB","FMVF52B3GG":"Fujitsu ESPRIMO FH52/B3","FMVF52D1PG":"Fujitsu ESPRIMO FH52/D1","PCDA370DARE3":"NEC LAVIE Desk All-in-one DA370/DA","PD41UWSSWA3":"dynabook REGZA PC D41/UW","Mac14.9":"MacBook Pro 14 2023","MacBookPro18,1":"MacBook Pro 16 2021","MacBookPro18,3":"MacBook Pro 14 2021","MacBookPro18,4":"MacBook Pro 14 2021","L9931GDM2F":"MacBook Pro 14 2021","F93K4P4P22":"MacBook Pro 14 2021","TKJF69GXTD":"MacBook Pro 14 2021","K960NJVJYW":"MacBook Pro 14 2021","FVFH50YZQ6LX":"MacBook Air M1 2020","FMVS14TK1":"Fujitsu LIFEBOOK S14/TK1","20R1S0QS00":"Lenovo ThinkPad L13 Gen1","MW1J3J/A":"MacBook Air 15 M4 2025","FMVA77B1W":"Fujitsu LIFEBOOK AH77/B1","PC-VKE18EZG3":"NEC VersaPro VKE18/EZ","PC-VKE18EZG4":"NEC VersaPro VKE18/E","N905-KJP-S":"Rakuten Kobo Touch N905-KJP-S","FMVA58C2BN":"Fujitsu LIFEBOOK AH58/C2","PC-DA770HAB-N":"NEC LAVIE Desk All-in-one DA770/HAB","81D6":"Lenovo IdeaPad 330-15AST","MS-7C02":"MSI MS-7C02 (B450M MORTAR MAX)","FMVA42E1W1":"Fujitsu LIFEBOOK AH42/E1"};

// localStorage学習済み追加分
const getLearnedMap = () => {
  try { return JSON.parse(localStorage.getItem('model_map_learned') || '{}'); }
  catch { return {}; }
};
const saveLearnedMap = (m) => {
  try { localStorage.setItem('model_map_learned', JSON.stringify(m)); } catch {}
};

// 内部型番っぽいかどうか判定
const isInternalCode = (code) => {
  if (!code || code.length < 4 || code.length > 30) return false;
  // 既に正式名（スペース含む）なら不要
  if (/\s/.test(code) && code.length > 10) return false;
  // ProBook, ThinkPad等の正式名パターン
  if (/^(ProBook|EliteBook|ThinkPad|Latitude|Inspiron|LIFEBOOK|VersaPro|MacBook|VAIO|dynabook|IdeaPad|Mate\s)/i.test(code)) return false;
  // Windows PC名 (DESKTOP-xxxxx)
  if (/^DESKTOP-/i.test(code)) return true;
  // Fujitsu: FMVxxxx
  if (/^FMV[A-Z][A-Z0-9]{5,}/i.test(code)) return true;
  // NEC: PCxxxxxx, PCN/PCG/PCDA, VK/MK型番
  if (/^PC-?[A-Z]?[A-Z0-9]{6,}/i.test(code)) return true;
  if (/^[VM]K[A-Z0-9]{4,}/i.test(code)) return true;
  // dynabook: PTxxxx, PBxxxx, A6xxxx
  if (/^P[TB][0-9]{2}[A-Z]/i.test(code)) return true;
  if (/^A6[A-Z]{2,}/i.test(code)) return true;
  // Lenovo: 20xxxx, 81xx, 82xx
  if (/^(20|21|81|82)[A-Z0-9]{2,8}$/i.test(code)) return true;
  // VAIO: VJxxx
  if (/^VJ[A-Z][0-9]{3}/i.test(code)) return true;
  // 英数混在で短い（一般的な内部型番）
  const letters = (code.match(/[a-zA-Z]/g) || []).length;
  const digits = (code.match(/[0-9]/g) || []).length;
  if (letters >= 2 && digits >= 3 && code.length <= 15) return true;
  return false;
};

// 型番解決（同期: map検索のみ）
const resolveModelLocal = (code) => {
  if (!code) return null;
  const clean = code.replace(/\(.*\)/, '').trim();
  
  // 1. パターンマッチ優先（確実な変換）
  const PATTERNS = [
    // VAIO: VJZ=Z, VJPJ=Pro PJ, VJPG=Pro PG, VJS=SX/S, VJF=F/FE, VJPB=Pro PB
    [/^VJZ\d/i, 'VAIO Z'],
    [/^VJPJ\d/i, 'VAIO Pro PJ'],
    [/^VJPG\d/i, 'VAIO Pro PG'],
    [/^VJPB\d/i, 'VAIO Pro PB'],
    [/^VJS\d/i, 'VAIO SX'],
    [/^VJF\d/i, 'VAIO F'],
    [/^VJP1[123]\d/i, 'VAIO Z'],
    // dynabook A6xxx = Gシリーズ
    [/^A6G[A-Z]/i, 'dynabook G'],
    [/^A6B[A-Z]/i, 'dynabook B65'],
    [/^A6C[A-Z]/i, 'dynabook C'],
    // NEC VK/MK = VersaPro/Mate
    [/^VKM?\d/i, 'NEC VersaPro'],
    [/^MK[A-Z0-9]/i, 'NEC Mate'],
  ];
  for (const [pat, name] of PATTERNS) {
    if (pat.test(clean)) return name;
  }
  
  // 2. BASE_MODEL_MAP完全一致
  if (BASE_MODEL_MAP[clean]) return BASE_MODEL_MAP[clean];
  
  // 3. localStorage学習（バリデーション付き）
  const learned = getLearnedMap();
  if (learned[clean]) {
    const val = learned[clean];
    // 内部型番が結果に含まれてたら不正（前のハルシネ）→ 削除
    if (clean.length > 6 && val.includes(clean.slice(0, 6))) {
      console.warn(`🗑️ 不正な学習結果を削除: ${clean} → ${val}`);
      delete learned[clean];
      saveLearnedMap(learned);
      return null;
    }
    return val;
  }
  return null;
};

// 型番解決（非同期: GPT-5.2）
const resolveModelAI = async (code, context, apiKey) => {
  if (!apiKey || !code) return null;
  const prompt = `PC内部型番→正式名に変換。1行のみ出力。不明なら"UNKNOWN"。

${code}${context ? ' (' + context + ')' : ''}

例: FMVA51F1WG→Fujitsu LIFEBOOK AH51/F1, PCNS600NAB→NEC LAVIE Note Standard NS600/NA, PT75VGSBJB3→dynabook T75/VG, 20KQS26G00→Lenovo ThinkPad X1 Carbon Gen6, VJPJ218001434→VAIO Pro PJ, VJZ141→VAIO Z, A6GNKWKGH6DA→dynabook G8/KW, PB65JFB11R7PC2X→dynabook B65/J`;
  try {
    const result = await callOpenAI(apiKey, [{ role: 'user', content: prompt }], 60, 'gpt-5.2');
    const line = result.split('\n')[0].trim().replace(/^["']|["']$/g, '');
    if (!line || line === 'UNKNOWN' || line.length <= 3) return null;
    // 内部型番がそのまま含まれてたら拒否
    if (code.length > 6 && line.includes(code.slice(0, 6))) return null;
    // 学習保存
    const learned = getLearnedMap();
    learned[code] = line;
    saveLearnedMap(learned);
    console.log(`📘 型番学習: ${code} → ${line}`);
    return line;
  } catch (e) {
    console.error('型番AI解決エラー:', e);
    return null;
  }
};


// Mac年式・モデル判定（GPT-5.2）
const resolveMacModel = async (apiKey, specs) => {
  if (!apiKey) return null;
  const info = [
    specs.cpu && `CPU: ${specs.cpu}`,
    specs.gpu && `GPU: ${specs.gpu}`,
    specs.display && `Display: ${specs.display}`,
    specs.memory && `Memory: ${specs.memory}`,
    specs.storage && `Storage: ${specs.storage}`,
    specs.model && `Model: ${specs.model}`,
    specs.size && `Size: ${specs.size}`,
    specs.chip && `Chip: ${specs.chip}`,
  ].filter(Boolean).join(', ');
  
  const prompt = `MacBookのスペックから正確なモデルと年式を判定。JSON1行のみ出力。

${info}

判定のヒント:
- Iris Plus 1536MB + 13.3" = MacBook Pro 2020 13"
- Iris Plus 645 + 13.3" = MacBook Pro 2019/2018 13"
- Intel HD 6000 + 13.3" = MacBook Pro 2015 13"
- Radeon Pro 5500M + 16" = MacBook Pro 2019 16"
- AMD Radeon Pro 560X = MacBook Pro 2018/2019 15"
- M1/M2/M3/M4 = Apple Silicon (year from chip)

出力: {"model":"MacBook Pro","year":"2020","size":"13.3"}
不明なら: {"model":"MacBook Pro","year":"","size":""}`;

  try {
    const result = await callOpenAI(apiKey, [{ role: 'user', content: prompt }], 80, 'gpt-5.2');
    const clean = result.replace(/```json|```/g, '').trim();
    const json = JSON.parse(clean);
    return json;
  } catch(e) {
    console.error('Mac判定エラー:', e);
    return null;
  }
};

// OpenAI API
// ⚠️ gpt-5-miniはreasoning model。デフォルトでmedium推論が走り、
// max_completion_tokensの大半がreasoning tokensに消費される。
// 例: max=600 → reasoning=500+, 出力=100以下 → JSON途中切れ → パース失敗
// → 画像結合(merge)・OCR・紹介文が全て無反応になる。
// 対策: reasoning_effort='minimal'を必ず指定 + max_completion_tokensを余裕もって設定。
// gpt-4.1-miniにはreasoning tokensがないためこの問題は起きなかった。
const callOpenAI = async (key, msgs, max = 200, model = 'gpt-5-mini') => {
  const body = { model, messages: msgs, max_completion_tokens: max };
  // GPT-5系はreasoning model → minimal推論でトークン節約
  if (model.startsWith('gpt-5')) body.reasoning_effort = 'minimal';
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
    body: JSON.stringify(body)
  });
  const d = await r.json();
  if (d.error) throw new Error(d.error.message);
  return d.choices[0].message.content.trim();
};

// Claude API呼び出し（テキスト生成用）
// modelOpt: 'haiku'(default) or 'sonnet'
const CLAUDE_MODELS = {
  haiku: 'claude-haiku-4-5-20251001',
  sonnet: 'claude-sonnet-4-5-20250929'
};
const callClaude = async (key, prompt, max = 500, modelOpt = 'haiku') => {
  const model = CLAUDE_MODELS[modelOpt] || CLAUDE_MODELS.haiku;
  const r = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': key,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify({
      model,
      max_tokens: max,
      messages: [{ role: 'user', content: prompt }]
    })
  });
  const d = await r.json();
  if (d.error) throw new Error(d.error.message || JSON.stringify(d.error));
  return (d.content || []).map(c => c.text || '').join('').trim();
};

// OCR（gpt-5-mini + プロンプト改善）
const ocrBarcode = async (key, dataUrl) => {
  const smallUrl = await shrinkForAPI(dataUrl, 1024);
  const result = await callOpenAI(key, [{
    role: 'user',
    content: [
      { type: 'text', text: `このバーコードラベルの番号を正確に読み取ってください。
バーコードの下に印字されている数字列をそのまま返してください。
ハイフンを含む場合はハイフンの後ろの数字列のみ返してください。
例: 「55500000001-0000113510」→「0000113510」
例: 「SEL55500000001-0000154368」→「0000154368」
返答はハイフン後の数字のみ。文字や説明は一切不要。` },
      { type: 'image_url', image_url: { url: smallUrl, detail: 'high' } }
    ]
  }], 200, 'gpt-5-mini');
  const digits = result.trim().replace(/[^0-9]/g, '');
  if (!digits || digits.length < 3) return null;
  return digits.slice(-6);
};

// スペック画像からPC情報を抽出（バーコード無し時に使用）
const ocrSpecs = async (key, images, needMakerID = false) => {
  // info/spec画像を最大3枚送信。categoryなし時はバーコード以外の画像から選択
  let targets = images.filter(img => !img.excluded && (img.category === 'info' || img.category === 'spec')).slice(0, 3);
  if (targets.length === 0) {
    targets = images.filter(img => !img.excluded && !img.isBarcode && img.category !== 'barcode').slice(0, 3);
  }
  if (targets.length === 0) return null;
  // メーカー特定が必要な場合、main画像も1枚追加（ロゴ/外観から判定）
  if (needMakerID) {
    const mainImg = images.find(img => !img.excluded && img.category === 'main');
    if (mainImg && !targets.includes(mainImg)) {
      targets = [mainImg, ...targets].slice(0, 4);
    }
  }
  const makerHint = needMakerID ? `\n\nメーカー特定のヒント:\n- ノートPCの外観写真からロゴ・ブランド名を読み取る\n- ThinkPadの赤いトラックポイント(赤いポッチ)→ Lenovo\n- 天板のロゴ(DELL, HP, Lenovo, VAIO等)\n- キーボード配列やデザインの特徴\n- 外観から判別できる場合は必ずmakerに記載` : '';
  const content = [
    { type: 'text', text: `このPC情報画面からスペックをJSON形式で抽出してください。

型番(product_name)の探し方:
- 「このPCの名前を変更」付近のPC名の下に型番がある（例: FMVU75B3R, PCNS600NAB）
- システム情報の「モデル」「型番」「Model」欄
- 画面左下やタスクバー付近のテキスト
- 型番は英数字の組み合わせ（6〜15文字程度）

バッテリー情報:
- CYCLE COUNT = 充放電回数
- FULL CHARGE CAPACITY / DESIGN CAPACITY = バッテリー健康度(%)${makerHint}

出力JSON（読み取れない項目はnull）:
{"maker":"メーカー名","product_name":"型番(FMVU75B3R等の英数コード)","model":"MacBook Pro等のシリーズ名","cpu":"CPU名","memory":"8GB等","storage":"256GB SSD等","display":"14型等","gpu":"GPU名","os":"OS名","year":2020,"chip":"Apple Silicon名(M1等)","size":"画面サイズ(13.3型等)","cycle_count":"充放電回数(数値)","battery_health":"バッテリー最大容量%(FULL/DESIGN×100)"}
JSON以外は返さないでください。` }
  ];
  for (const img of targets) {
    const small = await shrinkForAPI(img.dataUrl, 1024);
    content.push({ type: 'image_url', image_url: { url: small, detail: 'high' } });
  }
  try {
    const result = await callOpenAI(key, [{ role: 'user', content }], 500, 'gpt-5-mini');
    const clean = result.replace(/```json|```/g, '').trim();
    return JSON.parse(clean);
  } catch (e) { console.error('ocrSpecs error:', e); return null; }
};

// 画像縮小ユーティリティ（API送信用）
const shrinkForAPI = (dataUrl, maxSize = 512, quality = 0.6) => new Promise(resolve => {
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement('canvas');
    const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    resolve(canvas.toDataURL('image/jpeg', quality));
  };
  img.onerror = () => resolve(dataUrl);
  img.src = dataUrl;
});

// 画像分類
const classifyImages = async (claudeKey, images) => {
  // 画像枚数に応じて品質調整（多いとContext Window溢れる）
  const imgCount = images.length;
  const maxSize = imgCount > 10 ? 512 : imgCount > 6 ? 768 : 1024;
  const quality = imgCount > 10 ? 0.6 : imgCount > 6 ? 0.7 : 0.85;
  console.log(`🖼️ 分類: ${imgCount}枚 → ${maxSize}px/${Math.round(quality*100)}%`);
  
  // Claude API用: base64画像を準備
  const smallUrls = await Promise.all(images.map(img => shrinkForAPI(img.dataUrl, maxSize, quality)));
  const imageContents = smallUrls.map(url => {
    // data:image/jpeg;base64,XXXX → base64部分を抽出
    const match = url.match(/^data:(image\/\w+);base64,(.+)$/);
    if (!match) return null;
    return {
      type: 'image',
      source: { type: 'base64', media_type: match[1], data: match[2] }
    };
  }).filter(Boolean);
  
  const prompt = `中古ノートPC写真${images.length}枚を分類。各画像ごとに以下の判定フローで1カテゴリを決定。

■判定フロー（上から順に判定、最初に該当したものが答え）:
1. バーコード（縦線＋数字列）が写っている？ → barcode
2. PCが閉じた状態？（天板/ロゴ面/側面ポート/底面が見える）→ side
3. PCが開いた全体写真？（画面とキーボード両方見える）→ main
4. キーボード面のアップ？（キーが画面の半分以上）→ keyboard
5. 画面にスペック文字が読める？（CPU名/RAM/OS/バッテリー数値）→ info
6. 本体に貼られたラベル/シールのアップ？ → spec
7. どれにも該当しない → other

■補足ルール:
・同じカテゴリが何枚あってもOK。バランスを取る必要はない。side6枚は普通
・暗い画面でもテキスト（Battery report/CYCLE COUNT等）が読めればinfo
・キーボードにシールが見えてもキーが主体ならkeyboard（specではない）
・底面のラベルは小さければside（ラベルのアップならspec）

■状態判定:
condition: 3がデフォルト。画面色むら/筐体割れ/キー欠損/ヒンジ破損のみ4-5。
notes: デフォルト「中古品なりの使用感はありますが、美品となります。」

JSON出力（JSONのみ、他のテキスト不要）:
{"results":[{"index":0,"category":"main"},{"index":1,"category":"info","info_text":"読めたテキスト"},...], "condition":3, "notes":"..."}
infoの場合のみinfo_textに読めたテキストを記載。`;

  const r = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': claudeKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true'
    },
    body: JSON.stringify({
      model: 'claude-haiku-4-5-20251001',
      max_tokens: 2000,
      messages: [{ role: 'user', content: [{ type: 'text', text: prompt }, ...imageContents] }]
    })
  });
  const d = await r.json();
  if (d.error) throw new Error(d.error.message || JSON.stringify(d.error));
  
  try {
    const text = (d.content || []).map(c => c.text || '').join('').trim();
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      console.log('🔍 Claude分類結果:', parsed.results?.map(r => `[${r.index}]${r.category}${r.info_text ? '('+r.info_text+')' : ''}`).join(', '), `condition:${parsed.condition}`);
      // info_textバリデーション: infoなのにテキスト根拠がないものはsideに格下げ
      const validated = (parsed.results || []).map(r => {
        if (r.category === 'info' && (!r.info_text || r.info_text.trim().length < 3)) {
          console.warn(`⚠️ [${r.index}] info→side格下げ（info_text無し）`);
          return { ...r, category: 'side' };
        }
        return r;
      });
      return {
        results: validated,
        condition: parsed.condition || 3,
        notes: parsed.notes || ''
      };
    }
  } catch (e) {
    console.error('分類結果のパースエラー:', e);
  }
  return null;
};

const generateIntro = async (key, p, cKey) => {
  const s = p.specs || {};
  // 型番から「他 X台セット」を削除
  let modelClean = (s.product_name || '').replace(/他?\s*\d+台[ｾセ][ｯッ][ﾄト]/g, '').replace(/\(.*$/, '').trim();
  if (isInternalCode(modelClean)) modelClean = '';
  const officeInfo = p.hasOffice ? 'Microsoft Office2024(永続版)搭載' : '';
  const makerModel = [s.maker, modelClean].filter(Boolean).join(' ');
  
  // ジャンク品の場合は専用プロンプト
  if (p.isJunk) {
    const prompt = `メルカリ出品用のジャンク品PCの紹介文を書いてください。

商品: ${makerModel || '中古PC'}
CPU: ${s.cpu || '不明'} / メモリ: ${s.memory || '不明'} / ストレージ: ${s.storage || '不明'}

条件:
- 3〜4文で簡潔に
- ジャンク品・動作保証なし・修理/部品取り用であることを明記
- スペック値は絶対に改変しない
- 紹介文のみ出力（見出し・箇条書き不要）

紹介文:`;
    if (cKey) return await callClaude(cKey, prompt, 500);
    return await callOpenAI(key, [{ role: 'user', content: prompt }], 500);
  }
  
  const officeNote = officeInfo ? `\nOffice: ${officeInfo}` : '';
  const prompt = `メルカリ出品用の中古ノートPCの紹介文を書いてください。

商品: ${makerModel || '中古ノートPC'}
CPU: ${s.cpu || '不明'} / メモリ: ${s.memory || '不明'} / ストレージ: ${s.storage || '不明'}${officeNote}

条件:
- 3〜4文で簡潔に、購入意欲を高める自然な日本語で
- 1文目: 商品の特徴や強みを端的に（例:「快適なビジネスワークを実現する高性能モバイルノートです。」）
- 2〜3文目: スペックの魅力を具体的に（マルチタスク、データ保存、軽量さなど実用面で）
- 最終文: 用途提案（テレワーク、学生、ビジネスなど）
- CPU略称は正式名に変換可（C5→Core i5等）。それ以外のスペック値は改変禁止
- Officeについて一切言及しない（「付属していません」も書かない）
- 「中古品ですが」「状態は」等の状態言及は不要（別セクションで記載済み）
- 紹介文のみ出力（見出し・箇条書き・改行区切り不要）

紹介文:`;
  if (cKey) return await callClaude(cKey, prompt, 500);
  return await callOpenAI(key, [{ role: 'user', content: prompt }], 500);
};

// 画像結合関数（2枚横並び / 3枚L字 / 4枚グリッド）
const mergeImages = async (images, cols = 2) => {
  const size = 1000;
  const rows = Math.ceil(images.length / cols);
  const canvas = document.createElement('canvas');
  canvas.width = size * cols;
  canvas.height = size * rows;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  for (let i = 0; i < images.length; i++) {
    const img = new Image();
    await new Promise((resolve) => {
      img.onload = resolve;
      img.onerror = resolve;
      img.src = images[i].dataUrl;
    });
    const col = i % cols;
    const row = Math.floor(i / cols);
    ctx.drawImage(img, col * size, row * size, size, size);
  }
  
  const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
  const filename = `_merged_${Date.now()}.jpg`;
  return { dataUrl, filename };
};

// dataUrlをBlobに変換
const dataUrlToBlob = (dataUrl) => {
  const [header, data] = dataUrl.split(',');
  const mime = header.match(/:(.*?);/)[1];
  const bin = atob(data);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return new Blob([arr], { type: mime });
};

// フォルダに画像を保存
const saveImageToFolder = async (dirHandle, filename, dataUrl) => {
  try {
    const blob = dataUrlToBlob(dataUrl);
    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
    return true;
  } catch (e) {
    console.error('画像保存エラー:', e);
    return false;
  }
};

// アイコン
const Icon = ({ name, className = "w-5 h-5" }) => {
  const icons = {
    upload: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />,
    file: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />,
    key: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z" />,
    image: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />,
    check: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />,
    x: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />,
    refresh: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />,
    left: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />,
    right: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />,
    scan: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z" />,
    eye: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />,
    eyeOff: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />,
    search: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />,
  };
  return <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">{icons[name]}</svg>;
};

// DropZoneコンポーネント
// モザイクエディタ（トップレベルコンポーネント - 安定動作のためApp外に定義）
const MosaicEditor = ({ src, imgIdx, barcode, onSave, onBarcodeChange, onClose }) => {
  const canvasRef = React.useRef(null);
  const overlayRef = React.useRef(null);
  const imgRef = React.useRef(null);
  const drawRef = React.useRef({ active: false, sx: 0, sy: 0 });
  const [histCount, setHistCount] = React.useState(0);
  const historyRef = React.useRef([]);

  React.useEffect(() => {
    const img = new Image();
    imgRef.current = img;
    img.onload = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const maxW = Math.min(window.innerWidth * 0.85, 1200);
      const maxH = window.innerHeight * 0.6;
      const scale = Math.min(1, maxW / img.width, maxH / img.height);
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      const ov = overlayRef.current;
      if (ov) { ov.width = canvas.width; ov.height = canvas.height; }
    };
    img.src = src;
  }, [src]);

  const getXY = (e) => {
    const r = canvasRef.current.getBoundingClientRect();
    const t = e.touches ? e.touches[0] : e;
    return [t.clientX - r.left, t.clientY - r.top];
  };
  const onDown = (e) => { e.preventDefault(); const [x, y] = getXY(e); drawRef.current = { active: true, sx: x, sy: y }; };
  const onMove = (e) => {
    if (!drawRef.current.active) return;
    e.preventDefault();
    const [x, y] = getXY(e);
    const { sx, sy } = drawRef.current;
    const ov = overlayRef.current;
    if (!ov) return;
    const ctx = ov.getContext('2d');
    ctx.clearRect(0, 0, ov.width, ov.height);
    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.setLineDash([6, 3]);
    ctx.fillStyle = 'rgba(255,0,0,0.12)';
    ctx.fillRect(Math.min(sx,x), Math.min(sy,y), Math.abs(x-sx), Math.abs(y-sy));
    ctx.strokeRect(Math.min(sx,x), Math.min(sy,y), Math.abs(x-sx), Math.abs(y-sy));
  };
  const onUp = (e) => {
    if (!drawRef.current.active) return;
    drawRef.current.active = false;
    const ct = e.changedTouches ? e.changedTouches[0] : e;
    const r = canvasRef.current.getBoundingClientRect();
    const ex = ct.clientX - r.left, ey = ct.clientY - r.top;
    const { sx, sy } = drawRef.current;
    const ov = overlayRef.current;
    if (ov) ov.getContext('2d').clearRect(0, 0, ov.width, ov.height);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const x = Math.round(Math.max(0, Math.min(sx, ex)));
    const y = Math.round(Math.max(0, Math.min(sy, ey)));
    const w = Math.round(Math.min(Math.abs(ex - sx), canvas.width - x));
    const h = Math.round(Math.min(Math.abs(ey - sy), canvas.height - y));
    if (w < 5 || h < 5) return;
    historyRef.current.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
    setHistCount(historyRef.current.length);
    const bs = Math.max(10, Math.round(Math.min(w, h) / 5));
    const id = ctx.getImageData(x, y, w, h);
    const d = id.data;
    for (let by = 0; by < h; by += bs) {
      for (let bx = 0; bx < w; bx += bs) {
        let rr=0,gg=0,bb=0,n=0;
        for (let dy=0; dy<bs&&by+dy<h; dy++) for (let dx=0; dx<bs&&bx+dx<w; dx++) { const i=((by+dy)*w+(bx+dx))*4; rr+=d[i]; gg+=d[i+1]; bb+=d[i+2]; n++; }
        rr=Math.round(rr/n); gg=Math.round(gg/n); bb=Math.round(bb/n);
        for (let dy=0; dy<bs&&by+dy<h; dy++) for (let dx=0; dx<bs&&bx+dx<w; dx++) { const i=((by+dy)*w+(bx+dx))*4; d[i]=rr; d[i+1]=gg; d[i+2]=bb; }
      }
    }
    ctx.putImageData(id, x, y);
  };
  const undo = () => {
    if (historyRef.current.length === 0) return;
    canvasRef.current.getContext('2d').putImageData(historyRef.current.pop(), 0, 0);
    setHistCount(historyRef.current.length);
  };
  const save = () => {
    if (imgIdx == null || historyRef.current.length === 0) { onClose(); return; }
    const canvas = canvasRef.current;
    const img = imgRef.current;
    const full = document.createElement('canvas');
    full.width = img.width; full.height = img.height;
    full.getContext('2d').drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, img.width, img.height);
    onSave(full.toDataURL('image/jpeg', 0.92));
  };

  return React.createElement('div', {
    className: 'fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50', style: {padding: 8},
    onClick: e => { if (e.target === e.currentTarget) onClose(); }
  },
    React.createElement('div', {className: 'flex gap-2 mb-2 flex-wrap justify-center'},
      React.createElement('span', {className: 'text-white text-sm py-1'}, '🔲 ドラッグでモザイク（複数OK）'),
      histCount > 0 && React.createElement('button', {onClick: undo, className: 'px-3 py-1 bg-yellow-500 text-white rounded text-sm'}, `↩ 戻す (${histCount})`),
      histCount > 0 && imgIdx != null && React.createElement('button', {onClick: save, className: 'px-4 py-1 bg-green-500 text-white rounded text-sm font-bold'}, '💾 保存'),
      React.createElement('button', {onClick: onClose, className: 'px-3 py-1 bg-gray-600 text-white rounded text-sm'}, '✕ 閉じる')
    ),
    React.createElement('div', {className: 'relative', style: {display: 'inline-block', lineHeight: 0}},
      React.createElement('canvas', {ref: canvasRef, className: 'rounded', style: {display: 'block', touchAction: 'none'}}),
      React.createElement('canvas', {ref: overlayRef, className: 'absolute inset-0 rounded cursor-crosshair', style: {touchAction: 'none'},
        onMouseDown: onDown, onMouseMove: onMove, onMouseUp: onUp, onMouseLeave: onUp,
        onTouchStart: onDown, onTouchMove: onMove, onTouchEnd: onUp
      })
    ),
    React.createElement('div', {className: 'mt-2 bg-white rounded-lg p-2 flex items-center gap-2', style: {maxWidth: 500, width: '100%'}},
      React.createElement('label', {className: 'font-medium text-sm whitespace-nowrap'}, 'BC:'),
      React.createElement('input', {type: 'text', value: barcode || '', onChange: e => onBarcodeChange(e.target.value),
        placeholder: '下6桁', className: 'flex-1 border-2 border-blue-400 rounded px-2 py-1 font-mono text-sm focus:border-blue-600 focus:outline-none'
      }),
      React.createElement('button', {onClick: onClose, className: 'px-4 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600'}, 'OK')
    )
  );
};

const DropZone = ({ title, icon, color, accept, multiple, directory, onFiles, hint }) => {
  const [isDragging, setIsDragging] = useState(false);
  const inputRef = useRef(null);
  const fileInputRef = useRef(null);
  const dragCounter = useRef(0);
  
  const handleDragIn = (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current++;
    if (dragCounter.current === 1) {
      setIsDragging(true);
    }
  };
  
  const handleDragOut = (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current--;
    if (dragCounter.current === 0) {
      setIsDragging(false);
    }
  };
  
  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  const handleDrop = async (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current = 0;
    setIsDragging(false);
    
    const items = e.dataTransfer.items;
    const droppedFiles = e.dataTransfer.files;
    const files = [];
    
    console.log('Drop event - items:', items?.length, 'files:', droppedFiles?.length);
    
    // webkitGetAsEntryが使える場合（フォルダ対応）
    let entryError = false;
    if (items && items.length > 0) {
      const entries = [];
      for (let i = 0; i < items.length; i++) {
        if (items[i].webkitGetAsEntry) {
          const entry = items[i].webkitGetAsEntry();
          if (entry) entries.push(entry);
        }
      }
      
      if (entries.length > 0) {
        for (const entry of entries) {
          try {
            const entryFiles = await readEntry(entry);
            if (entryFiles.length > 0) {
              files.push(...entryFiles);
            } else if (entry.isDirectory) {
              // フォルダなのにファイルが取得できなかった
              entryError = true;
            }
          } catch (err) {
            console.error('readEntry error:', err);
            entryError = true;
          }
        }
      }
    }
    
    // fallback: 通常のファイル
    if (files.length === 0 && droppedFiles.length > 0) {
      console.log('Using fallback file handling');
      for (let i = 0; i < droppedFiles.length; i++) {
        const f = droppedFiles[i];
        // フォルダかどうかチェック（size=0, type=空）
        if (f.size === 0 && f.type === '') {
          console.log('Detected folder in fallback, skipping:', f.name);
          entryError = true;
          continue;
        }
        // webkitRelativePathがない場合は名前をセット
        if (!f.webkitRelativePath) {
          Object.defineProperty(f, 'webkitRelativePath', {
            value: f.name,
            writable: false,
            configurable: true
          });
        }
        files.push(f);
      }
    }
    
    console.log('Processed files:', files.length, files.slice(0,5).map(f => f.webkitRelativePath || f.name));
    
    if (files.length > 0) {
      onFiles(files);
    } else if (entryError) {
      // フォルダドロップが失敗した場合
      alert('⚠️ フォルダの読み込みに失敗しました。\n\n日本語フォルダ名はドラッグ&ドロップで対応できない場合があります。\n\n【対処法】\n・下の「フォルダを選択」ボタンを使う\n・または画像ファイルを直接ドラッグ&ドロップ');
    } else {
      console.warn('No files found after processing drop');
    }
  };
  
  const readEntry = async (entry, path = '') => {
    return new Promise(async (resolve) => {
      const files = [];
      
      // タイムアウト設定（10秒）
      const timeout = setTimeout(() => {
        console.warn('readEntry timeout for:', path + entry.name);
        resolve(files);
      }, 10000);
      
      try {
        if (entry.isFile) {
          entry.file((file) => {
            clearTimeout(timeout);
            // webkitRelativePathを模倣
            Object.defineProperty(file, 'webkitRelativePath', {
              value: path + file.name,
              writable: false,
              configurable: true
            });
            files.push(file);
            resolve(files);
          }, (err) => {
            clearTimeout(timeout);
            console.error('file() error:', err);
            resolve(files);
          });
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const readAllEntries = async () => {
            return new Promise((res, rej) => {
              const results = [];
              const readBatch = () => {
                reader.readEntries((batch) => {
                  if (batch.length === 0) {
                    res(results);
                  } else {
                    results.push(...batch);
                    readBatch();
                  }
                }, (err) => {
                  console.error('readEntries error:', err);
                  // エラーでも今まで取得した分は返す
                  rej(err);
                });
              };
              readBatch();
            });
          };
          
          try {
            const entries = await readAllEntries();
            for (const child of entries) {
              const childFiles = await readEntry(child, path + entry.name + '/');
              files.push(...childFiles);
            }
          } catch (err) {
            // readAllEntriesでエラーが出た場合（日本語フォルダ名など）
            console.error('Failed to read directory:', entry.name, err);
          }
          clearTimeout(timeout);
          resolve(files);
        } else {
          clearTimeout(timeout);
          resolve(files);
        }
      } catch (err) {
        clearTimeout(timeout);
        console.error('readEntry catch error:', err);
        resolve(files);
      }
    });
  };
  
  const handleClick = () => {
    if (directory) {
      inputRef.current?.click();
    } else {
      inputRef.current?.click();
    }
  };
  
  const handleFileClick = (e) => {
    e.stopPropagation();
    fileInputRef.current?.click();
  };
  
  const handleChange = (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length > 0) {
      onFiles(files);
    }
  };
  
  const colorClasses = {
    blue: { border: 'hover:border-blue-400', icon: 'text-blue-500', dragBg: 'bg-blue-50 border-blue-400' },
    green: { border: 'hover:border-green-400', icon: 'text-green-500', dragBg: 'bg-green-50 border-green-400' },
    red: { border: 'hover:border-red-400', icon: 'text-red-500', dragBg: 'bg-red-50 border-red-400' },
    orange: { border: 'hover:border-orange-400', icon: 'text-orange-500', dragBg: 'bg-orange-50 border-orange-400' },
  };
  const c = colorClasses[color] || colorClasses.blue;
  
  return (
    <div 
      className="bg-white rounded shadow p-4"
      onDragEnter={handleDragIn}
      onDragLeave={handleDragOut}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
    >
      <h3 className="font-bold mb-3 flex items-center gap-2">
        <Icon name={icon} className={`w-5 h-5 ${c.icon}`}/>{title}
      </h3>
      <div
        onClick={handleClick}
        className={`border-2 border-dashed rounded p-4 text-center cursor-pointer transition-all ${isDragging ? c.dragBg : `border-gray-300 ${c.border}`}`}
      >
        <Icon name="upload" className="w-6 h-6 mx-auto mb-1 text-gray-400"/>
        <span className="text-sm text-gray-600">{isDragging ? 'ドロップ！' : (hint || 'クリック or ドラッグ')}</span>
        {directory && (
          <input
            ref={inputRef}
            type="file"
            accept={accept}
            multiple={multiple}
            webkitdirectory=""
            directory=""
            className="hidden"
            onChange={handleChange}
          />
        )}
        {!directory && (
          <input
            ref={inputRef}
            type="file"
            accept={accept}
            multiple={multiple}
            className="hidden"
            onChange={handleChange}
          />
        )}
      </div>
      {directory && (
        <div className="mt-2 flex gap-2">
          <button
            onClick={handleClick}
            className="flex-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 py-1 px-2 rounded border"
          >
            📁 フォルダを選択
          </button>
          <button
            onClick={handleFileClick}
            className="flex-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 py-1 px-2 rounded border"
          >
            📄 ファイルを選択
          </button>
        </div>
      )}
      {directory && (
        <input
          ref={fileInputRef}
          type="file"
          accept={accept}
          multiple={true}
          className="hidden"
          onChange={handleChange}
        />
      )}
    </div>
  );
};

// IndexedDB自動保存（画像含むため大容量対応）
const IDB_NAME = 'mercari_tool';
const IDB_STORE = 'sessions';
const IDB_KEY = 'autosave';
const idbOpen = () => new Promise((res, rej) => {
  const req = indexedDB.open(IDB_NAME, 1);
  req.onupgradeneeded = () => req.result.createObjectStore(IDB_STORE);
  req.onsuccess = () => res(req.result);
  req.onerror = () => rej(req.error);
});
const idbSave = async (data) => {
  try {
    const db = await idbOpen();
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).put(data, IDB_KEY);
    await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
    db.close();
    return true;
  } catch(e) { console.error('IDB save error:', e); return false; }
};
const idbLoad = async () => {
  try {
    const db = await idbOpen();
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).get(IDB_KEY);
    const result = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = rej; });
    db.close();
    return result || null;
  } catch(e) { console.error('IDB load error:', e); return null; }
};
const idbClear = async () => {
  try {
    const db = await idbOpen();
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).delete(IDB_KEY);
    db.close();
  } catch(e) {}
};

// メインApp
function App() {
  const [step, setStep] = useState(1);
  const [apiKey, setApiKey] = useState(localStorage.getItem('openai_key') || '');
  const [claudeKey, setClaudeKey] = useState(localStorage.getItem('claude_key') || '');
  const [outputDirHandle, setOutputDirHandle] = useState(null); // 画像保存先フォルダ
  const [purchaseData, setPurchaseData] = useState([]);
  const [priceData, setPriceData] = useState([]);

  const [products, setProducts] = useState([]);
  const [currentIdx, setCurrentIdx] = useState(0);
  const [expandedSpecRow, setExpandedSpecRow] = useState(null);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [dragIdx, setDragIdx] = useState(null);
  const [selectedImages, setSelectedImages] = useState([]);
  const [imageHistory, setImageHistory] = useState([]); // 履歴（Undo用）
  const [zoomImage, setZoomImage] = useState(null); // {dataUrl, imgIdx} or null
  const [hoverImg, setHoverImg] = useState(null); // dataUrl for preview
  const [decomposeTarget, setDecomposeTarget] = useState(null); // {imgIdx, mergedImg, sourceImgs}
  const [autoSaveTime, setAutoSaveTime] = useState(null); // 最終自動保存時刻
  const [pendingRestore, setPendingRestore] = useState(null); // 復元待ちデータ
  // 保証文テンプレート（編集可能）
  const [noticeText, setNoticeText] = useState(() => localStorage.getItem('mercari_notice_text') || DEFAULT_NOTICE_TEXT);
  const [showNoticeEditor, setShowNoticeEditor] = useState(false);

  // 検索URL構築
  const buildSearchQuery = (p) => {
    const s = p.specs || {};
    const parts = [s.maker, s.cpu, s.memory, s.storage].filter(Boolean);
    if (s.model) parts.unshift(s.model);
    return parts.join(' ').trim();
  };
  const buildYahooUrl = (query) => {
    const q = encodeURIComponent(query);
    return `https://auctions.yahoo.co.jp/closedsearch/closedsearch?p=${q}&va=${q}&b=1&n=50`;
  };
  const buildMercariUrl = (query) => {
    const q = encodeURIComponent(query);
    return `https://jp.mercari.com/search?keyword=${q}&status=sold_out&sort=created_time&order=desc`;
  };

  // 写真振り分けモード
  const [sorterMode, setSorterMode] = useState(false);
  const [sorterPhotos, setSorterPhotos] = useState([]);
  const [sorterSplits, setSorterSplits] = useState(new Set());
  const [sorterBarcodes, setSorterBarcodes] = useState(new Set()); // バーコード画像のインデックス
  const [sorterManualBC, setSorterManualBC] = useState(false); // 手動BC選択モード
  const [sorterSelected, setSorterSelected] = useState(-1);
  const [sorterPreview, setSorterPreview] = useState(null);
  const [showBcReview, setShowBcReview] = useState(false);
  const [bcReviewReady, setBcReviewReady] = useState(false);
  const [bcReviewIdx, setBcReviewIdx] = useState(0);

  // 初期ロード時にlocalStorageから復元
  useEffect(() => {
    try {
      const savedPurchase = localStorage.getItem('mercari_purchase_data');
      const savedPrice = localStorage.getItem('mercari_price_data');
      if (savedPurchase) {
        const data = JSON.parse(savedPurchase);
        setPurchaseData(data);
        console.log(`仕入データ復元: ${data.length}件`);
      }
      if (savedPrice) {
        const data = JSON.parse(savedPrice);
        setPriceData(data);
        console.log(`価格データ復元: ${data.length}件`);
      }
    } catch (e) {
      console.error('データ復元エラー:', e);
    }
  }, []);

  // 仕入データ変更時に保存（500件以下のみ、超過時はセッション内のみ保持）
  useEffect(() => {
    if (purchaseData.length > 0 && purchaseData.length <= 500) {
      try {
        localStorage.setItem('mercari_purchase_data', JSON.stringify(purchaseData));
      } catch (e) { /* quota exceeded */ }
    } else if (purchaseData.length > 500) {
      localStorage.removeItem('mercari_purchase_data');
    }
  }, [purchaseData]);

  // 価格データ変更時に保存
  useEffect(() => {
    if (priceData.length > 0 && priceData.length <= 500) {
      try {
        localStorage.setItem('mercari_price_data', JSON.stringify(priceData));
      } catch (e) { /* quota exceeded */ }
    } else if (priceData.length > 500) {
      localStorage.removeItem('mercari_price_data');
    }
  }, [priceData]);

  // === IndexedDB自動保存 ===
  // 起動時復元チェック
  useEffect(() => {
    idbLoad().then(data => {
      if (data && data.products && data.products.length > 0) {
        setPendingRestore(data);
      }
    });
  }, []);

  // step/products変更時に自動保存（step >= 2 かつ商品あり）
  // ⚠️ 画像dataUrlは巨大なので除外。スペック・価格・タイトルのみ保存
  const autoSaveRef = useRef(null);
  useEffect(() => {
    if (step < 2 || products.length === 0) return;
    clearTimeout(autoSaveRef.current);
    autoSaveRef.current = setTimeout(async () => {
      // 軽量版: 画像データを除外
      const lightProducts = products.map(p => ({
        ...p,
        images: p.images.map(img => ({
          id: img.id, filename: img.filename, category: img.category,
          isBarcode: img.isBarcode, excluded: img.excluded,
          // dataUrl/thumbUrlは除外（復元時に再読込が必要）
        }))
      }));
      const ok = await idbSave({ step, currentIdx, products: lightProducts, savedAt: new Date().toISOString(), version: '5.1', lightMode: true });
      if (ok) setAutoSaveTime(new Date());
    }, 3000); // 3秒デバウンス（lightModeで軽量なので高頻度OK）
    return () => clearTimeout(autoSaveRef.current);
  }, [step, products]);

  // 復元実行
  const restoreSession = () => {
    if (!pendingRestore) return;
    const isLight = pendingRestore.lightMode;
    setProducts(pendingRestore.products);
    setStep(Math.max(pendingRestore.step || 2, isLight ? 3 : 2)); // lightModeならStep3以降に強制
    setCurrentIdx(pendingRestore.currentIdx || 0);
    setMessage(`✅ 自動保存から復元: ${pendingRestore.products.length}商品（Step ${pendingRestore.step || 2}）/ ${pendingRestore.savedAt ? new Date(pendingRestore.savedAt).toLocaleString() : ''}${isLight ? ' ⚠️画像なし（スペック・価格・タイトルのみ）' : ''}`);
    setPendingRestore(null);
  };

  // 手動保存（JSONダウンロード）
  const manualSave = async () => {
    const lightProducts = products.map(p => ({
      ...p,
      images: p.images.map(img => ({
        id: img.id, filename: img.filename, category: img.category,
        isBarcode: img.isBarcode, excluded: img.excluded,
      }))
    }));
    await idbSave({ step, currentIdx, products: lightProducts, savedAt: new Date().toISOString(), version: '5.1', lightMode: true });
    setAutoSaveTime(new Date());
    setMessage(`💾 手動保存しました（${products.length}商品, Step ${step}）`);
  };

  // 画像復元: フォルダを再選択してfilename照合で画像を紐付け直す
  const reloadImagesFromFolder = async () => {
    try {
      const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
      setLoading(true);
      setMessage('📁 画像を再読み込み中...');
      let restored = 0, total = 0;
      const np = [...products];
      
      for (let pi = 0; pi < np.length; pi++) {
        const p = np[pi];
        if (!p.images || p.images.length === 0) continue;
        // フォルダ名でサブディレクトリを探す
        let subDir = null;
        try { subDir = await dirHandle.getDirectoryHandle(p.folder); } catch(e) {}
        if (!subDir) continue;
        
        // サブディレクトリ内のファイルをマップ化
        const fileMap = {};
        for await (const [name, handle] of subDir.entries()) {
          if (handle.kind === 'file') fileMap[name] = handle;
        }
        
        // 各画像のfilenameで照合
        const newImages = [];
        for (const img of p.images) {
          total++;
          const fh = fileMap[img.filename];
          if (fh) {
            try {
              const file = await fh.getFile();
              const dataUrl = await new Promise((res, rej) => {
                const r = new FileReader();
                r.onload = () => res(r.result);
                r.onerror = rej;
                r.readAsDataURL(file);
              });
              newImages.push({ ...img, dataUrl, thumbUrl: dataUrl });
              restored++;
            } catch(e) {
              newImages.push(img); // 読めなかった場合はそのまま
            }
          } else {
            newImages.push(img);
          }
        }
        np[pi] = { ...p, images: newImages };
        if (pi % 10 === 0) {
          setMessage(`📁 画像を再読み込み中... ${pi+1}/${np.length} (${restored}枚復元)`);
          setProducts([...np]);
          await new Promise(r => setTimeout(r, 10));
        }
      }
      setProducts(np);
      setLoading(false);
      setMessage(`✅ 画像復元完了: ${restored}/${total}枚`);
    } catch(e) {
      if (e.name !== 'AbortError') console.error('画像復元エラー:', e);
      setLoading(false);
      setMessage('');
    }
  };

  // データクリア関数
  const clearSavedData = () => {
    if (confirm('保存されたCSV・価格データ・型番学習・自動保存をクリアしますか？')) {
      localStorage.removeItem('mercari_purchase_data');
      localStorage.removeItem('mercari_price_data');
      localStorage.removeItem('model_map_learned');
      idbClear();
      setPurchaseData([]);
      setPriceData([]);
      setAutoSaveTime(null);
      setMessage('保存データをクリアしました（型番学習含む）');
    }
  };

  // キャッシュクリア（APIキー以外すべて）
  const clearCacheKeepKeys = () => {
    const openaiKey = localStorage.getItem('openai_key');
    const claudeKeyVal = localStorage.getItem('claude_key');
    localStorage.clear();
    if (openaiKey) localStorage.setItem('openai_key', openaiKey);
    if (claudeKeyVal) localStorage.setItem('claude_key', claudeKeyVal);
    idbClear();
    setPurchaseData([]);
    setPriceData([]);
    setAutoSaveTime(null);
    setMessage('✅ キャッシュクリア完了（APIキーは保持）');
  };

  // APIキー保存
  const saveApiKey = () => {
    localStorage.setItem('openai_key', apiKey);
    setMessage('APIキー保存完了');
  };

  // APIテスト
  const testApi = async () => {
    if (!apiKey) return setMessage('❌ APIキーを入力してください');
    setLoading(true);
    setMessage('テスト中...');
    try {
      const r = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model: 'gpt-5-mini', reasoning_effort: 'minimal', messages: [{ role: 'user', content: 'Say OK' }], max_completion_tokens: 50 })
      });
      const d = await r.json();
      if (d.error) {
        setMessage(`❌ ${d.error.message}`);
      } else {
        setMessage(`✅ gpt-5-mini: 接続OK！`);
      }
    } catch (e) {
      setMessage(`❌ エラー: ${e.message}`);
    }
    setLoading(false);
  };

  // 仕入CSV読込（ファイル配列を受け取る）
  const handlePurchaseFiles = (files) => {
    const all = [];
    let done = 0;
    files.forEach(f => {
      const reader = new FileReader();
      reader.onload = (ev) => {
        Papa.parse(ev.target.result, {
          header: true, skipEmptyLines: true,
          complete: (r) => {
            all.push(...r.data);
            if (++done === files.length) {
              setPurchaseData(all);
              // 重複チェック（バーコード番号の下6桁）
              const bcCount = {};
              all.forEach(row => {
                const raw = String(row['バーコード番号'] || '').replace(/[^0-9]/g, '');
                if (raw.length >= 6) {
                  const bc6 = raw.slice(-6).padStart(6, '0');
                  bcCount[bc6] = (bcCount[bc6] || 0) + 1;
                }
              });
              const dupes = Object.entries(bcCount).filter(([_, c]) => c > 1);
              if (dupes.length > 0) {
                const dupeList = dupes.slice(0, 15).map(([bc, c]) => `${bc}(${c}件)`).join(', ');
                setMessage(`仕入CSV: ${all.length}件\n⚠️ BC重複${dupes.length}件: ${dupeList}${dupes.length > 15 ? '...' : ''}`);
              } else {
                setMessage(`仕入CSV: ${all.length}件`);
              }
            }
          }
        });
      };
      reader.readAsText(f, 'Shift_JIS');
    });
  };

  // 価格Excel読込（ファイル配列を受け取る）
  const handlePriceFiles = (files) => {
    const all = [];
    let done = 0;
    files.forEach(f => {
      const reader = new FileReader();
      reader.onload = (ev) => {
        const wb = XLSX.read(new Uint8Array(ev.target.result), { type: 'array' });
        const json = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
        all.push(...json);
        if (++done === files.length) {
          setPriceData(all);
          setMessage(`価格: ${all.length}件`);
        }
      };
      reader.readAsArrayBuffer(f);
    });
  };

  // 自動価格計算: 仕入原価 → 販売価格（キリの良い数字に丸め）
  const calcSellingPrice = (purchaseCost) => {
    if (!purchaseCost || isNaN(purchaseCost) || purchaseCost <= 0) return null;
    const raw = (purchaseCost + 2500) / 0.7;
    return roundToNicePrice(raw);
  };
  // キリの良い数字に丸め（例: 14200→14800, 28600→29800, 43100→44800）
  const roundToNicePrice = (raw) => {
    if (raw <= 5000) return Math.ceil(raw / 500) * 500;           // ~5000: 500刻み
    if (raw <= 10000) return Math.ceil(raw / 1000) * 1000;        // ~10000: 1000刻み
    if (raw <= 50000) {                                            // ~50000: X800系
      const thousands = Math.floor(raw / 1000);
      const remainder = raw - thousands * 1000;
      if (remainder <= 200) return thousands * 1000;               // X000
      if (remainder <= 600) return thousands * 1000 + 800;         // X800
      return (thousands + 1) * 1000;                               // 繰り上げX000
    }
    return Math.ceil(raw / 5000) * 5000;                           // 50000~: 5000刻み
  };

  // 画像読込（ファイル配列を受け取る - フォルダでもファイル直接でもOK）
  const handleImageFiles = async (files) => {
    console.log('handleImageFiles called with', files.length, 'files');
    setLoading(true);
    setMessage('画像読込中...');
    const map = {};
    
    for (const f of files) {
      const path = f.webkitRelativePath || f.name;
      console.log('Processing file:', path, 'type:', f.type, 'size:', f.size);
      
      const parts = path.split('/');
      let folder, name;
      
      if (parts.length >= 2) {
        // フォルダ構造がある場合
        folder = parts[parts.length - 2];
        name = parts[parts.length - 1];
      } else {
        // ファイル直接の場合：ファイル名から拡張子を除いた部分をフォルダ名に
        // または数字部分でグルーピング
        name = f.name;
        // ファイル名のパターンを解析（例: 001_01.jpg → 001がフォルダ）
        const match = name.match(/^(\d+)[_-]/);
        if (match) {
          folder = match[1];
        } else {
          // パターンがない場合は拡張子を除いたファイル名
          folder = name.replace(/\.[^.]+$/, '');
        }
      }
      
      const ext = name.split('.').pop().toLowerCase();
      if (!['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext)) {
        console.log('Skipping non-image file:', name);
        continue;
      }
      
      if (!map[folder]) map[folder] = [];
      
      try {
        const dataUrl = await new Promise((resolve, reject) => {
          const rd = new FileReader();
          rd.onload = e => resolve(e.target.result);
          rd.onerror = e => reject(e);
          rd.readAsDataURL(f);
        });
        map[folder].push({ id: `${folder}_${name}`, filename: name, dataUrl, excluded: false });
      } catch (err) {
        console.error('FileReader error for', name, err);
      }
    }
    
    console.log('Grouped into folders:', Object.keys(map));
    
    const prods = Object.entries(map).sort().map(([folder, imgs]) => ({
      id: folder, folder, images: imgs.sort((a, b) => a.filename.localeCompare(b.filename)), barcode: null
    }));
    
    if (prods.length === 0) {
      setMessage('画像が見つかりませんでした');
      setLoading(false);
      return;
    }
    
    setProducts(prods);
    setMessage(`${prods.length}商品`);
    setStep(2);
    setLoading(false);
  };

  // === 写真振り分けモード ===
  // バーコード画像自動検出（ブラウザBarcodeDetector API → 高速・無料）
  const detectBarcodesInPhotos = async (photos) => {
    const barcodeSet = new Set();
    
    // BarcodeDetector API対応チェック
    const hasBarcodeAPI = typeof BarcodeDetector !== 'undefined';
    let detector = null;
    if (hasBarcodeAPI) {
      try { detector = new BarcodeDetector({ formats: ['code_128', 'code_39', 'ean_13', 'ean_8', 'qr_code', 'itf', 'codabar'] }); }
      catch(e) { console.warn('BarcodeDetector初期化失敗:', e); }
    }
    
    if (detector) {
      // ブラウザ内検出（並列処理、超高速）
      const concurrency = 10;
      for (let b = 0; b < photos.length; b += concurrency) {
        const batch = photos.slice(b, Math.min(b + concurrency, photos.length));
        if (b % 100 === 0) setMessage(`バーコード検出中（ローカル）... ${Math.min(b + concurrency, photos.length)}/${photos.length}`);
        
        const promises = batch.map((photo, bi) => {
          const idx = b + bi;
          return new Promise(resolve => {
            const img = new Image();
            img.onload = async () => {
              try {
                // 小さいcanvasで高速化
                const canvas = document.createElement('canvas');
                const scale = Math.min(1, 800 / Math.max(img.width, img.height));
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const barcodes = await detector.detect(canvas);
                if (barcodes.length > 0) resolve(idx);
                else resolve(null);
              } catch(e) { resolve(null); }
            };
            img.onerror = () => resolve(null);
            img.src = photo.dataUrl;
          });
        });
        
        const results = await Promise.all(promises);
        results.forEach(idx => { if (idx !== null) barcodeSet.add(idx); });
      }
      setMessage(`✅ ローカル検出完了: ${barcodeSet.size}枚のバーコード発見`);
    } else if (apiKey) {
      // フォールバック: GPT API（BarcodeDetector非対応ブラウザ用）
      const batchSize = 20;
      const t0 = Date.now();
      for (let b = 0; b < photos.length; b += batchSize) {
        const batch = photos.slice(b, b + batchSize);
        const elapsed = (Date.now() - t0) / 1000;
        const eta = b > 0 ? Math.ceil((elapsed / b) * (photos.length - b)) : '';
        const etaStr = eta ? ` (残り約${eta < 60 ? eta + '秒' : Math.ceil(eta/60) + '分'})` : '';
        setMessage(`バーコード検出中（API）... ${Math.min(b + batchSize, photos.length)}/${photos.length}${etaStr}`);
        try {
          // 256pxに縮小して送信
          const smallUrls = await Promise.all(batch.map(p => shrinkForAPI(p.dataUrl, 256)));
          const imageContents = smallUrls.map(url => ({
            type: 'image_url',
            image_url: { url, detail: 'low' }
          }));
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 30000);
          const r = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            signal: controller.signal,
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
              model: 'gpt-5-mini',
              reasoning_effort: 'minimal',
              messages: [{ role: 'user', content: [
                { type: 'text', text: `${batch.length}枚の画像があります。各画像がバーコード/ラベルの画像かどうか判定してください。バーコード・シリアルナンバーラベル・管理番号シールの画像なら1、それ以外（PC本体・画面・キーボード等）なら0。\nJSON配列のみ出力: [0,1,0,...]` },
                ...imageContents
              ] }],
              max_completion_tokens: 200
            })
          });
          clearTimeout(timeout);
          const d = await r.json();
          if (!d.error) {
            const text = d.choices[0].message.content.trim();
            const arrMatch = text.match(/\[[\d\s,]+\]/);
            if (arrMatch) {
              const arr = JSON.parse(arrMatch[0]);
              arr.forEach((v, i) => { if (v === 1) barcodeSet.add(b + i); });
            }
          }
        } catch (e) { console.error('バーコード検出エラー:', e); }
      }
    } else {
      setMessage('⚠️ 手動で区切ってください（BarcodeDetector非対応・APIキー未設定）');
    }
    
    return barcodeSet;
  };

  const handleSorterFiles = async (files) => {
    setLoading(true);
    setMessage('写真読込中...');
    const validFiles = Array.from(files).filter(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return ['jpg','jpeg','png','gif','webp'].includes(ext);
    });
    if (validFiles.length === 0) { setMessage('画像が見つかりません'); setLoading(false); return; }
    
    // サムネイル生成関数（200px, JPEG 50%）
    const makeThumbnail = (dataUrl) => new Promise(resolve => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const scale = Math.min(1, 200 / Math.max(img.width, img.height));
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        resolve(canvas.toDataURL('image/jpeg', 0.5));
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
    
    // フォルダ構造を検出（webkitRelativePath）
    const folderMap = new Map(); // folder -> [file, ...]
    let hasSubfolders = false;
    validFiles.forEach(f => {
      const rel = f.webkitRelativePath || '';
      const parts = rel.split('/');
      // "親フォルダ/サブフォルダ/image.jpg" → サブフォルダ名
      const folder = parts.length >= 3 ? parts[parts.length - 2] : '__root__';
      if (folder !== '__root__') hasSubfolders = true;
      if (!folderMap.has(folder)) folderMap.set(folder, []);
      folderMap.get(folder).push(f);
    });
    
    // サブフォルダが2つ以上 → フォルダ分け済み、sorterスキップ
    const folderKeys = Array.from(folderMap.keys()).filter(k => k !== '__root__').sort();
    if (hasSubfolders && folderKeys.length >= 2) {
      setMessage(`${folderKeys.length}フォルダ検出、読込中...`);
      const prods = [];
      let totalPhotos = 0;
      
      for (let fi = 0; fi < folderKeys.length; fi++) {
        const folderName = folderKeys[fi];
        const folderFiles = folderMap.get(folderName);
        folderFiles.sort((a,b) => a.name.localeCompare(b.name));
        setMessage(`読込中... ${folderName}（${fi+1}/${folderKeys.length}）`);
        
        const images = [];
        for (let b = 0; b < folderFiles.length; b += 30) {
          const batch = folderFiles.slice(b, b + 30);
          const results = await Promise.all(batch.map(f => new Promise(async (resolve) => {
            const rd = new FileReader();
            rd.onload = async (e) => {
              const dataUrl = e.target.result;
              const thumbUrl = await makeThumbnail(dataUrl);
              resolve({ id: f.name, filename: f.name, dataUrl, thumbUrl, excluded: false });
            };
            rd.onerror = () => resolve(null);
            rd.readAsDataURL(f);
          })));
          results.forEach(r => { if (r) images.push(r); });
        }
        
        totalPhotos += images.length;
        prods.push({
          id: folderName, folder: folderName,
          images, barcode: null,
          hasOffice: false, isJunk: false
        });
      }
      
      setProducts(prods);
      setSorterMode(false);
      setStep(2);
      setLoading(false); // UI操作可能にしてからAI処理開始
      setMessage(`✅ ${folderKeys.length}フォルダ（${totalPhotos}枚）読込完了`);
      
      // APIキーがあればAI処理を自動実行（バックグラウンド）
      if (apiKey) {
        setMessage(`🔄 AI処理開始（${prods.length}商品）...`);
        const t0ai = Date.now();
        for (let i = 0; i < prods.length; i++) {
          const p = prods[i];
          // OCR
          const allActive = p.images.filter(img => !img.excluded);
          const bcImg = allActive[allActive.length - 1];
          if (bcImg && !p.barcode) {
            try {
              setMessage(`📷 BC読取 ${i+1}/${prods.length}`);
              const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
              if (bc) { p.barcode = bc; bcImg.isBarcode = true; }
            } catch(e) { console.error('OCRエラー:', e); }
          }
          // 画像分類＆並替
          if (allActive.length >= 3 && claudeKey) {
            try {
              setMessage(`🤖 分類＆並替 ${i+1}/${prods.length}`);
              const classResult = await classifyImages(claudeKey, allActive);
              if (classResult) {
                const { results: classifications, condition, notes } = classResult;
                p.condition = condition || 3;
                p.conditionNotes = notes || '';
                const byCategory = { main: [], keyboard: [], side: [], info: [], spec: [], barcode: [], other: [] };
                classifications.forEach(c => {
                  const img = allActive[c.index];
                  if (!img) return;
                  const cat = (c.category === 'screen' || c.category === 'battery') ? 'info' : c.category;
                  img.category = byCategory[cat] ? cat : 'other';
                  if (byCategory[cat]) byCategory[cat].push(img);
                  else byCategory.other.push(img);
                });
                const sorted = [];
                const mergedSrcIds = new Set();
                const mergeAndPush = async (imgs, name) => {
                  if (imgs.length >= 2) {
                    const { dataUrl, filename } = await mergeImages(imgs, 2);
                    sorted.push({ id: `merged_${Date.now()}_${name}`, filename, dataUrl, excluded: false, category: name });
                    imgs.forEach(img => mergedSrcIds.add(img.id));
                  } else { sorted.push(...imgs); }
                };
                // main(2) → info(結合) → spec(結合) → keyboard(結合) → side(結合) → other
                sorted.push(...byCategory.main.slice(0, 2));
                if (byCategory.main.length > 2) byCategory.other.push(...byCategory.main.slice(2));
                if (byCategory.info.length >= 2) { await mergeAndPush(byCategory.info.slice(0, 4), 'info'); if (byCategory.info.length > 4) byCategory.other.push(...byCategory.info.slice(4)); }
                else { sorted.push(...byCategory.info); }
                if (byCategory.spec.length >= 2) { await mergeAndPush(byCategory.spec.slice(0, 4), 'spec'); if (byCategory.spec.length > 4) byCategory.other.push(...byCategory.spec.slice(4)); }
                else { sorted.push(...byCategory.spec); }
                if (byCategory.keyboard.length >= 2) { await mergeAndPush(byCategory.keyboard.slice(0, 4), 'keyboard'); if (byCategory.keyboard.length > 4) byCategory.other.push(...byCategory.keyboard.slice(4)); }
                else { sorted.push(...byCategory.keyboard); }
                if (byCategory.side.length >= 2) {
                  await mergeAndPush(byCategory.side.slice(0, 4), 'side');
                  if (byCategory.side.length > 4) byCategory.other.push(...byCategory.side.slice(4));
                } else { sorted.push(...byCategory.side); }
                sorted.push(...byCategory.other);
                byCategory.barcode.forEach(img => img.isBarcode = true);
                sorted.push(...byCategory.barcode);

                const excludedImgs = p.images.filter(img => img.excluded || mergedSrcIds.has(img.id)).map(img => ({ ...img, excluded: true }));
                p.images = [...sorted, ...excludedImgs];
              }
            } catch(e) { console.error('⚠️ 分類エラー:', e); setMessage(`⚠️ 分類失敗(${p.folder || i}): ${e.message?.slice(0,50)}`); }
          }
          // 部分更新
          setProducts([...prods]);
        }
        const elapsed = Math.round((Date.now() - t0ai) / 1000);
        const bcOk = prods.filter(p => p.barcode).length;
        const bcFail = prods.filter(p => !p.barcode).map(p => p.folder);
        let msg = `✅ AI処理完了（${elapsed}秒）${bcOk}件BC読取`;
        if (bcFail.length > 0) msg += `\n⚠️ BC読取失敗(${bcFail.length}件): ${bcFail.slice(0, 20).join(', ')}${bcFail.length > 20 ? '...' : ''}`;
        setMessage(msg);
        setBcReviewReady(true);
      }
      setLoading(false);
      return;
    }
    
    // フォルダ分けなし → 通常の手動振り分けモード
    validFiles.sort((a,b) => a.name.localeCompare(b.name));
    
    const photos = [];
    const readBatch = 30;
    for (let b = 0; b < validFiles.length; b += readBatch) {
      const batch = validFiles.slice(b, b + readBatch);
      setMessage(`写真読込中... ${Math.min(b + readBatch, validFiles.length)}/${validFiles.length}`);
      const results = await Promise.all(batch.map(f => new Promise(async (resolve) => {
        const rd = new FileReader();
        rd.onload = async (e) => {
          const dataUrl = e.target.result;
          const thumbUrl = await makeThumbnail(dataUrl);
          resolve({ id: f.name, filename: f.name, dataUrl, thumbUrl, file: f });
        };
        rd.onerror = () => resolve(null);
        rd.readAsDataURL(f);
      })));
      results.forEach(r => { if (r) photos.push(r); });
    }
    
    setMessage(`${photos.length}枚読込完了。手動で区切ってください（S: 区切る）`);
    setSorterPhotos(photos);
    setSorterSplits(new Set());
    setSorterBarcodes(new Set());
    setSorterManualBC(true);
    setSorterSelected(-1);
    setSorterMode(true);
    setLoading(false);
  };

  const sorterToggleSplit = () => {
    if (sorterSelected < 0 || sorterSelected >= sorterPhotos.length - 1) return;
    const sp = sorterSelected + 1;
    setSorterSplits(prev => {
      const n = new Set(prev);
      n.has(sp) ? n.delete(sp) : n.add(sp);
      return n;
    });
  };

  const sorterUndoSplit = () => {
    setSorterSplits(prev => {
      if (prev.size === 0) return prev;
      const sorted = Array.from(prev).sort((a,b) => b - a);
      const n = new Set(prev);
      n.delete(sorted[0]);
      return n;
    });
  };

  const sorterGetGroups = () => {
    const sorted = [0, ...Array.from(sorterSplits).sort((a,b) => a - b)];
    return sorted.map((start, i) => {
      const end = i + 1 < sorted.length ? sorted[i + 1] : sorterPhotos.length;
      return { start, end, count: end - start, photos: sorterPhotos.slice(start, end) };
    });
  };

  const sorterFinish = async () => {
    setLoading(true);
    setMessage('グループ生成中...');
    const groups = sorterGetGroups();
    const prods = groups.map((g, i) => {
      const folder = `PC_${String(i+1).padStart(3,'0')}`;
      const bcPhotoIdx = g.photos.findIndex((_, pi) => sorterBarcodes.has(g.start + pi));
      return {
        id: folder, folder,
        images: g.photos.map((p, pi) => ({ 
          id: p.id, filename: p.filename, dataUrl: p.dataUrl, thumbUrl: p.thumbUrl, excluded: false,
          isBarcode: sorterBarcodes.has(g.start + pi)
        })),
        barcode: null,
        _bcPhotoIdx: bcPhotoIdx >= 0 ? bcPhotoIdx : g.photos.length - 1
      };
    });
    
    if (apiKey) {
      const total = prods.length;
      setMessage(`🔄 AI処理開始（${total}商品）`);
      const t0 = Date.now();
      
      const fmtEta = (done, total, t0) => {
        const elapsed = (Date.now() - t0) / 1000;
        if (done < 2) return '';
        const perItem = elapsed / done;
        const remaining = Math.ceil(perItem * (total - done));
        if (remaining < 60) return `残り約${remaining}秒`;
        return `残り約${Math.ceil(remaining/60)}分`;
      };
      
      // 即座にStep2表示、バックグラウンドでAI処理
      prods.forEach(p => delete p._bcPhotoIdx);
      setProducts([...prods]);
      setSorterMode(false);
      setStep(2);
      setLoading(false); // UI操作可能に
      
      let errors = 0;
      for (let i = 0; i < total; i++) {
        const p = prods[i];
        
        // OCR
        const allActive = p.images.filter(img => !img.excluded);
        const bcImg = allActive.find(img => img.isBarcode) || allActive[allActive.length - 1];
        if (bcImg && !p.barcode) {
          try {
            setMessage(`📷 BC読取 ${i+1}/${total} ${fmtEta(i, total, t0)}`);
            const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
            if (bc) p.barcode = bc;
          } catch (e) {
            errors++;
            console.error(`OCRエラー(${i+1}):`, e);
            if (errors >= 5) { setMessage(`⚠️ エラー多発のため中断。「AI再処理」で再開できます`); break; }
          }
        }
        
        // 画像分類＆並替
        if (allActive.length >= 3 && claudeKey) {
          try {
            setMessage(`🤖 分類 ${i+1}/${total} ${fmtEta(i, total, t0)}`);
            const classResult = await classifyImages(claudeKey, allActive);
            if (classResult) {
          
          const { results: classifications, condition, notes } = classResult;
          p.condition = condition || 3;
          p.conditionNotes = notes || '';
          
          const byCategory = { main: [], keyboard: [], side: [], info: [], spec: [], barcode: [], other: [] };
          classifications.forEach(c => {
            const img = allActive[c.index];
            if (!img) return;
            // screen/battery → info に統合
            const cat = (c.category === 'screen' || c.category === 'battery') ? 'info' : c.category;
            img.category = byCategory[cat] ? cat : 'other';
            if (byCategory[cat]) byCategory[cat].push(img);
            else byCategory.other.push(img);
          });
          
          const sorted = [];
          const mergedSrcIds = new Set();
          const mergeAndPush = async (imgs, name) => {
            if (imgs.length >= 2) {
              const { dataUrl, filename } = await mergeImages(imgs, 2);
              sorted.push({ id: `merged_${Date.now()}_${name}`, filename, dataUrl, excluded: false, category: name });
              imgs.forEach(img => mergedSrcIds.add(img.id));
            } else { sorted.push(...imgs); }
          };
          
          // main(2) → info(結合) → spec(結合) → keyboard(結合) → side(結合) → other
          sorted.push(...byCategory.main.slice(0, 2));
          if (byCategory.main.length > 2) byCategory.other.push(...byCategory.main.slice(2));
          if (byCategory.info.length >= 2) { await mergeAndPush(byCategory.info.slice(0, 4), 'info'); if (byCategory.info.length > 4) byCategory.other.push(...byCategory.info.slice(4)); }
          else { sorted.push(...byCategory.info); }
          if (byCategory.spec.length >= 2) { await mergeAndPush(byCategory.spec.slice(0, 4), 'spec'); if (byCategory.spec.length > 4) byCategory.other.push(...byCategory.spec.slice(4)); }
          else { sorted.push(...byCategory.spec); }
          if (byCategory.keyboard.length >= 2) { await mergeAndPush(byCategory.keyboard.slice(0, 4), 'keyboard'); if (byCategory.keyboard.length > 4) byCategory.other.push(...byCategory.keyboard.slice(4)); }
          else { sorted.push(...byCategory.keyboard); }
          if (byCategory.side.length >= 2) {
            await mergeAndPush(byCategory.side.slice(0, 4), 'side');
            if (byCategory.side.length > 4) byCategory.other.push(...byCategory.side.slice(4));
          } else { sorted.push(...byCategory.side); }
          sorted.push(...byCategory.other);
          byCategory.barcode.forEach(img => img.isBarcode = true);
          sorted.push(...byCategory.barcode);

          
          const excludedImgs = p.images.filter(img => img.excluded || mergedSrcIds.has(img.id)).map(img => ({ ...img, excluded: true }));
          p.images = [...sorted, ...excludedImgs];
            }
          } catch (e) { console.error(`分類エラー(${i+1}):`, e); }
        }
        
        // 1商品完了→即反映
        setProducts([...prods]);
      }
      
      const elapsed = Math.round((Date.now() - t0) / 1000);
      const bcOk = prods.filter(p => p.barcode).length;
      const bcFail = prods.filter(p => !p.barcode).map(p => p.folder);
      var doneMsg = `✅ ${total}商品、${bcOk}件BC読取完了（${elapsed}秒）`;
      if (bcFail.length > 0) doneMsg += `\n⚠️ BC読取失敗(${bcFail.length}件): ${bcFail.slice(0, 20).join(', ')}${bcFail.length > 20 ? '...' : ''}`;
    }
    
    prods.forEach(p => { delete p._bcPhotoIdx; delete p._sorted; });
    
    setProducts([...prods]);
    setSorterMode(false);
    setMessage(doneMsg || `✅ ${prods.length}商品に振り分け完了`);
    setBcReviewReady(true);
    setStep(2);
    setLoading(false);
  };

  // カテゴリで再並替＆再結合（手動カテゴリ変更後に使う）
  const resortByCategory = async (prodIdx) => {
    const p = products[prodIdx || currentIdx];
    if (!p) return;
    setLoading(true);
    setMessage('🔄 カテゴリで再並替中...');
    try {
      const np = [...products];
      const idx = prodIdx ?? currentIdx;
      
      // 1. merged画像を元画像に戻す（excludedの元画像を復元）
      let restored = [];
      const mergedIds = new Set();
      p.images.forEach(img => {
        if (img.id?.startsWith('merged_')) {
          mergedIds.add(img.id);
        }
      });
      // merged画像を除去し、元のexcluded画像を復元
      p.images.forEach(img => {
        if (mergedIds.has(img.id)) return; // merged自体はスキップ
        if (img.excluded && mergedIds.size > 0) {
          // mergedの元画像の可能性 → 復元
          restored.push({ ...img, excluded: false });
        } else {
          restored.push(img);
        }
      });
      
      // 2. カテゴリ別に分類
      const active = restored.filter(img => !img.excluded);
      const excluded = restored.filter(img => img.excluded);
      const byCategory = { main: [], keyboard: [], side: [], info: [], spec: [], barcode: [], other: [] };
      active.forEach(img => {
        const cat = img.category || 'other';
        if (byCategory[cat]) byCategory[cat].push(img);
        else byCategory.other.push(img);
      });
      
      // 3. 並替＆結合
      const sorted = [];
      const mergedSrcIds = new Set();
      const mergeAndPush = async (imgs, name) => {
        if (imgs.length >= 2) {
          const { dataUrl, filename } = await mergeImages(imgs, 2);
          sorted.push({ id: `merged_${Date.now()}_${name}`, filename, dataUrl, excluded: false, category: name });
          imgs.forEach(img => mergedSrcIds.add(img.id));
        } else { sorted.push(...imgs); }
      };
      sorted.push(...byCategory.main.slice(0, 2));
      if (byCategory.main.length > 2) byCategory.other.push(...byCategory.main.slice(2));
      if (byCategory.info.length >= 2) { await mergeAndPush(byCategory.info.slice(0, 4), 'info'); if (byCategory.info.length > 4) byCategory.other.push(...byCategory.info.slice(4)); }
      else { sorted.push(...byCategory.info); }
      if (byCategory.spec.length >= 2) { await mergeAndPush(byCategory.spec.slice(0, 4), 'spec'); if (byCategory.spec.length > 4) byCategory.other.push(...byCategory.spec.slice(4)); }
      else { sorted.push(...byCategory.spec); }
      if (byCategory.keyboard.length >= 2) { await mergeAndPush(byCategory.keyboard.slice(0, 4), 'keyboard'); if (byCategory.keyboard.length > 4) byCategory.other.push(...byCategory.keyboard.slice(4)); }
      else { sorted.push(...byCategory.keyboard); }
      if (byCategory.side.length >= 2) { await mergeAndPush(byCategory.side.slice(0, 4), 'side'); if (byCategory.side.length > 4) byCategory.other.push(...byCategory.side.slice(4)); }
      else { sorted.push(...byCategory.side); }
      sorted.push(...byCategory.other);
      byCategory.barcode.forEach(img => img.isBarcode = true);
      sorted.push(...byCategory.barcode);
      
      const newExcluded = restored.filter(img => mergedSrcIds.has(img.id) || (img.excluded && !mergedSrcIds.has(img.id))).map(img => ({ ...img, excluded: true }));
      np[idx].images = [...sorted, ...newExcluded];
      setProducts(np);
      setMessage(`✅ カテゴリで再並替完了（${sorted.length}枚）`);
    } catch (e) {
      console.error('resortByCategory error:', e);
      setMessage(`❌ 再並替エラー: ${e.message}`);
    }
    setLoading(false);
  };

  // AI再処理（エラー中断後の再開用 / 未処理商品のみ）
  const aiReprocess = async () => {
    if (!apiKey) return setMessage('❌ OpenAI APIキー未設定');
    if (!claudeKey) return setMessage('❌ Claude APIキー未設定（画像分類に必要）');
    setLoading(true);
    const total = products.length;
    const t0 = Date.now();
    
    const fmtEta = (done, total, t0) => {
      const elapsed = (Date.now() - t0) / 1000;
      if (done < 2) return '';
      const perItem = elapsed / done;
      const remaining = Math.ceil(perItem * (total - done));
      return remaining < 60 ? `残り約${remaining}秒` : `残り約${Math.ceil(remaining/60)}分`;
    };
    
    const np = [...products];
    let processed = 0;
    
    for (let i = 0; i < np.length; i++) {
      const p = np[i];
      
      // OCR未完了
      if (!p.barcode) {
        const allActive = p.images.filter(img => !img.excluded);
        const bcImg = allActive.find(img => img.isBarcode) || allActive[allActive.length - 1];
        if (bcImg) {
          try {
            setMessage(`📷 BC再読取... ${i+1}/${total} ${fmtEta(processed, total, t0)}`);
            const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
            if (bc) p.barcode = bc;
          } catch (e) { console.error('OCRエラー:', e); }
        }
      }
      
      // merged済み（分類完了）の商品は再分類しない。手動で🔓分解→🔀再並替を使う
      const hasMerged = p.images.some(img => img.id?.startsWith('merged_'));
      const hasCategories = p.images.some(img => img.category);
      
      // 未分類の商品のみAI分類
      const activeImgs = p.images.filter(img => !img.excluded);
      if (!hasMerged && !hasCategories && activeImgs.length > 1) {
        try {
          setMessage(`🤖 分類＆並替... ${i+1}/${total} ${fmtEta(processed, total, t0)}`);
          const classResult = await classifyImages(claudeKey, activeImgs);
          if (classResult) {
            const { results: classifications, condition, notes } = classResult;
            p.condition = condition || 3;
            p.conditionNotes = notes || '';
            const byCategory = { main: [], keyboard: [], side: [], info: [], spec: [], barcode: [], other: [] };
            classifications.forEach(c => {
              const img = activeImgs[c.index];
              if (!img) return;
              const cat = (c.category === 'screen' || c.category === 'battery') ? 'info' : c.category;
              img.category = byCategory[cat] ? cat : 'other';
              if (byCategory[cat]) byCategory[cat].push(img);
              else byCategory.other.push(img);
            });
            const sorted = [];
            const mergedSrcIds = new Set();
            const mergeAndPush = async (imgs, name) => {
              if (imgs.length >= 2) {
                const { dataUrl, filename } = await mergeImages(imgs, 2);
                sorted.push({ id: `merged_${Date.now()}_${name}`, filename, dataUrl, excluded: false, category: name });
                imgs.forEach(img => mergedSrcIds.add(img.id));
              } else { sorted.push(...imgs); }
            };
            // main(2) → info(結合) → spec(結合) → keyboard(結合) → side(結合) → other
            sorted.push(...byCategory.main.slice(0, 2));
            if (byCategory.main.length > 2) byCategory.other.push(...byCategory.main.slice(2));
            if (byCategory.info.length >= 2) { await mergeAndPush(byCategory.info.slice(0, 4), 'info'); if (byCategory.info.length > 4) byCategory.other.push(...byCategory.info.slice(4)); }
            else { sorted.push(...byCategory.info); }
            if (byCategory.spec.length >= 2) { await mergeAndPush(byCategory.spec.slice(0, 4), 'spec'); if (byCategory.spec.length > 4) byCategory.other.push(...byCategory.spec.slice(4)); }
            else { sorted.push(...byCategory.spec); }
            if (byCategory.keyboard.length >= 2) { await mergeAndPush(byCategory.keyboard.slice(0, 4), 'keyboard'); if (byCategory.keyboard.length > 4) byCategory.other.push(...byCategory.keyboard.slice(4)); }
            else { sorted.push(...byCategory.keyboard); }
            if (byCategory.side.length >= 2) {
              await mergeAndPush(byCategory.side.slice(0, 4), 'side');
              if (byCategory.side.length > 4) byCategory.other.push(...byCategory.side.slice(4));
            } else { sorted.push(...byCategory.side); }
            sorted.push(...byCategory.other);
            byCategory.barcode.forEach(img => img.isBarcode = true);
            sorted.push(...byCategory.barcode);

            const excludedImgs = p.images.filter(img => img.excluded || mergedSrcIds.has(img.id)).map(img => ({ ...img, excluded: true }));
            p.images = [...sorted, ...excludedImgs];
          }
        } catch (e) { console.error('⚠️ 分類エラー:', e); setMessage(`⚠️ 分類失敗(${p.folder || i}): ${e.message?.slice(0,50)}`); }
      }
      processed++;
    }
    
    setProducts(np);
    setLoading(false);
    const elapsed = Math.round((Date.now() - t0) / 1000);
    const bcFail = np.filter(p => !p.barcode).map(p => p.folder);
    let reMsg = `✅ AI再処理完了（${elapsed}秒）`;
    if (bcFail.length > 0) reMsg += `\n⚠️ BC読取失敗(${bcFail.length}件): ${bcFail.slice(0, 20).join(', ')}${bcFail.length > 20 ? '...' : ''}`;
    setMessage(reMsg);
    setBcReviewReady(true);
  };

  // OCR
  // バーコード画像を見つけるヘルパー
  const findBarcodeImage = (p) => {
    // isBarcode フラグ付き画像を優先
    const bcImg = p.images.find(img => img.isBarcode && !img.excluded);
    if (bcImg) return bcImg;
    // フラグなし→最後のactive画像
    const active = p.images.filter(img => !img.excluded);
    return active[active.length - 1] || p.images[p.images.length - 1];
  };

  const doOcr = async (idx) => {
    const p = products[idx];
    if (!p.images.length || !apiKey) return;
    setLoading(true);
    try {
      const bcImg = findBarcodeImage(p);
      const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
      if (bc) {
        const np = [...products];
        np[idx].barcode = bc;
        setProducts(np);
        setMessage(`OCR成功: ${bc}`);
      } else {
        alert('読取失敗: バーコードが見つかりませんでした');
      }
    } catch (e) {
      console.error('OCR Error:', e);
      alert('読取失敗: ' + e.message);
    }
    setLoading(false);
  };

  const doOcrAll = async () => {
    if (!apiKey) return alert('APIキーを設定してください');
    setLoading(true);
    let successCount = 0;
    for (let i = 0; i < products.length; i++) {
      if (products[i].barcode) continue;
      try {
        setMessage(`OCR中... ${i+1}/${products.length}`);
        const bcImg = findBarcodeImage(products[i]);
        const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
        if (bc) {
          const np = [...products];
          np[i].barcode = bc;
          setProducts(np);
          successCount++;
        }
      } catch (e) {
        console.error('OCR error for product', i, e);
      }
    }
    setMessage(`OCR完了: ${successCount}件成功`);
    setLoading(false);
  };

  // 画像並び替え
  const moveImage = (from, to) => {
    if (from === to) return;
    const np = [...products];
    const imgs = [...np[currentIdx].images];
    const [moved] = imgs.splice(from, 1);
    imgs.splice(to > from ? to - 1 : to, 0, moved);
    np[currentIdx] = { ...np[currentIdx], images: imgs };
    setProducts(np);
    setDragIdx(null);
  };
  
  // 選択画像を別PCへ移動
  const moveSelectedToProduct = (targetIdx) => {
    if (selectedImages.length === 0 || targetIdx === currentIdx) return;
    if (targetIdx < 0 || targetIdx >= products.length) return;
    const np = [...products];
    const movedImgs = selectedImages.map(i => np[currentIdx].images[i]).filter(Boolean);
    // 元PCから削除
    np[currentIdx] = { ...np[currentIdx], images: np[currentIdx].images.filter((_, i) => !selectedImages.includes(i)) };
    // 先頭PCの末尾(バーコード前)に追加
    const targetImgs = [...np[targetIdx].images];
    const lastActive = targetImgs.filter(img => !img.excluded);
    const insertAt = lastActive.length > 0 ? targetImgs.indexOf(lastActive[lastActive.length - 1]) : targetImgs.length;
    targetImgs.splice(insertAt, 0, ...movedImgs);
    np[targetIdx] = { ...np[targetIdx], images: targetImgs };
    setProducts(np);
    setSelectedImages([]);
    setMessage(`${movedImgs.length}枚をPC ${targetIdx + 1}へ移動`);
  };

  const toggleExclude = (imgIdx) => {
    const np = [...products];
    np[currentIdx].images[imgIdx].excluded = !np[currentIdx].images[imgIdx].excluded;
    setProducts(np);
  };

  // 自動画像並び替え
  // 軽量照合: CSVマッチ+スペック抽出+価格のみ（OCR/AI/紹介文スキップ）
  // BC検査後や再照合に使用
  const rematchProducts = () => {
    const findPurchase = (bc) => {
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      const matches = purchaseData.filter(r => {
        const v = String(r['バーコード番号'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
      if (matches.length === 0) return null;
      return matches.find(r => !String(r['バーコード番号'] || '').includes('他')) || matches[0];
    };
    const findPrice = (bc, specs) => {
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      const bcMatch = priceData.find(r => {
        const v = String(r['バーコード番号'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
      if (bcMatch) return bcMatch;
      const mgmtMatch = priceData.find(r => {
        const nums = String(r['管理番号'] || '').replace(/[^0-9]/g, '');
        return nums.length >= 6 && nums.slice(-6) === bcNorm;
      });
      return mgmtMatch || null;
    };
    const np = products.map(p => {
      if (!p.barcode) return { ...p, status: p.specs?.cpu ? 'ocr_specs' : 'no_barcode', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      const bcRaw = p.barcode.replace(/[^0-9]/g, '');
      const barcode = bcRaw ? bcRaw.padStart(6, '0').slice(-6) : '';
      if (!barcode) return { ...p, status: p.specs?.cpu ? 'ocr_specs' : 'no_barcode', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      const row = findPurchase(barcode);
      if (!row) return { ...p, barcode, status: p.specs?.cpu ? 'ocr_specs' : 'no_data', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      // CSVからスペック取得（既存OCRスペックがあればそちらを優先）
      const csvSpecs = extractSpecs(row);
      const specs = p.specs?.cpu ? p.specs : csvSpecs;
      const type = p.product_type || detectProductType(row, specs);
      const priceRow = findPrice(barcode, specs);
      const purchaseCost = parseInt(row['成約金額']) || parseInt(row['自社入札金額']) || null;
      const costBasedPrice = purchaseCost ? calcSellingPrice(purchaseCost) : null;
      const refPrice = priceRow ? (parseInt(priceRow['メルカリ販売価格(入力)']) || parseInt(priceRow['販売価格']) || null) : null;
      const rowPrice = row['販売価格'] ? parseInt(row['販売価格']) : null;
      const candidates = [costBasedPrice, refPrice, rowPrice].filter(x => x && x !== 999999 && x > 0);
      const price = p.price || (candidates.length > 0 ? Math.max(...candidates) : null);
      const rank = String(row['評価点'] || '').trim().toUpperCase();
      const acc = parseAccessories(row['付属品情報'] || '');
      const accessories = acc.length > 0 ? acc : (p.accessories || ['ACアダプター', 'ACコード']);
      const defect = [row['瑕疵情報1'], row['瑕疵情報2']].filter(x => x && !x.includes('中古品の為')).join('、');
      const csvCondition = (rank && CONDITION_MAP[rank]) ? CONDITION_MAP[rank] : null;
      let finalCondition = csvCondition || p.condition || 3;
      let finalNotes = p.conditionNotes || '中古品なりの使用感はありますが、美品となります。';
      if (defect && finalCondition < 4) { finalCondition = 4; if (finalNotes.includes('美品')) finalNotes = '使用に伴う多少のスレがあります。'; }
      return {
        ...p, barcode, status: 'ok', specs, product_type: type, price, purchaseCost, rank,
        condition: finalCondition, conditionNotes: finalNotes, accessories,
        defect_info: defect, is_english_kb: (row['付属品情報'] || '').includes('英字KB'),
      };
    });
    setProducts(np);
    const matched = np.filter(x => x.status === 'ok').length;
    setMessage(`✅ 照合完了: ${matched}/${np.length}件マッチ`);
    setStep(3);
    // 即座にIDB保存（state更新を待たず直接npを保存）
    const lightNp = np.map(p => ({ ...p, images: p.images.map(img => ({ id: img.id, filename: img.filename, category: img.category, isBarcode: img.isBarcode, excluded: img.excluded })) }));
    idbSave({ step: 3, currentIdx, products: lightNp, savedAt: new Date().toISOString(), version: '5.1', lightMode: true });
  };

  // データ処理（フル: OCR/AI型番/Mac判定/紹介文含む）
  const processProducts = async () => {
    setLoading(true);
    try {
    // 単品データを優先（「他」がついてないもの）
    const findPurchase = (bc) => {
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      const matches = purchaseData.filter(r => {
        const v = String(r['バーコード番号'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
      if (matches.length === 0) return null;
      const single = matches.find(r => !String(r['バーコード番号'] || '').includes('他'));
      return single || matches[0];
    };
    const findPrice = (bc, specs) => {
      // 1. バーコードで検索（従来形式: バーコード番号列）
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      const bcMatch = priceData.find(r => {
        const v = String(r['バーコード番号'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
      if (bcMatch) return bcMatch;
      
      // 2. 管理番号にバーコード含む（XLSX形式: "874471 1049-I SEL1049000001"）
      const mgmtMatch = priceData.find(r => {
        const mgmt = String(r['管理番号'] || '');
        const nums = mgmt.replace(/[^0-9]/g, '');
        return nums.length >= 6 && nums.slice(-6) === bcNorm;
      });
      if (mgmtMatch) return mgmtMatch;
      
      // 3. Keywordで型番マッチ（"DELL Latitude 3510 10210U 16GB 256GB"）
      if (specs && priceData.some(r => r['Keyword'])) {
        const maker = (specs.maker || '').toLowerCase();
        const model = (specs.product_name || '').toLowerCase();
        const cpu = (specs.cpu || '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        const mem = (specs.memory || '').replace(/[^0-9]/g, '');
        const stor = (specs.storage || '').replace(/[^0-9]/g, '');
        
        // 同じ型番+CPU+メモリ+ストレージで一致するものを探す
        const kwMatches = priceData.filter(r => {
          const kw = String(r['Keyword'] || '').toLowerCase();
          if (!kw) return false;
          const kwNorm = kw.replace(/[^a-zA-Z0-9\s]/g, '');
          const modelMatch = model && kw.includes(model.split('(')[0].trim().toLowerCase());
          const cpuMatch = cpu && kwNorm.replace(/[^a-zA-Z0-9]/g, '').includes(cpu.slice(0, 6));
          const memMatch = mem && kw.includes(mem + 'gb');
          return (modelMatch || cpuMatch) && memMatch;
        });
        // 販売価格が入ってるものを優先、最高額を返す
        const withPrice = kwMatches.filter(r => parseInt(r['販売価格']) > 0);
        if (withPrice.length > 0) {
          return withPrice.sort((a, b) => (parseInt(b['販売価格']) || 0) - (parseInt(a['販売価格']) || 0))[0];
        }
      }
      return null;
    };

    const np = products.map(p => {
      if (!p.barcode) return { ...p, status: 'no_barcode', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      const bcRaw = p.barcode.replace(/[^0-9]/g, '');
      const barcode = bcRaw ? bcRaw.padStart(6, '0').slice(-6) : '';
      if (!barcode) return { ...p, status: 'no_barcode', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      const row = findPurchase(barcode);
      if (!row) return { ...p, barcode, status: 'no_data', condition: p.condition || 3, conditionNotes: p.conditionNotes || '中古品なりの使用感はありますが、美品となります。' };
      const specs = extractSpecs(row);
      const type = detectProductType(row, specs);
      const priceRow = findPrice(barcode, specs);
      const purchaseCost = parseInt(row['成約金額']) || parseInt(row['自社入札金額']) || null;
      
      // 価格決定: 仕入原価ベース vs 販売価格CSV → 高い方
      const costBasedPrice = purchaseCost ? calcSellingPrice(purchaseCost) : null;
      const refPrice = priceRow ? (parseInt(priceRow['メルカリ販売価格(入力)']) || parseInt(priceRow['販売価格']) || null) : null;
      const rowPrice = row['販売価格'] ? parseInt(row['販売価格']) : null;
      
      // 999999は未設定
      const candidates = [costBasedPrice, refPrice, rowPrice].filter(p => p && p !== 999999 && p > 0);
      let price = candidates.length > 0 ? Math.max(...candidates) : null;
      console.log(`💰 ${barcode}: cost=${purchaseCost}→${costBasedPrice}, ref=${refPrice}, row=${rowPrice} → ${price}`);
      const rank = String(row['評価点'] || '').trim().toUpperCase();
      const acc = parseAccessories(row['付属品情報'] || '');
      const accessories = acc.length > 0 ? acc : ['ACアダプター', 'ACコード'];
      const defect = [row['瑕疵情報1'], row['瑕疵情報2']].filter(x => x && !x.includes('中古品の為')).join('、');
      // 状態判定: CSVランク > AI判定 > デフォルト3
      // CSV瑕疵はcondition数値の引き上げのみ（テキストは出品に載せない）
      const csvCondition = (rank && CONDITION_MAP[rank]) ? CONDITION_MAP[rank] : null;
      let finalCondition = csvCondition || p.condition || 3;
      let finalNotes = p.conditionNotes || '中古品なりの使用感はありますが、美品となります。';
      if (defect) {
        if (finalCondition < 4) finalCondition = 4;
        // AI判定がデフォルト美品のままならconditionに合わせたテキストに変更
        if (finalNotes === '中古品なりの使用感はありますが、美品となります。') {
          finalNotes = '使用に伴う多少のスレがあります。';
        }
      }
      return {
        ...p, barcode, status: 'ok', specs, product_type: type, price, purchaseCost, rank,
        condition: finalCondition,
        conditionNotes: finalNotes,
        accessories: accessories, defect_info: defect,
        is_english_kb: (row['付属品情報'] || '').includes('英字KB'),
        hasOffice: p.hasOffice || false,
        isJunk: p.isJunk || false
      };
    });
    setProducts(np);

    // バーコード無し/CSVマッチ無し → 画像からスペック抽出
    // + CSVマッチしたがメーカー不明/DESKTOP型番の場合もOCR実行
    if (apiKey) {
      const isBadMaker = (m) => !m || /^不明|^unknown|^表示なし/i.test(m);
      const isBadModel = (m) => !m || /^DESKTOP-/i.test(m) || isInternalCode(m);
      const needOcr = np.filter(p => {
        if (p.specs?.cpu && !isBadMaker(p.specs?.maker)) return false; // 既にOK
        if (p.status === 'no_barcode' || p.status === 'no_data') return !p.specs?.cpu;
        // CSVマッチ済みでもメーカー不明 or 型番がDESKTOP等ならOCR
        if (isBadMaker(p.specs?.maker) || isBadModel(p.specs?.product_name)) return true;
        return false;
      });
      if (needOcr.length > 0) {
        setMessage(`📷 画像からスペック読取中... 0/${needOcr.length}`);
        for (let i = 0; i < needOcr.length; i++) {
          const p = needOcr[i];
          setMessage(`📷 画像からスペック読取中... ${i+1}/${needOcr.length} (${p.folder})`);
          try {
            const needMaker = isBadMaker(p.specs?.maker);
            const ocrResult = await ocrSpecs(apiKey, p.images, needMaker);
            if (ocrResult) {
              const idx = np.findIndex(x => x.id === p.id);
              if (idx >= 0) {
                const s = ocrResult;
                const existing = np[idx].specs || {};
                const hadCsvData = np[idx].status === 'ok';
                if (hadCsvData) {
                  // CSVデータあり → メーカー/型番のみOCRで補完、スペックはCSV優先
                  if (isBadMaker(existing.maker) && s.maker) existing.maker = s.maker;
                  if (isBadModel(existing.product_name) && s.product_name) existing.product_name = cleanModelName(s.product_name);
                  if (!existing.cpu && s.cpu) existing.cpu = cleanCpu(s.cpu);
                  if (!existing.display && (s.display || s.size)) existing.display = s.display || s.size;
                  np[idx].specs = existing;
                } else {
                  // CSVデータなし → フルOCR
                  np[idx].specs = {
                    maker: s.maker || '', product_name: cleanModelName(s.product_name || ''),
                    cpu: cleanCpu(s.cpu || ''), memory: normalizeMemory(s.memory || ''), storage: normalizeStorage(s.storage || ''),
                    display: s.display || s.size || '', gpu: cleanGpu(s.gpu || ''),
                    model: s.model || s.product_name || '', size: s.size || s.display || '',
                    year: s.year || null, chip: s.chip || null
                  };
                  np[idx].status = 'ocr_specs';
                }
                // Mac判定
                const mk = (np[idx].specs.maker || '').toLowerCase();
                const pn = (np[idx].specs.product_name || '').toLowerCase();
                const isMac = mk.includes('apple') || (s.chip && /^M\d/i.test(s.chip)) || pn.includes('mac');
                if (isMac) np[idx].product_type = s.chip ? 'apple_silicon' : 'intel_mac';
                if (s.cycle_count) np[idx].cycle_count = s.cycle_count;
                if (s.battery_health) np[idx].battery_health = s.battery_health;
              }
            }
          } catch(e) { console.error('ocrSpecs error:', p.folder, e); }
          setProducts([...np]);
        }
      }
    }

    // AI型番解決（内部型番→正式名）GPT-5.2使用
    if (apiKey) {
      const needResolve = np.filter(p => p.specs?._needsAI && p.specs?._rawCode);
      if (needResolve.length > 0) {
        setMessage(`📘 型番変換中... 0/${needResolve.length}`);
        for (let i = 0; i < needResolve.length; i++) {
          const p = needResolve[i];
          const code = p.specs._rawCode;
          const context = [p.specs.maker, p.specs.cpu, p.specs.memory].filter(Boolean).join(' ');
          setMessage(`📘 型番変換中... ${i+1}/${needResolve.length} (${code})`);
          try {
            const resolved = await resolveModelAI(code, context, apiKey);
            if (resolved) {
              const idx = np.findIndex(x => x.id === p.id);
              if (idx >= 0) {
                // メーカー名を分離
                const { maker: resMaker, name: resName } = splitMakerFromName(resolved);
                np[idx].specs.product_name = resName || resolved;
                np[idx].specs._resolved = true;
                delete np[idx].specs._needsAI;
                // メーカー補完
                if (!np[idx].specs.maker && resMaker) {
                  np[idx].specs.maker = normalizeMaker(resMaker);
                }
              }
            }
          } catch(e) { console.error('型番AI解決エラー:', code, e); }
          setProducts([...np]);
        }
      }
    }

    // Mac年式・モデル判定（GPT-5.2）
    if (apiKey) {
      const needMacResolve = np.filter(p => 
        ['intel_mac', 'apple_silicon'].includes(p.product_type) && !p.specs?.year
      );
      if (needMacResolve.length > 0) {
        setMessage(`🍎 Mac年式判定中... 0/${needMacResolve.length}`);
        for (let i = 0; i < needMacResolve.length; i++) {
          const p = needMacResolve[i];
          setMessage(`🍎 Mac年式判定中... ${i+1}/${needMacResolve.length} (${p.folder})`);
          try {
            const result = await resolveMacModel(apiKey, p.specs);
            if (result) {
              const idx = np.findIndex(x => x.id === p.id);
              if (idx >= 0) {
                if (result.year) np[idx].specs.year = result.year;
                if (result.model) np[idx].specs.model = result.model;
                if (result.size && !np[idx].specs.size) np[idx].specs.size = result.size + 'インチ';
                console.log(`🍎 Mac判定: ${p.folder} → ${result.model} ${result.year} ${result.size || ''}`);
              }
            }
          } catch(e) { console.error('Mac判定エラー:', p.folder, e); }
          setProducts([...np]);
        }
      }
    }

    setProducts(np);
    setStep(3);
    setLoading(false);
    setMessage('');
    // 即座にIDB保存
    const lightNp = np.map(p => ({ ...p, images: p.images.map(img => ({ id: img.id, filename: img.filename, category: img.category, isBarcode: img.isBarcode, excluded: img.excluded })) }));
    idbSave({ step: 3, currentIdx, products: lightNp, savedAt: new Date().toISOString(), version: '5.1', lightMode: true });
    } catch(e) {
      console.error('processProducts error:', e);
      setLoading(false);
      setMessage(`❌ データ処理エラー: ${e.message}`);
    }
  };

  // プレビュー画面へ（紹介文生成）
  const goToPreview = async () => {
    setLoading(true);
    setMessage('紹介文生成中...');
    const np = [...products];
    
    for (let i = 0; i < np.length; i++) {
      if (np[i].intro) continue; // 既に生成済みはスキップ
      if (!np[i].specs?.cpu && !np[i].specs?.chip) continue; // スペック無しはスキップ
      try {
        np[i].intro = (claudeKey || apiKey) ? await generateIntro(apiKey, np[i], claudeKey) : `${np[i].specs?.maker || ''}の中古PCです。`;
        // タイトルと説明文も事前生成
        np[i].title = np[i].title || makeTitle(np[i]);
        np[i].description = np[i].description || makeDescription(np[i], noticeText);
        setProducts([...np]);
        setMessage(`紹介文生成中... (${i+1}/${np.length})`);
      } catch (e) {
        console.error('紹介文生成エラー:', e);
        np[i].intro = `${np[i].specs?.maker || ''}の中古PCです。`;
        np[i].title = np[i].title || makeTitle(np[i]);
        np[i].description = np[i].description || makeDescription(np[i], noticeText);
      }
    }
    
    // 全商品のタイトル・説明文を生成（バーコードなしも含む）
    np.forEach(p => {
      if (!p.title) p.title = makeTitle(p);
      if (!p.description) p.description = makeDescription(p, noticeText);
    });
    
    setProducts(np);
    setCurrentIdx(0);
    setStep(4);
    setLoading(false);
    setMessage('');
  };

  // CSV生成
  // 出力フォルダ選択
  const pickOutputFolder = async () => {
    try {
      const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
      setOutputDirHandle(handle);
      setMessage(`📁 保存先: ${handle.name}`);
      return handle;
    } catch (e) {
      if (e.name !== 'AbortError') setMessage('❌ フォルダ選択失敗');
      return null;
    }
  };

  // 商品画像のファイル名生成（CSV・保存で共通使用）
  const makeImageFilename = (p, img, idx) => {
    return `${String(idx + 1).padStart(2, '0')}_${img.filename || `img_${idx}.jpg`}`;
  };

  // 全商品の画像をフォルダに保存（メルカリCSVインポート用: フラット構造）
  const saveAllImages = async () => {
    let dir = outputDirHandle;
    if (!dir) {
      dir = await pickOutputFolder();
      if (!dir) return;
    }
    setLoading(true);
    const okProducts = products;
    let saved = 0;
    for (let pi = 0; pi < okProducts.length; pi++) {
      const p = okProducts[pi];
      setMessage(`📁 保存中... ${pi + 1}/${okProducts.length} (${p.barcode || p.folder})`);
      try {
        const allActive = p.images.filter(img => !img.excluded);
        const hasBcFlag = allActive.some(img => img.isBarcode);
        const activeImgs = hasBcFlag 
          ? allActive.filter(img => !img.isBarcode)
          : allActive.slice(0, -1);
        for (let i = 0; i < Math.min(activeImgs.length, 20); i++) {
          const fname = makeImageFilename(p, activeImgs[i], i);
          await saveImageToFolder(dir, fname, activeImgs[i].dataUrl);
          saved++;
          if (saved % 5 === 0) await new Promise(r => setTimeout(r, 10));
        }
      } catch (e) { console.error(`保存エラー (${p.folder}):`, e); }
    }
    setLoading(false);
    setMessage(`✅ ${okProducts.length}商品 / ${saved}枚を保存しました`);
  };

  const generateCsv = async () => {
    setLoading(true);
    setMessage('CSV生成中...');
    
    // メルカリCSVヘッダー（正しい順序）
    const headers = [
      ...Array.from({length:20}, (_,i) => `商品画像名_${i+1}`),
      '商品名', '商品説明',
      'SKU1_種類', 'SKU1_在庫数', 'SKU1_商品管理コード', 'SKU1_JANコード',
      'ブランドID', '販売価格', 'カテゴリID', '商品の状態',
      '配送方法', '発送元の地域', '発送までの日数', '商品ステータス', '配送料の負担'
    ];
    
    // フィルター: 全商品出力（バーコードなしも含む）
    const okProducts = products;
    
    const rows = okProducts.map(p => {
      // 画像ファイル名（バーコード画像除く、元のファイル名をそのまま使用、最大20枚）
      const allActive = p.images.filter(img => !img.excluded);
      const hasBcFlag = allActive.some(img => img.isBarcode);
      const productImgs = hasBcFlag 
        ? allActive.filter(img => !img.isBarcode)
        : allActive.slice(0, -1);
      const imgs = productImgs
        .slice(0, 20)
        .map((img, i) => makeImageFilename(p, img, i));
      while (imgs.length < 20) imgs.push('');
      
      const cat = ['intel_mac', 'apple_silicon'].includes(p.product_type) ? CONFIG.category_macbook : CONFIG.category_windows;
      const conditionCode = typeof p.condition === 'number' ? p.condition : (CONFIG.condition_map[p.condition] || 3);
      const price = p.price || 0;  // 価格がなければ0（要設定）
      
      return [
        ...imgs,                           // 商品画像名_1～20
        p.title || makeTitle(p),           // 商品名（編集済みがあればそれを使用）
        p.description || makeDescription(p, noticeText), // 商品説明（編集済みがあればそれを使用）
        '',                                // SKU1_種類
        1,                                 // SKU1_在庫数
        '',                                // SKU1_商品管理コード（空）
        '',                                // SKU1_JANコード
        '',                                // ブランドID
        price,                             // 販売価格
        cat,                               // カテゴリID
        conditionCode,                     // 商品の状態
        CONFIG.shipping_method,            // 配送方法
        CONFIG.region,                     // 発送元の地域
        CONFIG.shipping_days,              // 発送までの日数
        1,                                 // 商品ステータス（1=下書き）
        CONFIG.shipping_fee                // 配送料の負担
      ];
    });
    
    // CSV生成（Shift-JIS、改行はそのまま）
    const escapeForCsv = (str) => {
      const s = String(str);
      // ダブルクォートをエスケープ
      if (s.includes('"') || s.includes(',') || s.includes('\n') || s.includes('\r')) {
        return '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    };
    
    const csvContent = [headers, ...rows].map(r => r.map(c => escapeForCsv(c)).join(',')).join('\r\n');
    
    // Shift-JISに変換してBlob作成（大きなデータはタイムアウト防止）
    try {
      await new Promise(r => setTimeout(r, 50)); // UIスレッド解放
      const unicodeArray = Encoding.stringToCode(csvContent);
      await new Promise(r => setTimeout(r, 50));
      const sjisArray = Encoding.convert(unicodeArray, { to: 'SJIS', from: 'UNICODE' });
      const blob = new Blob([new Uint8Array(sjisArray)], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `mercari_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      setMessage(`${rows.length}商品のCSVを生成しました`);
    } catch(e) {
      console.error('CSV生成エラー:', e);
      // フォールバック: UTF-8でダウンロード
      const bom = '\uFEFF';
      const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `mercari_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      setMessage(`⚠️ ${rows.length}商品のCSVを生成（UTF-8フォールバック）`);
    }
    setStep(5);
    setLoading(false);
  };

  // 途中保存: 全状態をJSONファイルとしてダウンロード
  const saveSession = () => {
    try {
      // 画像dataUrlを除外して軽量化
      const lightProducts = products.map(p => ({
        ...p,
        images: p.images.map(img => ({
          id: img.id, filename: img.filename, category: img.category,
          isBarcode: img.isBarcode, excluded: img.excluded,
        }))
      }));
      const data = { step, currentIdx, products: lightProducts, version: '5.1', savedAt: new Date().toISOString(), lightMode: true };
      const json = JSON.stringify(data);
      const blob = new Blob([json], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `mercari_session_${new Date().toISOString().slice(0,16).replace(/[:-]/g,'')}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      setMessage(`💾 セッション保存しました（${products.length}商品、画像除外）`);
    } catch(e) {
      console.error('saveSession error:', e);
      setMessage(`❌ 保存失敗: ${e.message}`);
    }
  };

  // 途中読込: JSONファイルから状態を復元
  const loadSession = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.products) {
          setProducts(data.products);
          setStep(data.step || 2);
          setCurrentIdx(data.currentIdx || 0);
          setMessage(`📂 セッション復元: ${data.products.length}商品（Step ${data.step || 2}）${data.savedAt ? ' / 保存日時: ' + new Date(data.savedAt).toLocaleString() : ''}`);
        }
      } catch (err) { setMessage('❌ セッションファイルの読込失敗'); }
    };
    reader.readAsText(file);
    e.target.value = '';
  };

  const cur = products[currentIdx];

  return (
    <div className="min-h-screen bg-gray-100">
      <header className="bg-red-500 text-white py-3 px-6 shadow">
        <h1 className="text-xl font-bold">メルカリCSV生成ツール <span className="text-sm font-normal text-gray-400">v5.1 (2/18)</span></h1>
      </header>

      <div className="max-w-6xl mx-auto p-4">
        {/* ステータス */}
        <div className="bg-white rounded shadow p-3 mb-4 flex gap-6 text-sm items-center">
          <span>仕入: <b>{purchaseData.length}</b></span>
          <span>価格: <b>{priceData.length}</b></span>
          <span>API: {apiKey ? '✓' : '未設定'}</span>
          <span className="text-purple-600">🤖 gpt-5-mini</span>
          <span className={claudeKey ? 'text-orange-500' : 'text-gray-400'}>🧠 {claudeKey ? 'Claude Haiku ✓' : 'Claude未設定'}</span>
          <span className="text-cyan-400">📘 型番DB {Object.keys(BASE_MODEL_MAP).length + Object.keys(getLearnedMap()).length}件</span>
          {(purchaseData.length > 0 || priceData.length > 0) && (
            <button onClick={clearSavedData} className="text-red-500 hover:text-red-700 text-xs">🗑️ データクリア</button>
          )}
          <button onClick={clearCacheKeepKeys} className="text-yellow-500 hover:text-yellow-700 text-xs">🧹 キャッシュ全削除</button>
          <span className="ml-auto text-gray-500">Step {step}/5</span>
          {products.length > 0 && (
            <button onClick={manualSave} className="text-green-600 hover:text-green-800 text-xs ml-1" title="手動保存（IndexedDB）">
              💾 保存{autoSaveTime ? ` (${autoSaveTime.toLocaleTimeString().slice(0,5)})` : ''}
            </button>
          )}
          {products.length > 0 && (
            <button onClick={saveSession} className="text-blue-500 hover:text-blue-700 text-xs" title="JSONファイルとしてダウンロード">📥 DL</button>
          )}
          {products.length > 0 && (
            <button onClick={reloadImagesFromFolder} disabled={loading} className="text-orange-500 hover:text-orange-700 text-xs font-bold disabled:opacity-50" title="フォルダから画像を再読み込み">📁 画像復元</button>
          )}
          <label className="text-blue-500 hover:text-blue-700 text-xs cursor-pointer" title="JSONファイルから復元">
            📤 読込
            <input type="file" accept=".json" onChange={loadSession} className="hidden"/>
          </label>
          <button onClick={() => setShowNoticeEditor(true)} className="text-gray-500 hover:text-gray-700 text-xs ml-2">📝 保証文</button>
          {sorterPhotos.length > 0 && !sorterMode && (
            <button onClick={() => setSorterMode(true)} className="text-blue-500 hover:text-blue-700 text-xs ml-2">📷 振り分け再開</button>
          )}
        </div>

        {/* 自動保存から復元バナー */}
        {pendingRestore && step === 1 && (
          <div className="bg-yellow-50 border border-yellow-300 rounded p-3 mb-4 flex items-center gap-3">
            <span className="text-yellow-700 font-medium">⚠️ 前回の作業データが見つかりました（{pendingRestore.products.length}商品, Step {pendingRestore.step}, {pendingRestore.savedAt ? new Date(pendingRestore.savedAt).toLocaleString() : ''}）</span>
            <button onClick={restoreSession} className="px-4 py-1.5 bg-yellow-500 text-white rounded font-bold hover:bg-yellow-600">復元する</button>
            {pendingRestore.lightMode && (
              <span className="text-xs text-gray-500 ml-2">⚠️画像なし → 復元後「📁 画像復元」で再読み込み</span>
            )}
            <button onClick={() => { setPendingRestore(null); idbClear(); }} className="px-3 py-1.5 border rounded text-gray-600 hover:bg-gray-50">破棄</button>
          </div>
        )}

        {message && <div className={`px-4 py-2 rounded mb-4 border whitespace-pre-wrap ${message.startsWith('❌') ? 'bg-red-50 border-red-200 text-red-700' : message.startsWith('✅') ? 'bg-green-50 border-green-200 text-green-700' : 'bg-blue-50 border-blue-200 text-blue-700'}`}>{message}</div>}

        {/* Step 1 */}
        {step === 1 && (
          <div>
            {/* 保存データがある場合の表示 */}
            {(purchaseData.length > 0 || priceData.length > 0) && (
              <div className="bg-green-50 border border-green-200 rounded p-3 mb-4 text-sm">
                <span className="font-medium text-green-700">💾 保存済みデータ: </span>
                {purchaseData.length > 0 && <span className="mr-3">仕入CSV {purchaseData.length}件</span>}
                {priceData.length > 0 && <span className="mr-3">価格データ {priceData.length}件</span>}
                <span className="text-green-600 ml-2">（自動復元済み）</span>
              </div>
            )}
            <div className="grid grid-cols-2 lg:grid-cols-5 gap-4">
              <DropZone
                title="仕入CSV"
                icon="file"
                color="blue"
                accept=".csv"
                multiple={true}
                onFiles={handlePurchaseFiles}
              />
              <DropZone
                title="価格Excel"
                icon="file"
                color="green"
                accept=".xlsx,.xls,.csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel"
                multiple={true}
                onFiles={handlePriceFiles}
              />
              <div className="bg-white rounded shadow p-4">
                <h3 className="font-bold mb-3 flex items-center gap-2"><Icon name="key" className="w-5 h-5 text-purple-500"/>OpenAI API <span className="text-xs text-gray-400 font-normal">(OCR・文章生成)</span></h3>
                <input type="password" placeholder="sk-..." value={apiKey} onChange={e => setApiKey(e.target.value)} className="w-full border rounded px-2 py-1 mb-2 text-sm"/>
                <div className="flex gap-2">
                  <button onClick={saveApiKey} className="flex-1 bg-purple-500 text-white rounded py-1 text-sm hover:bg-purple-600">保存</button>
                  <button onClick={testApi} disabled={loading} className="flex-1 bg-blue-500 text-white rounded py-1 text-sm hover:bg-blue-600 disabled:opacity-50">テスト</button>
                </div>
                <div className="mt-3 pt-3 border-t">
                  <h3 className="font-bold mb-2 flex items-center gap-2"><Icon name="key" className="w-5 h-5 text-orange-500"/>Claude API <span className="text-xs text-gray-400 font-normal">(画像分類)</span></h3>
                  <input type="password" placeholder="sk-ant-..." value={claudeKey} onChange={e => setClaudeKey(e.target.value)} className="w-full border rounded px-2 py-1 mb-2 text-sm"/>
                  <div className="flex gap-2">
                    <button onClick={() => { localStorage.setItem('claude_key', claudeKey); setMessage('Claude APIキー保存完了'); }} className="flex-1 bg-orange-500 text-white rounded py-1 text-sm hover:bg-orange-600">保存</button>
                    <button onClick={async () => {
                      if (!claudeKey) return setMessage('❌ Claude APIキーを入力してください');
                      setLoading(true);
                      try {
                        const r = await fetch('https://api.anthropic.com/v1/messages', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json', 'x-api-key': claudeKey, 'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
                          body: JSON.stringify({ model: 'claude-haiku-4-5-20251001', max_tokens: 50, messages: [{ role: 'user', content: 'Say OK' }] })
                        });
                        const d = await r.json();
                        if (d.error) throw new Error(d.error.message);
                        setMessage('✅ Claude API接続OK（Haiku 4.5）');
                      } catch (e) { setMessage('❌ Claude API接続失敗: ' + e.message); }
                      setLoading(false);
                    }} disabled={loading} className="flex-1 bg-blue-500 text-white rounded py-1 text-sm hover:bg-blue-600 disabled:opacity-50">テスト</button>
                  </div>
                </div>
              </div>
              <DropZone
                title="📷 PC写真を読込"
                icon="image"
                color="blue"
                accept="image/*"
                multiple={true}
                directory={true}
                onFiles={handleSorterFiles}
                hint="フォルダ分け済み → 自動処理 ／ 未整理 → 手動振り分け"
              />
            </div>
            {/* 商品データがある場合、Step2に戻れるボタン */}
            {products.length > 0 && (
              <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded flex items-center justify-between">
                <span className="text-yellow-800">📦 編集中の商品データがあります（{products.length}件）</span>
                <button onClick={() => setStep(2)} className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600">
                  Step2に戻る →
                </button>
              </div>
            )}
          </div>
        )}

        {/* Step 2: 画像編集 */}
        {step === 2 && cur && (() => {
          const activeImages = cur.images.filter(img => !img.excluded);
          const excludedImages = cur.images.filter(img => img.excluded);
          const hasBcFlag = activeImages.some(img => img.isBarcode);
          // isBarcodeフラグ付き画像の数を除外、フラグなしなら最後の1枚をBC扱い
          const bcCount = hasBcFlag ? activeImages.filter(img => img.isBarcode).length : (activeImages.length > 0 ? 1 : 0);
          const uploadCount = activeImages.length - bcCount;
          
          // 履歴に保存する関数
          const saveHistory = () => {
            setImageHistory(prev => [...prev, JSON.parse(JSON.stringify(cur.images))]);
          };
          
          // Undo関数
          const undoMerge = () => {
            if (imageHistory.length === 0) return;
            const np = [...products];
            np[currentIdx].images = imageHistory[imageHistory.length - 1];
            setProducts(np);
            setImageHistory(prev => prev.slice(0, -1));
          };
          
          return (
          <div className="bg-white rounded shadow">
            {/* ヘッダー行1: ナビ + チェックボックス */}
            <div className="border-b p-3 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="flex items-center gap-1 bg-gray-100 rounded-lg p-1">
                  <button onClick={() => { setCurrentIdx(Math.max(0, currentIdx-1)); setImageHistory([]); setSelectedImages([]); }} disabled={currentIdx===0} className="p-1.5 rounded-lg hover:bg-white disabled:opacity-30 transition"><Icon name="left"/></button>
                  <span className="font-bold px-2 min-w-[60px] text-center">{currentIdx+1}/{products.length}</span>
                  <button onClick={() => { setCurrentIdx(Math.min(products.length-1, currentIdx+1)); setImageHistory([]); setSelectedImages([]); }} disabled={currentIdx===products.length-1} className="p-1.5 rounded-lg hover:bg-white disabled:opacity-30 transition"><Icon name="right"/></button>
                </div>
                <span className="text-gray-600 font-medium">{cur.folder}</span>
                {cur.barcode && <span className="bg-green-100 text-green-700 px-2 py-0.5 rounded text-sm font-mono">{cur.barcode}</span>}
              </div>
              <div className="flex items-center gap-3">
                <label className="flex items-center gap-1.5 cursor-pointer bg-blue-50 px-3 py-1.5 rounded-lg hover:bg-blue-100 transition">
                  <input 
                    type="checkbox" 
                    checked={cur.hasOffice || false}
                    onChange={e => { const np = [...products]; np[currentIdx].hasOffice = e.target.checked; setProducts(np); }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-medium text-blue-700">📦 OFFICE</span>
                </label>
                <label className="flex items-center gap-1.5 cursor-pointer bg-red-50 px-3 py-1.5 rounded-lg hover:bg-red-100 transition">
                  <input 
                    type="checkbox" 
                    checked={cur.isJunk || false}
                    onChange={e => { const np = [...products]; np[currentIdx].isJunk = e.target.checked; setProducts(np); }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-medium text-red-600">⚠️ ジャンク</span>
                </label>
              </div>
            </div>
            {/* ヘッダー行2: 画像枚数 + ツールボタン */}
            <div className="border-b px-4 py-2 flex items-center justify-between bg-white">
              <div className="flex items-center gap-3">
                <span className={`text-sm font-bold px-2 py-1 rounded ${uploadCount <= 10 ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                  📸 出品: {uploadCount}枚 {uploadCount > 10 && '⚠️'}
                </span>
              </div>
              <div className="flex items-center gap-2">
                <button onClick={doOcrAll} disabled={loading} className="px-3 py-1.5 bg-purple-500 text-white rounded text-sm hover:bg-purple-600 disabled:opacity-50 font-medium">
                  {loading ? '⏳ 処理中...' : '🔍 全OCR'}
                </button>
                <button onClick={aiReprocess} disabled={loading} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 disabled:opacity-50 font-medium">
                  🔄 AI再処理
                </button>
                <button onClick={() => resortByCategory()} disabled={loading} className="px-3 py-1.5 bg-orange-500 text-white rounded text-sm hover:bg-orange-600 disabled:opacity-50 font-medium" title="カテゴリバッジを手動で変更してからこれを押すと再結合">
                  🔀 再並替
                </button>
                <button onClick={() => {
                  const p = products[currentIdx];
                  if (!p) return;
                  const mergedImgs = p.images.filter(img => !img.excluded && img.id?.startsWith('merged_'));
                  if (mergedImgs.length === 0) { setMessage('結合画像がありません'); return; }
                  setDecomposeTarget({ mergedImgs });
                }} className="px-3 py-1.5 bg-purple-500 text-white rounded text-sm hover:bg-purple-600 font-medium" title="結合画像を選んで分解">
                  🔓 分解
                </button>
                {bcReviewReady && (
                  <button onClick={() => { setBcReviewIdx(0); setShowBcReview(true); }} className="px-3 py-1.5 bg-yellow-500 text-white rounded text-sm hover:bg-yellow-600 font-medium">
                    🔍 BC検査
                  </button>
                )}
              </div>
            </div>
            <div className="border-b px-4 py-2 flex items-center gap-3 bg-gray-50">
              <span className="text-sm text-gray-500">状態:</span>
              <select
                value={cur.condition || 3}
                onChange={e => { const np = [...products]; np[currentIdx].condition = parseInt(e.target.value); setProducts(np); }}
                className="border rounded px-2 py-1 text-sm"
              >
                {Object.entries(CONDITION_LABELS).map(([k, v]) => (
                  <option key={k} value={k}>{v}</option>
                ))}
              </select>
              <span className="text-sm text-gray-500 ml-2">メモ:</span>
              <input
                type="text"
                value={cur.conditionNotes || ''}
                onChange={e => { const np = [...products]; np[currentIdx].conditionNotes = e.target.value; setProducts(np); }}
                placeholder="例: 画面ムラあり、タッチパッド塗装はげ"
                className="flex-1 border rounded px-2 py-1 text-sm"
              />
            </div>

            <div className="flex" style={{height: 'calc(100vh - 200px)'}}>
              {/* 商品リスト */}
              <div className="w-48 border-r bg-gray-50 p-2 overflow-y-auto">
                <div className="text-xs text-gray-400 mb-1 px-1">📂 商品一覧 ({products.length})</div>
                {products.map((p, i) => {
                  const pActive = p.images.filter(img => !img.excluded);
                  const pHasBc = pActive.some(img => img.isBarcode);
                  const pBcCount = pHasBc ? pActive.filter(img => img.isBarcode).length : (pActive.length > 0 ? 1 : 0);
                  const pUpload = pActive.length - pBcCount;
                  const firstImg = pActive.find(img => !img.isBarcode);
                  const isCurrent = i === currentIdx;
                  const isMoveTarget = selectedImages.length > 0 && !isCurrent;
                  return (
                  <div
                    key={p.id}
                    onClick={() => {
                      if (isMoveTarget) {
                        // confirm不使用 - 直接移動（functional updateで確実に）
                        const count = selectedImages.length;
                        setProducts(prev => {
                          const np = prev.map(x => ({...x, images: [...x.images]}));
                          const movedImgs = selectedImages.map(si => np[currentIdx].images[si]).filter(Boolean);
                          if (movedImgs.length === 0) return prev;
                          np[currentIdx].images = np[currentIdx].images.filter((_, idx) => !selectedImages.includes(idx));
                          const targetImgs = np[i].images;
                          const lastActive = targetImgs.filter(img => !img.excluded);
                          const insertAt = lastActive.length > 0 ? targetImgs.indexOf(lastActive[lastActive.length - 1]) : targetImgs.length;
                          targetImgs.splice(insertAt, 0, ...movedImgs);
                          return np;
                        });
                        setSelectedImages([]);
                        setMessage(`${count}枚をPC ${i + 1}へ移動`);
                      } else {
                        setCurrentIdx(i); setSelectedImages([]); setImageHistory([]);
                      }
                    }}
                    className={`w-full flex items-center gap-2 px-2 py-1.5 rounded text-sm mb-0.5 cursor-pointer transition-all ${isCurrent ? 'bg-blue-500 text-white shadow' : isMoveTarget ? 'hover:bg-orange-100 border border-dashed border-orange-400 bg-orange-50' : 'hover:bg-gray-200'}`}
                  >
                    <div className="w-8 h-8 flex-shrink-0 rounded overflow-hidden bg-gray-200">
                      {firstImg && <img src={firstImg.thumbUrl || firstImg.dataUrl} className="w-full h-full object-cover"/>}
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="truncate text-xs font-medium">{p.folder}</div>
                      <div className={`text-xs flex items-center gap-1 ${isCurrent ? 'text-blue-200' : 'text-gray-400'}`}>
                        {p.barcode ? <span className="text-green-500">✓</span> : <span className="text-red-400">✗</span>}
                        <span className={pUpload > 10 ? (isCurrent ? 'text-yellow-200' : 'text-red-500 font-bold') : ''}>{pUpload}枚</span>
                      </div>
                    </div>
                    {isMoveTarget && <span className="text-orange-500 text-sm font-bold">⇦</span>}
                  </div>
                  );
                })}
              </div>

              {/* メイン編集エリア（左右分割） */}
              <div className="flex-1 flex min-w-0">
              {/* 左半分: サムネイル＋ツール */}
              <div className="w-1/2 p-3 overflow-y-auto border-r">
                {/* ツールバー（常時表示、固定高） */}
                <div className="mb-2 p-2 bg-gray-50 border rounded flex items-center gap-2 flex-wrap min-h-[44px]">
                  {selectedImages.length > 0 ? (<>
                    <span className="text-sm font-bold text-blue-700">📌 {selectedImages.length}枚選択中</span>
                    <span className="text-gray-300">|</span>
                    {/* 結合 */}
                    {selectedImages.length >= 2 && (
                      <button onClick={async () => {
                        saveHistory();
                        const selected = selectedImages.map(idx => cur.images[idx]).filter(Boolean);
                        if (selected.length < 2) return;
                        const { dataUrl, filename } = await mergeImages(selected, 2);
                        const np = [...products];
                        const newImg = { id: `merged_${Date.now()}`, filename, dataUrl, excluded: false };
                        const firstIdx = Math.min(...selectedImages);
                        const newImages = cur.images.map((img, i) => selectedImages.includes(i) ? {...img, excluded: true} : img);
                        newImages.splice(firstIdx, 0, newImg);
                        np[currentIdx].images = newImages;
                        setProducts(np);
                        setSelectedImages([]);
                      }} className="px-3 py-1 bg-blue-600 text-white rounded text-sm font-bold hover:bg-blue-700" title="選択した画像を1枚に結合">
                        🔗 結合
                      </button>
                    )}
                    {/* 除外 */}
                    <button onClick={() => {
                      saveHistory();
                      const np = [...products];
                      selectedImages.forEach(idx => { if (np[currentIdx].images[idx]) np[currentIdx].images[idx].excluded = true; });
                      setProducts(np);
                      setSelectedImages([]);
                    }} className="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600" title="選択した画像を除外">🗑 除外</button>
                    <span className="text-gray-300">|</span>
                    {/* 移動先セレクタ */}
                    <span className="text-xs text-gray-500">📤 移動先:</span>
                    <select
                      value=""
                      onChange={e => {
                        const targetIdx = parseInt(e.target.value);
                        if (!isNaN(targetIdx)) moveSelectedToProduct(targetIdx);
                      }}
                      className="border rounded px-2 py-1 text-sm bg-orange-50 border-orange-300 cursor-pointer max-w-[180px]"
                    >
                      <option value="">-- 選択 --</option>
                      {products.map((p, i) => i !== currentIdx && (
                        <option key={p.id} value={i}>
                          {i+1}. {p.folder} [{p.images.filter(img=>!img.excluded).length}枚]
                        </option>
                      ))}
                      <option value="__new__" disabled>──────</option>
                    </select>
                    {/* 新規商品として切り出し */}
                    <button onClick={() => {
                      const np = [...products];
                      const movedImgs = selectedImages.map(i => ({...np[currentIdx].images[i]})).filter(Boolean);
                      np[currentIdx] = { ...np[currentIdx], images: np[currentIdx].images.filter((_, i) => !selectedImages.includes(i)) };
                      const newId = `new_${Date.now()}`;
                      np.splice(currentIdx + 1, 0, { id: newId, folder: `新規_${products.length + 1}`, images: movedImgs, barcode: null, hasOffice: false, isJunk: false, condition: 3, conditionNotes: '中古品なりの使用感はありますが、美品となります。' });
                      setProducts(np);
                      setSelectedImages([]);
                      setCurrentIdx(currentIdx + 1);
                      setMessage(`📦 ${movedImgs.length}枚で新規商品を作成`);
                    }} className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700" title="選択した画像を新しい商品として切り出し">
                      📦 新規商品に
                    </button>
                    {/* 分割 */}
                    {selectedImages.length >= 1 && (
                      <button onClick={() => {
                        const splitAt = Math.min(...selectedImages);
                        if (splitAt <= 0) return;
                        const np = [...products];
                        const orig = np[currentIdx];
                        const imgs1 = orig.images.slice(0, splitAt);
                        const imgs2 = orig.images.slice(splitAt);
                        np[currentIdx] = { ...orig, images: imgs1 };
                        const newProd = { id: `${orig.folder}_B`, folder: `${orig.folder}_B`, images: imgs2, barcode: null, hasOffice: false, isJunk: false, condition: orig.condition };
                        np.splice(currentIdx + 1, 0, newProd);
                        setProducts(np);
                        setSelectedImages([]);
                        setMessage(`✂ ${splitAt}枚目で分割しました`);
                      }} className="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600" title="選択位置で商品を2つに分割">✂ 分割</button>
                    )}
                    <span className="text-gray-300">|</span>
                    <button onClick={() => setSelectedImages([])} className="px-3 py-1 bg-gray-300 text-gray-700 rounded text-sm hover:bg-gray-400">✕ 解除</button>
                  </>) : (<>
                    <span className="text-xs text-gray-400">💡 クリック:選択 / ダブルクリック:拡大 / ホバー:◀▶並替 / 左下バッジ:カテゴリ変更→🔀再並替</span>
                    <button onClick={() => {
                      const allIdx = cur.images.map((img, i) => (!img.excluded && !(hasBcFlag ? img.isBarcode : activeImages.indexOf(img) === activeImages.length - 1)) ? i : null).filter(x => x !== null);
                      setSelectedImages(allIdx);
                    }} className="px-2 py-1 bg-blue-100 text-blue-600 rounded text-xs hover:bg-blue-200 font-medium">☑ 全選択</button>
                    {imageHistory.length > 0 && (
                      <button onClick={undoMerge} className="px-2 py-1 bg-yellow-500 text-white rounded text-xs hover:bg-yellow-600">↩ 戻す ({imageHistory.length})</button>
                    )}
                  </>)}
                </div>
                {/* 出品画像 */}
                <div className="mb-4">
                  <div className="flex flex-wrap gap-1.5 items-start pb-4">
                    {cur.images.map((img, i) => {
                      if (img.excluded) return null;
                      const activeIdx = activeImages.indexOf(img);
                      const isBarcode = hasBcFlag ? !!img.isBarcode : (activeIdx === activeImages.length - 1);
                      const isSelected = selectedImages.includes(i);
                      const displayNum = activeIdx + 1;
                      const catColors = { main: 'bg-blue-500', keyboard: 'bg-cyan-500', side: 'bg-purple-500', info: 'bg-green-600', spec: 'bg-yellow-600', other: 'bg-gray-500' };
                      const catLabels = { main: 'MAIN', keyboard: 'KEY', side: 'SIDE', info: 'INFO', spec: 'SPEC', other: '?' };
                      const cats = ['main', 'info', 'spec', 'keyboard', 'side', 'other'];
                      return (
                        <div key={img.id} className="relative group"
                          onMouseEnter={() => setHoverImg(img.dataUrl)}
                          onMouseLeave={() => setHoverImg(null)}
                        >
                          <div
                            onClick={() => {
                              if (isBarcode) { setZoomImage({dataUrl: img.dataUrl, imgIdx: i}); return; }
                              if (isSelected) setSelectedImages(selectedImages.filter(x => x !== i));
                              else setSelectedImages([...selectedImages, i]);
                            }}
                            onDoubleClick={() => setZoomImage({dataUrl: img.dataUrl, imgIdx: i})}
                            className={`relative cursor-pointer transition-all ${isSelected ? 'ring-4 ring-blue-500 scale-105' : 'hover:ring-2 hover:ring-gray-400'} ${isBarcode ? 'ring-2 ring-red-400' : ''}`}
                          >
                            <img src={img.thumbUrl || img.dataUrl} className={`w-32 h-32 object-cover rounded border-2 ${isBarcode ? 'border-red-400' : isSelected ? 'border-blue-400' : 'border-gray-200'}`}/>
                            {/* 番号バッジ 左上 */}
                            <span className={`absolute top-1 left-1 text-xs px-1.5 py-0.5 rounded font-bold ${isBarcode ? 'bg-red-500 text-white' : 'bg-black/60 text-white'}`}>{isBarcode ? 'BC' : displayNum}</span>
                            {/* 選択番号 右上 */}
                            {isSelected && <span className="absolute top-1 right-1 bg-blue-500 text-white text-xs w-5 h-5 flex items-center justify-center rounded-full font-bold">{selectedImages.indexOf(i) + 1}</span>}
                            {/* カテゴリバッジ 左下 */}
                            {img.category && !isBarcode && (
                              <button
                                onClick={e => { e.stopPropagation(); const np = [...products]; const ci = cats.indexOf(img.category); np[currentIdx].images[i].category = cats[(ci + 1) % cats.length]; setProducts(np); }}
                                className={`absolute bottom-1 left-1 text-white text-xs font-bold px-1.5 py-0.5 rounded shadow-sm ${catColors[img.category] || 'bg-gray-500'}`}
                                title={`${img.category}（クリック→変更）`}
                              >{catLabels[img.category] || '?'}</button>
                            )}
                            {/* 除外ボタン 右下 */}
                            <button onClick={e => { e.stopPropagation(); toggleExclude(i); }} className="absolute bottom-1 right-1 bg-white/80 rounded-full p-0.5 opacity-0 group-hover:opacity-100 transition-opacity" title="除外">
                              <Icon name="eyeOff" className="w-3 h-3"/>
                            </button>
                          </div>
                          {/* ◀▶ 並替ボタン（ホバー表示） */}
                          {!isBarcode && (
                            <div className="absolute -bottom-4 left-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-0.5 z-20">
                              {activeIdx > 0 && (
                                <button onClick={e => { e.stopPropagation(); moveImage(i, cur.images.indexOf(activeImages[activeIdx - 1])); }} className="bg-gray-700 text-white text-xs px-1.5 py-0.5 rounded-l hover:bg-gray-900" title="左へ">◀</button>
                              )}
                              {activeIdx < activeImages.length - (hasBcFlag ? 2 : 2) && (
                                <button onClick={e => { e.stopPropagation(); moveImage(i, cur.images.indexOf(activeImages[activeIdx + 1])); }} className="bg-gray-700 text-white text-xs px-1.5 py-0.5 rounded-r hover:bg-gray-900" title="右へ">▶</button>
                              )}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>

                {/* 除外画像 */}
                {excludedImages.length > 0 && (
                <div className="mb-4">
                  <h4 className="font-bold text-sm mb-2 text-gray-400">🚫 除外済み（{excludedImages.length}枚）- クリックで復元</h4>
                  <div className="flex flex-wrap gap-2">
                    {cur.images.map((img, i) => {
                      if (!img.excluded) return null;
                      return (
                      <div key={img.id} className="relative opacity-50 cursor-pointer hover:opacity-80" onClick={() => toggleExclude(i)}>
                        <img src={img.thumbUrl || img.dataUrl} className="w-20 h-20 object-cover rounded border-2 border-gray-300 grayscale"/>
                        <button onClick={(e) => { e.stopPropagation(); toggleExclude(i); }} className="absolute top-1 right-1 bg-white rounded-full p-0.5">
                          <Icon name="eye" className="w-3 h-3"/>
                        </button>
                      </div>
                      );
                    })}
                  </div>
                </div>
                )}
              </div>
              {/* 右半分: 大プレビュー */}
              <div className="w-1/2 bg-gray-900 flex items-center justify-center p-2">
                {hoverImg ? (
                  <img src={hoverImg} className="max-w-full max-h-full object-contain rounded" />
                ) : (
                  <div className="text-gray-600 text-sm text-center">
                    <div className="text-4xl mb-2">🖼</div>
                    画像にカーソルを合わせると<br/>ここに大きく表示
                  </div>
                )}
              </div>
              </div>

              {/* 右パネル */}
              <div className="w-56 border-l p-4 bg-gray-50 overflow-y-auto">
                <div className="text-xs text-gray-400 mb-2 font-bold uppercase">📋 商品情報</div>
                <label className="block text-sm font-medium mb-1">🔢 バーコード</label>
                <div className="flex gap-1 mb-3">
                  <input type="text" value={cur.barcode || ''} onChange={e => { const np = [...products]; np[currentIdx].barcode = e.target.value; setProducts(np); }} className="flex-1 border rounded px-2 py-1 text-sm font-mono"/>
                  <button onClick={() => doOcr(currentIdx)} disabled={loading} className="px-2 py-1 bg-blue-500 text-white rounded text-sm" title="バーコード再読取"><Icon name="scan" className="w-4 h-4"/></button>
                </div>
                <label className="block text-sm font-medium mb-1">🔋 充放電回数</label>
                <input type="text" value={cur.cycle_count || ''} onChange={e => { const np = [...products]; np[currentIdx].cycle_count = e.target.value; setProducts(np); }} className="w-full border rounded px-2 py-1 text-sm mb-3" placeholder="例: 150"/>
                <label className="block text-sm font-medium mb-1">🔋 バッテリー(%)</label>
                <input type="text" value={cur.battery_health || ''} onChange={e => { const np = [...products]; np[currentIdx].battery_health = e.target.value; setProducts(np); }} className="w-full border rounded px-2 py-1 text-sm mb-3" placeholder="例: 85"/>
                
                <hr className="my-3"/>
                <div className="text-xs text-gray-400 mb-2 font-bold uppercase">🔧 商品操作</div>
                {currentIdx > 0 && (
                  <button onClick={() => {
                    if (!confirm(`前のPC（${products[currentIdx-1].folder}）と結合しますか？`)) return;
                    const np = [...products];
                    const prev = np[currentIdx - 1];
                    const curr = np[currentIdx];
                    prev.images = [...prev.images, ...curr.images];
                    np.splice(currentIdx, 1);
                    setProducts(np);
                    setCurrentIdx(currentIdx - 1);
                    setSelectedImages([]);
                    setMessage(`🔗 ${prev.folder}と結合しました`);
                  }} className="w-full mb-1 px-2 py-1.5 bg-purple-100 text-purple-700 rounded text-xs hover:bg-purple-200 font-medium">🔗 前PCと結合</button>
                )}
                {currentIdx < products.length - 1 && (
                  <button onClick={() => {
                    if (!confirm(`次のPC（${products[currentIdx+1].folder}）と結合しますか？`)) return;
                    const np = [...products];
                    const curr = np[currentIdx];
                    const next = np[currentIdx + 1];
                    curr.images = [...curr.images, ...next.images];
                    np.splice(currentIdx + 1, 1);
                    setProducts(np);
                    setSelectedImages([]);
                    setMessage(`🔗 ${next.folder}と結合しました`);
                  }} className="w-full mb-1 px-2 py-1.5 bg-purple-100 text-purple-700 rounded text-xs hover:bg-purple-200 font-medium">🔗 次PCと結合</button>
                )}
                {/* フォルダ名変更 */}
                <div className="mt-2 mb-1">
                  <label className="block text-xs text-gray-500 mb-1">📁 フォルダ名</label>
                  <input type="text" value={cur.folder || ''} onChange={e => { const np = [...products]; np[currentIdx].folder = e.target.value; setProducts(np); }} className="w-full border rounded px-2 py-1 text-xs"/>
                </div>
                <hr className="my-2"/>
                <button onClick={() => {
                  if (!confirm(`${cur.folder} を削除しますか？`)) return;
                  const np = products.filter((_, i) => i !== currentIdx);
                  setProducts(np);
                  setCurrentIdx(Math.min(currentIdx, np.length - 1));
                  setSelectedImages([]);
                }} className="w-full px-2 py-1.5 bg-red-100 text-red-600 rounded text-xs hover:bg-red-200 font-medium">🗑 この商品を削除</button>
              </div>
            </div>

            <div className="border-t p-4 flex justify-between">
              <button onClick={() => { if (confirm('Step1に戻りますか？画像の振り分けやAI処理結果は保持されます。')) setStep(1); }} className="px-4 py-2 border rounded hover:bg-gray-50">戻る</button>
              <button onClick={processProducts} className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">次へ</button>
            </div>
          </div>
          );
        })()}

        {/* Step 3: 価格確認 */}
        {step === 3 && (
          <div className="bg-white rounded shadow p-4">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-bold">価格確認</h2>
              <span className="text-xs text-gray-500">💡 価格Excel未設定時は仕入原価から自動計算（利益20%+手数料10%+送料¥1,500+梱包¥1,000）</span>
            </div>
            <table className="w-full text-sm">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-3 py-2 text-left">フォルダ</th>
                  <th className="px-3 py-2 text-left">BC（クリックで編集）</th>
                  <th className="px-3 py-2 text-left">商品</th>
                  <th className="px-3 py-2 text-right">仕入</th>
                  <th className="px-3 py-2 text-right">販売価格</th>
                  <th className="px-3 py-2">状態</th>
                </tr>
              </thead>
              <tbody>
                {products.map((p, i) => {
                  const activeImgs = p.images.filter(img => !img.excluded);
                  const bcImg = activeImgs.length > 0 ? activeImgs[activeImgs.length - 1] : null;
                  const hasPrice = p.price && p.price > 0;
                  const profit = hasPrice && p.purchaseCost ? p.price - Math.round(p.price * 0.1) - 1500 - 1000 - p.purchaseCost : null;
                  const profitRate = profit && p.price ? Math.round(profit / p.price * 100) : null;
                  const rowBg = p.status === 'no_data' ? 'bg-red-50' : (p.status === 'no_barcode' ? 'bg-orange-50' : (!hasPrice ? 'bg-yellow-50' : (i % 2 ? 'bg-gray-50' : '')));
                  const isUsable = p.status === 'ok' || p.status === 'ocr_specs' || p.status === 'no_barcode';
                  return (
                  <React.Fragment key={p.id}>
                  <tr className={`${rowBg} cursor-pointer hover:bg-blue-50`} onClick={() => setExpandedSpecRow(expandedSpecRow === i ? null : i)}>
                    <td className="px-3 py-2">{p.folder}</td>
                    <td className="px-3 py-2" onClick={e => e.stopPropagation()}>
                      <div className="flex items-center gap-2">
                        {bcImg && (
                          <img 
                            src={bcImg.dataUrl} 
                            className="w-12 h-12 object-cover rounded cursor-pointer hover:opacity-80 border"
                            onClick={() => { setCurrentIdx(i); setZoomImage({dataUrl: bcImg.dataUrl, imgIdx: null}); }}
                            title="クリックで拡大・編集"
                          />
                        )}
                        <span className={`font-mono ${p.barcode ? '' : 'text-gray-400'}`}>{p.barcode || '未入力'}</span>
                      </div>
                    </td>
                    <td className="px-3 py-2">
                      <div className="flex items-center gap-1">
                        <span>{p.specs?.product_name?.toLowerCase().startsWith((p.specs?.maker || '').toLowerCase()) ? p.specs?.product_name : `${p.specs?.maker || ''} ${p.specs?.product_name || ''}`.trim()}</span>
                        <span className="text-gray-400 text-xs">{expandedSpecRow === i ? '▲' : '▼'}</span>
                      </div>
                    </td>
                    <td className="px-3 py-2 text-right text-gray-500">
                      {p.purchaseCost ? `¥${p.purchaseCost.toLocaleString()}` : '-'}
                    </td>
                    <td className="px-3 py-2 text-right">
                      <div className="flex items-center justify-end gap-1">
                        <input type="number" value={p.price || ''} onChange={e => { const np = [...products]; np[i].price = parseInt(e.target.value) || null; setProducts(np); }} placeholder="要設定" className={`w-24 border rounded px-2 py-1 text-right ${!hasPrice ? 'border-yellow-400 bg-yellow-50' : ''}`}/>
                      </div>
                      {profit !== null && (
                        <div className={`text-xs mt-0.5 ${profit > 0 ? 'text-green-600' : 'text-red-500'}`}>
                          利益 ¥{profit.toLocaleString()} ({profitRate}%)
                        </div>
                      )}
                    </td>
                    <td className="px-3 py-2 text-center">
                      {p.status === 'no_data' ? (
                        <Icon name="x" className="w-5 h-5 text-red-400 mx-auto" title="CSV未マッチ"/>
                      ) : p.status === 'ocr_specs' ? (
                        <span className="text-blue-500 font-bold" title="画像からスペック取得済み">📷</span>
                      ) : p.status === 'no_barcode' && !p.specs?.cpu ? (
                        <span className="text-orange-400 font-bold" title="BC無し・スペック未取得">📝</span>
                      ) : hasPrice ? (
                        <Icon name="check" className="w-5 h-5 text-green-500 mx-auto" title="OK"/>
                      ) : (
                        <span className="text-yellow-500 font-bold" title="価格未設定">⚠</span>
                      )}
                    </td>
                  </tr>
                  {expandedSpecRow === i && (
                  <tr className="bg-blue-50 border-b-2 border-blue-200">
                    <td colSpan="6" className="px-4 py-3">
                      <div className="grid grid-cols-6 gap-2 text-xs">
                        {[
                          ['maker', 'メーカー'],
                          ['product_name', '型番'],
                          ['cpu', 'CPU'],
                          ['memory', 'メモリ'],
                          ['storage', 'ストレージ'],
                          ['gpu', 'GPU'],
                        ].map(([field, label]) => (
                          <div key={field}>
                            <label className="block text-gray-500 mb-0.5">{label}</label>
                            <input
                              type="text"
                              value={(p.specs && p.specs[field]) || ''}
                              onChange={e => {
                                const np = [...products];
                                if (!np[i].specs) np[i].specs = {};
                                np[i].specs[field] = e.target.value;
                                setProducts(np);
                              }}
                              onClick={e => e.stopPropagation()}
                              className="w-full border rounded px-2 py-1 text-sm bg-white"
                            />
                          </div>
                        ))}
                      </div>
                      <div className="grid grid-cols-6 gap-2 text-xs mt-2">
                        <div>
                          <label className="block text-gray-500 mb-0.5">画面</label>
                          <input type="text" value={p.specs?.display || ''} onChange={e => { const np = [...products]; if (!np[i].specs) np[i].specs = {}; np[i].specs.display = e.target.value; setProducts(np); }} onClick={e => e.stopPropagation()} className="w-full border rounded px-2 py-1 text-sm bg-white"/>
                        </div>
                        <div>
                          <label className="block text-gray-500 mb-0.5">OS</label>
                          <input type="text" value={p.specs?.os || ''} onChange={e => { const np = [...products]; if (!np[i].specs) np[i].specs = {}; np[i].specs.os = e.target.value; setProducts(np); }} onClick={e => e.stopPropagation()} className="w-full border rounded px-2 py-1 text-sm bg-white"/>
                        </div>
                        <div>
                          <label className="block text-gray-500 mb-0.5">充放電回数</label>
                          <input type="text" value={p.cycle_count || ''} onChange={e => { const np = [...products]; np[i].cycle_count = e.target.value; setProducts(np); }} onClick={e => e.stopPropagation()} className="w-full border rounded px-2 py-1 text-sm bg-white" placeholder="例: 150"/>
                        </div>
                        <div>
                          <label className="block text-gray-500 mb-0.5">バッテリー(%)</label>
                          <input type="text" value={p.battery_health || ''} onChange={e => { const np = [...products]; np[i].battery_health = e.target.value; setProducts(np); }} onClick={e => e.stopPropagation()} className="w-full border rounded px-2 py-1 text-sm bg-white" placeholder="例: 85"/>
                        </div>
                        <div className="col-span-2 flex items-end">
                          <span className="text-gray-400 text-xs">📌 CSV読取値 → 手動訂正可。タイトル・説明文に反映されます</span>
                        </div>
                      </div>
                    </td>
                  </tr>
                  )}
                  </React.Fragment>
                  );
                })}
              </tbody>
            </table>
            <div className="flex justify-between mt-4">
              <button onClick={() => setStep(2)} className="px-4 py-2 border rounded">戻る</button>
              <div className="flex gap-2">
                <button onClick={rematchProducts} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">再照合</button>
                <button onClick={goToPreview} disabled={loading} className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                  {loading ? '処理中...' : 'プレビュー →'}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Step 4: プレビュー編集 */}
        {step === 4 && (() => {
          const okProducts = products;
          const cur = okProducts[currentIdx] || null;
          const curProductIdx = currentIdx;
          const activeImgs = (() => {
            if (!cur) return [];
            const all = cur.images.filter(img => !img.excluded);
            const hasBc = all.some(img => img.isBarcode);
            return hasBc ? all.filter(img => !img.isBarcode) : all.slice(0, -1);
          })();
          
          // 画像入れ替え関数
          const swapImages = (fromDisplayIdx, toDisplayIdx) => {
            if (curProductIdx < 0 || fromDisplayIdx === toDisplayIdx) return;
            const np = [...products];
            const allImgs = [...np[curProductIdx].images];
            // activeImgsと同じロジックで実indexを取得
            const active = allImgs.filter(img => !img.excluded);
            const hasBc = active.some(img => img.isBarcode);
            const displayed = hasBc ? active.filter(img => !img.isBarcode) : active.slice(0, -1);
            const realFrom = allImgs.indexOf(displayed[fromDisplayIdx]);
            const realTo = allImgs.indexOf(displayed[toDisplayIdx]);
            if (realFrom < 0 || realTo < 0) return;
            [allImgs[realFrom], allImgs[realTo]] = [allImgs[realTo], allImgs[realFrom]];
            np[curProductIdx] = { ...np[curProductIdx], images: allImgs };
            setProducts(np);
          };
          
          return (
          <div className="bg-white rounded shadow">
            <div className="p-4 border-b flex items-center justify-between">
              <h2 className="text-lg font-bold">プレビュー編集</h2>
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-600">{okProducts.length}商品</span>
                <button onClick={pickOutputFolder} className="px-3 py-1 border rounded text-sm hover:bg-gray-50">
                  📁 {outputDirHandle ? outputDirHandle.name : '保存先'}
                </button>
                <button onClick={saveAllImages} className="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                  💾 全画像保存
                </button>
                <button onClick={() => setStep(3)} className="px-3 py-1 border rounded text-sm">戻る</button>
                <button onClick={generateCsv} disabled={loading} className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50">
                  {loading ? '処理中...' : 'CSV生成'}
                </button>
              </div>
            </div>
            
            <div className="flex" style={{height: 'calc(100vh - 220px)'}}>
              {/* 商品リスト */}
              <div className="w-48 border-r bg-gray-50 overflow-y-auto">
                {okProducts.map((p, i) => (
                  <button 
                    key={p.id} 
                    onClick={() => setCurrentIdx(i)} 
                    className={`w-full text-left px-3 py-2 text-sm border-b ${i === currentIdx ? 'bg-blue-500 text-white' : 'hover:bg-gray-100'}`}
                  >
                    <div className="font-medium truncate">{p.specs?.maker || 'Unknown'}</div>
                    <div className="text-xs opacity-75 truncate">{p.barcode}</div>
                  </button>
                ))}
              </div>
              
              {/* 編集エリア */}
              {cur && (
                <div className="flex-1 overflow-y-auto p-4">
                  {/* 画像プレビュー（入れ替え・拡大可能） */}
                  <div className="mb-4">
                    <div className="flex items-center gap-2 mb-2">
                      <span className="text-sm font-medium">📷 出品画像</span>
                      <span className="text-xs text-gray-500">ドラッグで入れ替え / クリックで拡大</span>
                    </div>
                    <div className="flex gap-2 overflow-x-auto pb-2">
                      {activeImgs.slice(0, 10).map((img, i) => (
                        <div 
                          key={i}
                          draggable
                          onDragStart={e => e.dataTransfer.setData('text/plain', i.toString())}
                          onDragOver={e => e.preventDefault()}
                          onDrop={e => {
                            e.preventDefault();
                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                            if (fromIdx !== i) swapImages(fromIdx, i);
                          }}
                          className="relative flex-shrink-0 cursor-move"
                        >
                          <img 
                            src={img.dataUrl} 
                            className="w-20 h-20 object-cover rounded border hover:border-blue-400"
                            onClick={() => setZoomImage({dataUrl: img.dataUrl, imgIdx: null})}
                          />
                          <span className="absolute bottom-0 left-0 bg-black/60 text-white text-xs px-1 rounded-tr">{i+1}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                  
                  {/* スペック簡単編集 */}
                  <div className="mb-4 p-3 bg-gray-50 rounded border">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-sm font-medium">📝 スペック編集</span>
                      <button onClick={() => {
                        const np = [...products];
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) {
                          np[idx].title = makeTitle(np[idx]);
                          np[idx].description = makeDescription(np[idx], noticeText);
                        }
                        setProducts(np);
                        setMessage('タイトル・説明文を再生成しました');
                      }} className="px-2 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600">🔄 タイトル・説明を再生成</button>
                    </div>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                      {[
                        ['maker', 'メーカー'], ['product_name', '型番'], ['cpu', 'CPU'], ['memory', 'メモリ'],
                        ['storage', 'ストレージ'], ['gpu', 'GPU'], ['display', '画面'], ['model', 'モデル名']
                      ].map(([key, label]) => (
                        <div key={key}>
                          <label className="text-xs text-gray-500">{label}</label>
                          <input
                            type="text"
                            value={(cur.specs || {})[key] || ''}
                            onChange={e => {
                              const np = [...products];
                              const idx = np.findIndex(p => p.id === cur.id);
                              if (idx >= 0) {
                                if (!np[idx].specs) np[idx].specs = {};
                                np[idx].specs[key] = e.target.value;
                              }
                              setProducts(np);
                            }}
                            className="w-full border rounded px-2 py-1 text-xs"
                            placeholder={label}
                          />
                        </div>
                      ))}
                    </div>
                    <div className="grid grid-cols-3 gap-2 mt-2">
                      <div>
                        <label className="text-xs text-gray-500">状態</label>
                        <select
                          value={cur.condition || 3}
                          onChange={e => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx >= 0) np[idx].condition = parseInt(e.target.value);
                            setProducts(np);
                          }}
                          className="w-full border rounded px-2 py-1 text-xs"
                        >
                          {Object.entries(CONDITION_LABELS).map(([k, v]) => (
                            <option key={k} value={k}>{v}</option>
                          ))}
                        </select>
                      </div>
                      <div>
                        <label className="text-xs text-gray-500">状態メモ</label>
                        <input
                          type="text"
                          value={cur.conditionNotes || ''}
                          onChange={e => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx >= 0) np[idx].conditionNotes = e.target.value;
                            setProducts(np);
                          }}
                          className="w-full border rounded px-2 py-1 text-xs"
                          placeholder="液晶不良、キーボード欠損等"
                        />
                      </div>
                      <div className="flex items-end gap-2">
                        <label className="flex items-center gap-1 cursor-pointer text-xs">
                          <input type="checkbox" checked={cur.isJunk || false} onChange={e => {
                            const np = [...products]; const idx = np.findIndex(p => p.id === cur.id);
                            if (idx >= 0) np[idx].isJunk = e.target.checked; setProducts(np);
                          }} className="w-3 h-3"/>
                          ⚠️ジャンク
                        </label>
                        <label className="flex items-center gap-1 cursor-pointer text-xs">
                          <input type="checkbox" checked={cur.hasOffice || false} onChange={e => {
                            const np = [...products]; const idx = np.findIndex(p => p.id === cur.id);
                            if (idx >= 0) np[idx].hasOffice = e.target.checked; setProducts(np);
                          }} className="w-3 h-3"/>
                          📦Office
                        </label>
                      </div>
                    </div>
                  </div>

                  {/* タイトル */}
                  <div className="mb-4">
                    <div className="flex items-center justify-between mb-1">
                      <label className="font-medium text-sm">タイトル</label>
                      <span className={`text-xs ${(cur.title || '').length > 80 ? 'text-red-500' : 'text-gray-500'}`}>
                        {(cur.title || '').length}/80
                      </span>
                    </div>
                    <input 
                      type="text" 
                      value={cur.title || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].title = e.target.value;
                        setProducts(np); 
                      }} 
                      className={`w-full border rounded px-3 py-2 ${(cur.title || '').length > 80 ? 'border-red-400' : ''}`}
                    />
                  </div>
                  
                  {/* 価格 */}
                  <div className="mb-4">
                    <label className="font-medium text-sm block mb-1">価格</label>
                    <div className="flex items-center gap-2">
                    <input 
                      type="number" 
                      value={cur.price || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].price = parseInt(e.target.value) || null;
                        setProducts(np); 
                      }} 
                      placeholder="要設定"
                      className="w-32 border rounded px-3 py-2"
                    />
                    {!cur.price && <span className="text-yellow-600 text-sm">⚠ 価格未設定</span>}
                    {(() => {
                      const q = buildSearchQuery(cur);
                      return q ? (<>
                        <a href={buildYahooUrl(q)} target="_blank" rel="noopener" className="px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200 font-bold" title={`ヤフオク落札相場: ${q}`}>Y!</a>
                        <a href={buildMercariUrl(q)} target="_blank" rel="noopener" className="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200 font-bold" title={`メルカリ売切相場: ${q}`}>M</a>
                      </>) : null;
                    })()}
                    </div>
                  </div>
                  
                  {/* 付属品 */}
                  <div className="mb-4">
                    <label className="font-medium text-sm block mb-1">付属品</label>
                    <div className="flex flex-wrap gap-1.5 mb-2">
                      {['ACアダプター', 'ACコード', 'あり', 'なし'].map(item => {
                        const has = (cur.accessories || []).includes(item);
                        return (
                          <button key={item} onClick={() => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = [...(np[idx].accessories || [])];
                            if (has) { accs = accs.filter(a => a !== item); }
                            else { if (item === 'あり' || item === 'なし') accs = [item]; else { accs = accs.filter(a => a !== 'あり' && a !== 'なし'); accs.push(item); } }
                            if (accs.length === 0) accs = ['あり'];
                            np[idx].accessories = accs;
                            // 説明文の付属品セクションも更新
                            if (np[idx].description) {
                              np[idx].description = np[idx].description.replace(/【付属品】\n[^\n]*/, `【付属品】\n${accs.join('、')}`);
                            }
                            setProducts(np);
                          }}
                          className={`px-2.5 py-1 rounded-full text-xs border transition-colors ${has ? 'bg-blue-500 text-white border-blue-500' : 'bg-white text-gray-700 border-gray-300 hover:border-blue-400'}`}
                          >{has ? '✓ ' : ''}{item}</button>
                        );
                      })}
                      {/* カスタム付属品（既存のうち定型外） */}
                      {(cur.accessories || []).filter(a => !['ACアダプター', 'ACコード', 'あり', 'なし'].includes(a)).map(item => (
                        <span key={item} className="px-2.5 py-1 rounded-full text-xs bg-green-100 text-green-800 border border-green-300 flex items-center gap-1">
                          {item}
                          <button onClick={() => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = np[idx].accessories.filter(a => a !== item);
                            if (accs.length === 0) accs = ['あり'];
                            np[idx].accessories = accs;
                            if (np[idx].description) np[idx].description = np[idx].description.replace(/【付属品】\n[^\n]*/, `【付属品】\n${accs.join('、')}`);
                            setProducts(np);
                          }} className="text-green-600 hover:text-red-500">×</button>
                        </span>
                      ))}
                      {/* 追加入力 */}
                      <input
                        type="text" placeholder="+ 追加" 
                        className="px-2 py-1 border rounded text-xs w-20"
                        onKeyDown={e => {
                          if (e.key === 'Enter' && e.target.value.trim()) {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = [...(np[idx].accessories || [])].filter(a => a !== 'あり' && a !== 'なし');
                            const v = e.target.value.trim();
                            if (!accs.includes(v)) accs.push(v);
                            np[idx].accessories = accs;
                            if (np[idx].description) np[idx].description = np[idx].description.replace(/【付属品】\n[^\n]*/, `【付属品】\n${accs.join('、')}`);
                            setProducts(np);
                            e.target.value = '';
                          }
                        }}
                      />
                    </div>
                  </div>
                  
                  {/* 商品説明 */}
                  <div>
                    <label className="font-medium text-sm block mb-1">商品説明</label>
                    <textarea 
                      value={cur.description || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].description = e.target.value;
                        setProducts(np); 
                      }} 
                      rows={20}
                      className="w-full border rounded px-3 py-2 text-sm font-mono"
                    />
                  </div>
                </div>
              )}
            </div>
          </div>
          );
        })()}

        {/* Step 5: 完了 */}
        {step === 5 && (
          <div className="bg-white rounded shadow p-8 text-center">
            <Icon name="check" className="w-16 h-16 text-green-500 mx-auto mb-4"/>
            <h2 className="text-xl font-bold mb-2">完了！</h2>
            <p className="text-gray-600 mb-6">{message}</p>
            <div className="flex gap-4 justify-center">
              <button onClick={() => setStep(4)} className="px-4 py-2 border rounded hover:bg-gray-50">← Step4に戻る</button>
              <button onClick={() => { setStep(1); setProducts([]); idbClear(); }} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">新規作成</button>
            </div>
          </div>
        )}
      </div>

      {/* 保証文エディタ */}
      {showNoticeEditor && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" onClick={() => setShowNoticeEditor(false)}>
          <div className="bg-white rounded-lg shadow-xl max-w-3xl w-full max-h-[85vh] overflow-hidden" onClick={e => e.stopPropagation()}>
            <div className="p-4 border-b flex items-center justify-between">
              <h3 className="font-bold text-lg">📝 保証文テンプレート編集</h3>
              <button onClick={() => setShowNoticeEditor(false)} className="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div className="p-4">
              <textarea
                value={noticeText}
                onChange={e => setNoticeText(e.target.value)}
                rows={18}
                className="w-full border rounded px-3 py-2 text-sm font-mono"
              />
              <div className="flex justify-between mt-3">
                <button onClick={() => { setNoticeText(DEFAULT_NOTICE_TEXT); }} className="px-3 py-1 border rounded text-sm hover:bg-gray-50">デフォルトに戻す</button>
                <div className="flex gap-2">
                  <button onClick={() => setShowNoticeEditor(false)} className="px-4 py-2 border rounded">キャンセル</button>
                  <button onClick={() => { localStorage.setItem('mercari_notice_text', noticeText); setShowNoticeEditor(false); setMessage('✅ 保証文を保存しました'); }} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">保存</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {loading && (
        <div className="fixed inset-0 bg-black/30 flex items-center justify-center" style={{zIndex:999}}>
          <div className="bg-white rounded p-6 flex items-center gap-3 shadow-xl">
            <Icon name="refresh" className="w-6 h-6 animate-spin text-blue-500"/>{message || '処理中...'}
          </div>
        </div>
      )}

      {/* 画像拡大・モザイクモーダル */}
      {zoomImage && React.createElement(MosaicEditor, {
        key: zoomImage.dataUrl,
        src: zoomImage.dataUrl,
        imgIdx: zoomImage.imgIdx,
        barcode: products[currentIdx]?.barcode || '',
        onBarcodeChange: v => { const np = [...products]; np[currentIdx].barcode = v; setProducts(np); },
        onSave: dataUrl => {
          const np = [...products];
          np[currentIdx].images[zoomImage.imgIdx].dataUrl = dataUrl;
          np[currentIdx].images[zoomImage.imgIdx].thumbUrl = null;
          setProducts(np);
          setMessage('✅ モザイク適用しました');
          setZoomImage(null);
        },
        onClose: () => setZoomImage(null)
      })}

      {/* 分解モーダル */}
      {decomposeTarget && (() => {
        const p = products[currentIdx];
        if (!p) return null;
        const { mergedImgs } = decomposeTarget;
        const catLabels = { main: 'MAIN', keyboard: 'KEY', side: 'SIDE', info: 'INFO', spec: 'SPEC', other: '?' };
        const catColors = { main: 'bg-blue-500', keyboard: 'bg-cyan-500', side: 'bg-purple-500', info: 'bg-green-600', spec: 'bg-yellow-600', other: 'bg-gray-500' };
        const cats = ['main', 'info', 'spec', 'keyboard', 'side', 'other'];
        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4" onClick={() => setDecomposeTarget(null)}>
            <div className="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[85vh] overflow-hidden" onClick={e => e.stopPropagation()}>
              <div className="px-5 py-3 border-b flex items-center justify-between bg-purple-50">
                <h3 className="font-bold text-lg">🔓 どの結合画像を分解する？</h3>
                <button onClick={() => setDecomposeTarget(null)} className="text-gray-400 hover:text-gray-600 text-xl">✕</button>
              </div>
              <div className="p-5 overflow-y-auto" style={{maxHeight: 'calc(85vh - 60px)'}}>
                <div className="grid grid-cols-1 gap-4">
                  {mergedImgs.map((mImg, mi) => {
                    const imgIdx = p.images.indexOf(mImg);
                    const cat = mImg.category || mImg.id?.split('_').pop() || '?';
                    // この結合画像と同カテゴリのexcluded画像を見つける
                    const sourceImgs = p.images.filter(img => img.excluded && img.category === cat);
                    return (
                      <div key={mImg.id} className="border-2 rounded-lg p-4 hover:border-purple-400 transition">
                        <div className="flex gap-4 items-start">
                          <div className="flex-shrink-0">
                            <img src={mImg.dataUrl} className="w-48 h-48 object-contain rounded border bg-gray-100" />
                            <span className={`inline-block mt-1 text-white text-xs font-bold px-2 py-0.5 rounded ${catColors[cat] || 'bg-gray-500'}`}>{catLabels[cat] || cat}</span>
                          </div>
                          <div className="flex-1">
                            <div className="text-sm font-medium mb-2">元画像（{sourceImgs.length}枚）</div>
                            <div className="flex flex-wrap gap-2 mb-3">
                              {sourceImgs.map((sImg, si) => (
                                <div key={si} className="relative">
                                  <img src={sImg.thumbUrl || sImg.dataUrl} className="w-24 h-24 object-cover rounded border" />
                                  <button
                                    onClick={() => {
                                      const np = [...products];
                                      const realIdx = np[currentIdx].images.indexOf(sImg);
                                      if (realIdx < 0) return;
                                      const ci = cats.indexOf(sImg.category);
                                      np[currentIdx].images[realIdx].category = cats[(ci + 1) % cats.length];
                                      setProducts(np);
                                      setDecomposeTarget({ ...decomposeTarget }); // re-render
                                    }}
                                    className={`absolute bottom-1 left-1 text-white text-xs font-bold px-1.5 py-0.5 rounded ${catColors[sImg.category] || 'bg-gray-500'}`}
                                    title="クリックでカテゴリ変更"
                                  >{catLabels[sImg.category] || '?'}</button>
                                </div>
                              ))}
                              {sourceImgs.length === 0 && <span className="text-gray-400 text-sm">元画像が見つかりません</span>}
                            </div>
                            <button
                              onClick={() => {
                                const np = [...products];
                                // この結合画像を削除
                                np[currentIdx].images = np[currentIdx].images.filter(img => img.id !== mImg.id);
                                // 同カテゴリのexcluded画像を復元
                                np[currentIdx].images.forEach(img => {
                                  if (img.excluded && img.category === cat) img.excluded = false;
                                });
                                setProducts(np);
                                // mergedImgsを更新
                                const remaining = mergedImgs.filter(m => m.id !== mImg.id);
                                if (remaining.length === 0) {
                                  setDecomposeTarget(null);
                                  setMessage('🔓 分解完了 → バッジを直して🔀再並替');
                                } else {
                                  setDecomposeTarget({ mergedImgs: remaining });
                                  setMessage(`🔓 分解した → 残り${remaining.length}個`);
                                }
                              }}
                              className="px-4 py-2 bg-purple-500 text-white rounded-lg text-sm font-bold hover:bg-purple-600"
                            >🔓 この結合を分解</button>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>
        );
      })()}

      {/* バーコード検査モーダル */}
      {showBcReview && (() => {
        const p = products[bcReviewIdx];
        if (!p) return null;
        const bcImg = p.images.find(img => img.isBarcode && !img.excluded);
        const lastImg = p.images.filter(img => !img.excluded).slice(-1)[0];
        const displayImg = bcImg || lastImg;
        const total = products.length;
        const doneCount = products.filter(p => p.barcode).length;
        return (
          <div className="fixed inset-0 bg-gray-900 flex flex-col z-50">
            {/* ヘッダー */}
            <div className="flex items-center justify-between px-4 py-2 bg-gray-800 text-white flex-shrink-0">
              <div className="flex items-center gap-3">
                <span className="text-lg font-bold">{bcReviewIdx + 1}/{total}</span>
                <span className="text-gray-300 text-sm">{p.folder}</span>
                <span className="text-xs px-2 py-0.5 rounded bg-green-600">{doneCount}件済</span>
              </div>
              <button onClick={() => setShowBcReview(false)} className="text-gray-400 hover:text-white text-sm px-2 py-1">✕ 閉じる</button>
            </div>
            {/* メイン: 画像ドーン */}
            <div className="flex-1 flex items-center justify-center overflow-hidden p-2 min-h-0">
              {displayImg ? (
                <img src={displayImg.dataUrl} className="max-w-full max-h-full object-contain rounded-lg" />
              ) : (
                <div className="text-gray-500 text-xl">BC画像なし</div>
              )}
            </div>
            {/* 入力エリア */}
            <div className="flex-shrink-0 bg-gray-800 px-4 py-3">
              <div className="max-w-2xl mx-auto flex items-center gap-3">
                <button onClick={() => setBcReviewIdx(Math.max(0, bcReviewIdx - 1))} disabled={bcReviewIdx === 0} className="text-gray-400 hover:text-white disabled:opacity-20 text-2xl px-2">◀</button>
                <div className="flex-1 flex items-center gap-2">
                  <input
                    type="text"
                    value={p.barcode || ''}
                    onChange={e => { const np = [...products]; np[bcReviewIdx].barcode = e.target.value; setProducts(np); }}
                    onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); setBcReviewIdx(Math.min(total - 1, bcReviewIdx + 1)); } }}
                    placeholder="バーコード番号を入力 → Enter で次へ"
                    className="flex-1 border-2 border-gray-600 bg-gray-700 text-white rounded-lg px-4 py-3 text-xl font-mono focus:border-blue-400 focus:outline-none"
                    autoFocus
                  />
                  {p.barcode ? <span className="text-green-400 text-2xl">✅</span> : <span className="text-red-400 text-2xl">❌</span>}
                </div>
                <button onClick={() => setBcReviewIdx(Math.min(total - 1, bcReviewIdx + 1))} disabled={bcReviewIdx === total - 1} className="text-gray-400 hover:text-white disabled:opacity-20 text-2xl px-2">▶</button>
              </div>
              <div className="max-w-2xl mx-auto mt-2">
                <div className="flex gap-1 overflow-x-auto pb-1 mb-2" style={{scrollbarWidth:'thin'}}>
                  {products.map((pp, i) => (
                    <button key={i} onClick={() => setBcReviewIdx(i)} className={`w-2.5 h-2.5 rounded-full transition flex-shrink-0 ${i === bcReviewIdx ? 'bg-white scale-125' : pp.barcode ? 'bg-green-500' : 'bg-red-500/60'}`} />
                  ))}
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-gray-400 text-xs">{products.filter(p=>p.barcode).length}/{products.length}件 確認済み</span>
                  <button
                    onClick={() => { setShowBcReview(false); rematchProducts(); }}
                    disabled={loading}
                    className="px-4 py-2 bg-blue-500 text-white rounded font-bold hover:bg-blue-600 disabled:opacity-50"
                  >
                    完了して照合 →
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      })()}

      {/* 写真振り分けモード */}
      {sorterMode && (() => {
        const groups = sorterGetGroups();
        const currentGroup = groups.find(g => sorterSelected >= g.start && sorterSelected < g.end);
        return (
        <div className="sorter-overlay" onKeyDown={e => {
          if (sorterPreview) {
            if (e.key === 'Escape' || e.key === ' ') { e.preventDefault(); setSorterPreview(null); }
            else if (e.key === 'ArrowLeft' && sorterSelected > 0) { e.preventDefault(); setSorterSelected(s => s-1); setSorterPreview(sorterPhotos[sorterSelected-1]?.dataUrl); }
            else if (e.key === 'ArrowRight' && sorterSelected < sorterPhotos.length-1) { e.preventDefault(); setSorterSelected(s => s+1); setSorterPreview(sorterPhotos[sorterSelected+1]?.dataUrl); }
            return;
          }
          if (e.key === 'ArrowRight') { e.preventDefault(); setSorterSelected(s => Math.min(sorterPhotos.length-1, s+1)); }
          else if (e.key === 'ArrowLeft') { e.preventDefault(); setSorterSelected(s => Math.max(0, s-1)); }
          else if (e.key === 's' || e.key === 'S') { e.preventDefault(); sorterToggleSplit(); }
          else if (e.key === 'b' || e.key === 'B') { e.preventDefault(); if (sorterSelected >= 0) setSorterBarcodes(prev => { const n = new Set(prev); n.has(sorterSelected) ? n.delete(sorterSelected) : n.add(sorterSelected); if (n.size > 0) setSorterManualBC(false); return n; }); }
          else if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); sorterUndoSplit(); }
          else if (e.key === ' ') { e.preventDefault(); if (sorterSelected >= 0) setSorterPreview(sorterPhotos[sorterSelected]?.dataUrl); }
          else if (e.key === 'Escape') { if (confirm('振り分けを中止しますか？')) setSorterMode(false); }
        }} tabIndex={0} ref={el => el && el.focus()}>
          <div className="sorter-header">
            <h2>📷 写真振り分けモード</h2>
            <div className="sorter-stats">
              <div className="sorter-stat">写真: <b>{sorterPhotos.length}</b></div>
              <div className="sorter-stat">BC: <b style={{color:'#ef4444'}}>{sorterBarcodes.size}</b></div>
              <div className="sorter-stat">PC数: <b>{groups.length}</b></div>
              {currentGroup && <div className="sorter-stat">現在: <b>{currentGroup.count}</b>枚</div>}
            </div>
          </div>
          <div className="sorter-toolbar">
            <button className="sbtn sbtn-split" onClick={sorterToggleSplit}>✂ ここで区切る (S)</button>
            <button className="sbtn" style={{background:'#3b82f6'}} onClick={() => {
              if (sorterSelected < 0) return;
              setSorterBarcodes(prev => {
                const n = new Set(prev);
                n.has(sorterSelected) ? n.delete(sorterSelected) : n.add(sorterSelected);
                if (n.size > 0) setSorterManualBC(false);
                return n;
              });
            }} title="選択画像のバーコードフラグ切替">🏷 BC切替 (B)</button>
            <button className="sbtn" style={{background:'#f59e0b'}} onClick={() => {
              const autoSplits = new Set();
              Array.from(sorterBarcodes).sort((a,b) => a - b).forEach(idx => {
                if (idx + 1 < sorterPhotos.length) autoSplits.add(idx + 1);
              });
              setSorterSplits(autoSplits);
              setMessage(`BCで${autoSplits.size}グループに区切り直しました`);
            }} title="バーコード位置で区切り直す" disabled={sorterBarcodes.size === 0}>✂ BCで区切り直す</button>
            <button className="sbtn" style={{background:'#8b5cf6'}} onClick={async () => {
              if (!apiKey) { setMessage('APIキー未設定'); return; }
              setLoading(true);
              const bcSet = await detectBarcodesInPhotos(sorterPhotos);
              setSorterBarcodes(bcSet);
              const autoSplits = new Set();
              Array.from(bcSet).sort((a,b) => a - b).forEach(idx => {
                if (idx + 1 < sorterPhotos.length) autoSplits.add(idx + 1);
              });
              setSorterSplits(autoSplits);
              setLoading(false);
              setMessage(`✅ ${bcSet.size}枚検出、${autoSplits.size}グループ`);
            }} title="バーコード再検出">🔄 再検出</button>
            <button className="sbtn sbtn-undo" onClick={sorterUndoSplit}>↩ 戻す (Z)</button>
            <button className="sbtn sbtn-done" onClick={sorterFinish} disabled={sorterSplits.size === 0}>
              ✅ 振り分け完了 ({groups.length}台)
            </button>
            <button className="sbtn sbtn-cancel" onClick={() => { if(confirm('中止しますか？')) setSorterMode(false); }}>✕ 中止</button>
            <div className="sorter-keys">
              <kbd>S</kbd> 区切る <kbd>B</kbd> BC切替 <kbd>Z</kbd> 戻す <kbd>Space</kbd> プレビュー <kbd>←→</kbd> 移動
            </div>
          </div>
          {/* バーコード未検出アラート */}
          <div style={{display:'flex', flex:1, overflow:'hidden'}}>
            {/* PC一覧サイドバー */}
            <div className="sorter-sidebar">
              {groups.map((g, i) => (
                <div key={i}
                  className={`sorter-pc-item ${currentGroup === g ? 's-active' : ''}`}
                  onClick={() => setSorterSelected(g.start)}>
                  <span>PC {i+1}</span><span style={{color:'#888',fontSize:12}}>{g.count}枚</span>
                </div>
              ))}
            </div>
            {/* 写真グリッド */}
            <div className="sorter-grid">
              {sorterPhotos.map((photo, i) => {
                const isSplit = sorterSplits.has(i);
                const isNextSplit = sorterSplits.has(i + 1);
                const isSelected = i === sorterSelected;
                // PC区切りヘッダー
                const groupIdx = groups.findIndex(g => g.start === i);
                return (
                  <React.Fragment key={photo.id}>
                    {(i === 0 || isSplit) && (
                      <div className="sorter-divider">
                        <span>PC {groupIdx >= 0 ? groupIdx + 1 : '?'}</span>
                        <span>{groups[groupIdx]?.count || 0}枚</span>
                      </div>
                    )}
                    <div
                      className={`sorter-item ${isSelected ? 's-selected' : ''} ${isNextSplit ? 's-split' : ''}`}
                      onClick={() => setSorterSelected(i)}
                      onDoubleClick={() => setSorterPreview(photo.dataUrl)}
                      draggable
                      onDragStart={e => e.dataTransfer.setData('text/plain', i.toString())}
                      onDragOver={e => e.preventDefault()}
                      onDrop={e => {
                        e.preventDefault();
                        const from = parseInt(e.dataTransfer.getData('text/plain'));
                        if (from === i) return;
                        setSorterPhotos(prev => {
                          const arr = [...prev];
                          const [moved] = arr.splice(from, 1);
                          arr.splice(i, 0, moved);
                          return arr;
                        });
                        // splitPointsも調整
                        setSorterSplits(prev => {
                          const newSplits = new Set();
                          Array.from(prev).sort((a,b)=>a-b).forEach(sp => {
                            let ns = sp;
                            if (from < i) { if(sp > from && sp <= i) ns=sp-1; else if(sp===from) ns=i; }
                            else { if(sp >= i && sp < from) ns=sp+1; else if(sp===from) ns=i; }
                            if(ns > 0 && ns < sorterPhotos.length) newSplits.add(ns);
                          });
                          return newSplits;
                        });
                        // barcodeフラグも調整
                        setSorterBarcodes(prev => {
                          const newBc = new Set();
                          Array.from(prev).forEach(bp => {
                            let nb = bp;
                            if (from < i) { if(bp > from && bp <= i) nb=bp-1; else if(bp===from) nb=i; }
                            else { if(bp >= i && bp < from) nb=bp+1; else if(bp===from) nb=i; }
                            if(nb >= 0 && nb < sorterPhotos.length) newBc.add(nb);
                          });
                          return newBc;
                        });
                        setSorterSelected(i);
                      }}
                    >
                      <img src={photo.thumbUrl || photo.dataUrl} loading="lazy"/>
                      <div className="s-label">{photo.filename.replace(/\.[^.]+$/, '').replace('IMG_', '')}</div>
                      {sorterBarcodes.has(i) && <div style={{position:'absolute',top:2,left:2,background:'#ef4444',color:'#fff',fontSize:10,padding:'1px 4px',borderRadius:3,fontWeight:'bold'}}>BC</div>}
                    </div>
                  </React.Fragment>
                );
              })}
            </div>
          </div>

          {/* プレビュー */}
          {sorterPreview && (
            <div className="sorter-preview active" onClick={() => setSorterPreview(null)}>
              <img src={sorterPreview}/>
            </div>
          )}
        </div>
        );
      })()}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
