<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒ¡ãƒ«ã‚«ãƒªCSVç”Ÿæˆãƒ„ãƒ¼ãƒ« v4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/encoding-japanese@2.0.0/encoding.min.js"></script>
  <style>
    .drag-over { border-color: #3b82f6 !important; background: #eff6ff !important; }
    /* å†™çœŸæŒ¯ã‚Šåˆ†ã‘ãƒ¢ãƒ¼ãƒ‰ */
    .sorter-overlay { position:fixed; inset:0; background:#1a1a2e; z-index:300; display:flex; flex-direction:column; }
    .sorter-header { background:#16213e; padding:10px 20px; display:flex; justify-content:space-between; align-items:center; border-bottom:2px solid #0f3460; }
    .sorter-header h2 { color:#e94560; font-size:18px; font-weight:bold; }
    .sorter-stats { display:flex; gap:16px; font-size:14px; color:#eee; }
    .sorter-stat { background:#0f3460; padding:4px 12px; border-radius:16px; }
    .sorter-stat b { color:#e94560; }
    .sorter-toolbar { background:#16213e; padding:8px 16px; display:flex; gap:8px; align-items:center; border-bottom:1px solid #0f3460; flex-wrap:wrap; }
    .sorter-toolbar .sbtn { padding:6px 16px; border:none; border-radius:6px; cursor:pointer; font-size:13px; font-weight:600; transition:all 0.2s; }
    .sbtn-split { background:#e94560; color:#fff; } .sbtn-split:hover { background:#ff6b81; }
    .sbtn-undo { background:#444; color:#ddd; } .sbtn-undo:hover { background:#555; }
    .sbtn-done { background:#28a745; color:#fff; font-size:15px; padding:8px 24px; } .sbtn-done:hover { background:#34d058; }
    .sbtn-done:disabled { background:#555; cursor:not-allowed; }
    .sbtn-cancel { background:#666; color:#fff; } .sbtn-cancel:hover { background:#777; }
    .sorter-grid { flex:1; overflow-y:auto; padding:10px; display:flex; flex-wrap:wrap; gap:6px; align-content:flex-start; }
    .sorter-item { width:120px; height:120px; position:relative; cursor:pointer; border-radius:6px; overflow:hidden; border:3px solid transparent; background:#222; user-select:none; transition:border-color 0.15s; }
    .sorter-item img { width:100%; height:100%; object-fit:cover; pointer-events:none; }
    .sorter-item.s-selected { border-color:#00bfff; }
    .sorter-item.s-split { border-color:#e94560; }
    .sorter-item.s-split::after { content:"âœ‚"; position:absolute; top:2px; right:4px; background:#e94560; color:#fff; font-size:12px; padding:2px 6px; border-radius:4px; pointer-events:none; }
    .sorter-item .s-label { position:absolute; bottom:0; left:0; right:0; background:rgba(0,0,0,0.7); font-size:9px; text-align:center; padding:2px; color:#ccc; pointer-events:none; }
    .sorter-divider { width:100%; padding:4px 10px; background:#e94560; color:#fff; font-weight:bold; font-size:13px; border-radius:4px; margin:4px 0; display:flex; justify-content:space-between; }
    .sorter-sidebar { width:180px; background:#16213e; overflow-y:auto; border-right:1px solid #0f3460; flex-shrink:0; }
    .sorter-pc-item { padding:8px 12px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; color:#eee; font-size:13px; transition:background 0.2s; }
    .sorter-pc-item:hover { background:#1a1a40; }
    .sorter-pc-item.s-active { background:#0f3460; border-left:3px solid #e94560; }
    .sorter-preview { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:400; justify-content:center; align-items:center; cursor:pointer; }
    .sorter-preview.active { display:flex; }
    .sorter-preview img { max-width:90%; max-height:90%; object-fit:contain; }
    .sorter-keys { font-size:12px; color:#888; margin-left:auto; }
    .sorter-keys kbd { background:#333; padding:2px 6px; border-radius:4px; border:1px solid #555; font-family:monospace; color:#ddd; }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useCallback, useEffect } = React;

// è¨­å®š
const CONFIG = {
  category_macbook: '9taHgBE3YAkhXLEpvShiYc',
  category_windows: 'FUdk7W2MDA6tujBfXCjgr4',
  shipping_method: 3,        // é…é€æ–¹æ³•ï¼ˆ3=ã‚‰ãã‚‰ããƒ¡ãƒ«ã‚«ãƒªä¾¿ï¼‰
  region: 'jp14',            // ç™ºé€å…ƒï¼ˆjp14=ç¥å¥ˆå·çœŒï¼‰
  shipping_days: 2,          // ç™ºé€æ—¥æ•°ï¼ˆ2=2~3æ—¥ã§ç™ºé€ï¼‰
  shipping_fee: 1,           // é…é€æ–™è² æ‹…ï¼ˆ1=é€æ–™è¾¼ã¿ï¼‰
  condition_map: {           // å•†å“ã®çŠ¶æ…‹
    'æ–°å“ã€æœªä½¿ç”¨': 1,
    'æœªä½¿ç”¨ã«è¿‘ã„': 2,
    'ç›®ç«‹ã£ãŸå‚·ã‚„æ±šã‚Œãªã—': 3,
    'ã‚„ã‚„å‚·ã‚„æ±šã‚Œã‚ã‚Š': 4,
    'å‚·ã‚„æ±šã‚Œã‚ã‚Š': 5,
    'å…¨ä½“çš„ã«çŠ¶æ…‹ãŒæ‚ªã„': 6
  }
};

const CONDITION_MAP = {
  'A': 'ç›®ç«‹ã£ãŸå‚·ã‚„æ±šã‚Œãªã—', 'B': 'ã‚„ã‚„å‚·ã‚„æ±šã‚Œã‚ã‚Š',
  'C': 'ç›®ç«‹ã£ãŸå‚·ã‚„æ±šã‚Œãªã—', 'D': 'ã‚„ã‚„å‚·ã‚„æ±šã‚Œã‚ã‚Š', 'Z': 'å…¨ä½“çš„ã«çŠ¶æ…‹ãŒæ‚ªã„'
};

const ACCESSORY_MAP = {
  'é›»æºï½ºï½°ï¾„ï¾': 'ACã‚³ãƒ¼ãƒ‰', 'ACï½ºï½°ï¾„ï¾': 'ACã‚³ãƒ¼ãƒ‰', 'ACã‚³ãƒ¼ãƒ‰': 'ACã‚³ãƒ¼ãƒ‰',
  'ACï½±ï¾€ï¾ï¾Œï¾Ÿï¾€': 'ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼', 'ACï½±ï¾€ï¾ï¾Œï¾Ÿï¾€ï½°': 'ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼', 'ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼': 'ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼',
  'MagSafeã‚±ãƒ¼ãƒ–ãƒ«': 'MagSafeã‚±ãƒ¼ãƒ–ãƒ«', 'USB-C-Cã‚±ãƒ¼ãƒ–ãƒ«': 'USB-Cã‚±ãƒ¼ãƒ–ãƒ«',
  'ACãƒ—ãƒ©ã‚°': 'ACãƒ—ãƒ©ã‚°', 'ï¾ï½³ï½½': 'ãƒã‚¦ã‚¹', 'ï½·ï½°ï¾ï¾ï½°ï¾„ï¾': 'ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰'
};
const ACCESSORY_EXCLUDE = ['ï¾Šï¾ï½¯ï¾ƒï¾˜ï¾Šï¾Ÿï½¯ï½¸', 'Webï½¶ï¾’ï¾—æœ‰', 'è‹±å­—KB', 'TVæ©Ÿèƒ½'];

const DEFAULT_NOTICE_TEXT = `â€» å®Ÿéš›ã®å•†å“ç”»åƒã§ã™ã€‚
â€» ã‚¹ãƒšãƒƒã‚¯ã‚„çŠ¶æ…‹ã®è©³ç´°ã¯ç”»åƒã‹ã‚‰ã”ç¢ºèªãã ã•ã„ã€‚
â€» ä¸­å¤å“ã®ãŸã‚ã€ä½¿ç”¨ã«å·®ã—æ”¯ãˆãªã„å‚·ã‚„æ±šã‚ŒãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚å¿…ãšå†™çœŸã‚’ã”ç¢ºèªãã ã•ã„ã€‚

â–  åˆæœŸä¸è‰¯ã«ã¤ã„ã¦
å‡ºè·æ—¥ã‹ã‚‰7æ—¥ä»¥å†…ã«ã”é€£çµ¡ã„ãŸã ã„ãŸåˆæœŸä¸è‰¯ï¼ˆé›»æºãŒå…¥ã‚‰ãªã„ã€ç”»é¢ãŒæ˜ ã‚‰ãªã„ãªã©ï¼‰ã«ã¤ã„ã¦ã¯ã€å½“åº—ã«ã¦å‹•ä½œç¢ºèªã®ä¸Šã€ç„¡å„Ÿã§äº¤æ›ã¾ãŸã¯ä¿®ç†å¯¾å¿œã‚’è¡Œã„ã¾ã™ã€‚
ãƒ»å¯¾è±¡æœŸé–“ï¼šå‡ºè·æ—¥ã‹ã‚‰7æ—¥é–“
ãƒ»é€æ–™ï¼šå¾€å¾©ã™ã¹ã¦å½“åº—è² æ‹…

â–  ä¿è¨¼å¯¾è±¡å¤–
ä»¥ä¸‹ã®å ´åˆã¯ä¿è¨¼ãƒ»è¿”å“ã®å¯¾è±¡å¤–ã§ã™ã€‚
ãƒ»ãŠå®¢æ§˜ã®éå¤±ã«ã‚ˆã‚‹æ•…éšœãƒ»ç ´æï¼ˆæ°´æ¿¡ã‚Œãƒ»è½ä¸‹ãƒ»è¡æ’ƒãƒ»èª¤æ¥ç¶šãªã©ï¼‰
ãƒ»åˆ†è§£ãƒ»æ”¹é€ ã«ã‚ˆã‚‹ãƒˆãƒ©ãƒ–ãƒ«
ãƒ»ãŠå®¢æ§˜ã”è‡ªèº«ã«ã‚ˆã‚‹OSå†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¾Œã®ãƒˆãƒ©ãƒ–ãƒ«
ãƒ»ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä¸å…·åˆã€å¯¾å¿œã—ãªã„ã‚²ãƒ¼ãƒ ç­‰ã¨ã®ç›¸æ€§å•é¡Œ
ãƒ»å‹•ä½œã«å½±éŸ¿ã—ãªã„è»½å¾®ãªå¤–è¦³ä¸Šã®å‚·ã‚„æ±šã‚Œ
ãƒ»å‹•ä½œã«å½±éŸ¿ã—ãªã„USBãƒãƒ¼ãƒˆãƒ»Type-Cãƒãƒ¼ãƒˆã®ä¸è‰¯
ãƒ»å‹•ä½œã«å½±éŸ¿ã—ãªã„ã‚«ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ€ãƒ¼ãƒ»ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªç«¯å­ç­‰ã®ä¸è‰¯
ãƒ»ãƒãƒƒãƒ†ãƒªãƒ¼ã®åŠ£åŒ–ãƒ»æ¶ˆè€—ï¼ˆãƒãƒ¼ãƒˆPCã®å ´åˆï¼‰
ãƒ»ãã®ä»–ã€PCå‹•ä½œã«å½±éŸ¿ã®ãªã„å¾®ç´°ãªä¸å…·åˆ
â€»å•†å“èª¬æ˜ã«å‹•ä½œç¢ºèªæ¸ˆã¿ã¨è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹æ©Ÿèƒ½ã¯ä¿è¨¼å¯¾è±¡ã§ã™ã€‚
â€»ã€Œåˆ†è§£ãƒ»æ”¹é€ ã€ã«ã¤ã„ã¦ï¼šå½“åº—ã‹ã‚‰ã®æŒ‡ç¤ºãªãå†…éƒ¨ãƒ‘ãƒ¼ãƒ„ã¸ã®ä½œæ¥­ã‚’è¡Œã£ãŸå ´åˆã¯ä¿è¨¼å¯¾è±¡å¤–ã¨ãªã‚Šã¾ã™ã€‚ä¸å…·åˆãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ã¾ãšå½“åº—ã¸ã”é€£çµ¡ãã ã•ã„ã€‚

â–  è¿”é€ã«ã¤ã„ã¦
ãƒ»åˆæœŸä¸è‰¯ã®å ´åˆï¼šé€æ–™ã¯å¾€å¾©ã™ã¹ã¦å½“åº—è² æ‹…ã§ã™ã€‚
ãƒ»åˆæœŸä¸è‰¯ä»¥å¤–ã®ä¿è¨¼é©ç”¨ãƒ»è¿”å“ã®å ´åˆï¼šé€æ–™ã¯ãŠå®¢æ§˜è² æ‹…ï¼ˆå…ƒæ‰•ã„ï¼‰ã¨ãªã‚Šã¾ã™ã€‚

â–  ä¸å…·åˆã®ã”é€£çµ¡ã«ã¤ã„ã¦
ä¸å…·åˆã®å…·ä½“çš„ãªç—‡çŠ¶ãƒ»ç™ºç”ŸçŠ¶æ³ãƒ»å†™çœŸã¾ãŸã¯å‹•ç”»ã‚’ã”æä¾›ãã ã•ã„ã€‚
æƒ…å ±ã‚’ã”æä¾›ã„ãŸã ã‘ãªã„å ´åˆã¯ã€å¯¾å¿œã‚’ãŠæ–­ã‚Šã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚`;

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
const normalizeMemory = (v) => {
  if (!v) return '';
  const str = String(v).toUpperCase();
  // MBè¡¨è¨˜ã®å ´åˆã¯GBã«å¤‰æ›
  const mbMatch = str.match(/(\d+)\s*(MB|M)/i);
  if (mbMatch) {
    const mb = parseInt(mbMatch[1]);
    return `${Math.round(mb / 1024)}GB`;
  }
  // GBè¡¨è¨˜
  const gbMatch = str.match(/(\d+)\s*(GB|G)?/i);
  if (gbMatch) {
    const n = parseInt(gbMatch[1]);
    // 1000ä»¥ä¸Šã¯MBã®å¯èƒ½æ€§ãŒé«˜ã„
    if (n >= 1000) return `${Math.round(n / 1024)}GB`;
    return `${n}GB`;
  }
  return v;
};

const normalizeStorage = (v) => {
  if (!v) return '';
  const str = String(v).toUpperCase();
  const m = str.match(/(\d+)\s*(G|GB|T|TB)?/i);
  if (m) {
    const n = parseInt(m[1]);
    const u = (m[2] || '').toUpperCase();
    return (u === 'T' || u === 'TB' || n <= 4) ? `${n}TB` : `${n}GB`;
  }
  return v;
};

// EMCç•ªå·ã‹ã‚‰Macæƒ…å ±ã‚’å–å¾—ã™ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°
const EMC_MAP = {
  // MacBook Pro 16"
  '3347': { size: '16', year: '2019' },
  '3651': { size: '16', year: '2021' },
  '4044': { size: '16', year: '2023' },
  // MacBook Pro 15"
  '3215': { size: '15', year: '2018' },
  '3162': { size: '15', year: '2017' },
  '3163': { size: '15', year: '2017' },
  '3072': { size: '15', year: '2016' },
  // MacBook Pro 14"
  '3598': { size: '14', year: '2021' },
  '4046': { size: '14', year: '2023' },
  // MacBook Pro 13"
  '3301': { size: '13', year: '2019' },
  '3214': { size: '13', year: '2018' },
  '3164': { size: '13', year: '2017' },
  '3071': { size: '13', year: '2016' },
  '3358': { size: '13', year: '2020' },
  '3578': { size: '13', year: '2020' }, // M1
  // MacBook Air 13"
  '3348': { size: '13', year: '2020' },
  '3598': { size: '13', year: '2020' }, // M1
  '3941': { size: '13', year: '2022' }, // M2
  // MacBook Air 15"
  '4043': { size: '15', year: '2023' },
};

const extractSpecs = (row) => {
  const s = { maker: '', product_name: '', cpu: '', memory: '', storage: '', display: '', gpu: '', model: '', size: '', year: '', chip: '' };
  if (!row) return s;
  
  s.maker = row['ãƒ¡ãƒ¼ã‚«ãƒ¼'] || '';
  s.product_name = (row['å•†å“å'] || '').replace(/\([^)]*\)/g, '').trim();
  s.gpu = row['GPU'] || '';
  
  // Macæƒ…å ±æŠ½å‡º
  const name = row['å•†å“å'] || '';
  const cpu = row['CPU'] || '';
  const makerLower = s.maker.toLowerCase();
  const nameLower = name.toLowerCase();
  
  if (makerLower.includes('apple') || nameLower.includes('mac')) {
    // EMCç•ªå·ã‹ã‚‰æƒ…å ±å–å¾—
    const emcMatch = name.match(/EMC\s*(\d{4})/i);
    if (emcMatch && EMC_MAP[emcMatch[1]]) {
      const emcInfo = EMC_MAP[emcMatch[1]];
      s.size = emcInfo.size + 'ã‚¤ãƒ³ãƒ';
      s.year = emcInfo.year;
    }
    
    // modelæŠ½å‡ºï¼ˆPro/Air/mini/iMacï¼‰
    if (/macbook\s*pro|m-?book\s*pro/i.test(name)) {
      s.model = 'MacBook Pro';
    } else if (/macbook\s*air|m-?book\s*air/i.test(name)) {
      s.model = 'MacBook Air';
    } else if (/mac\s*mini/i.test(name)) {
      s.model = 'Mac mini';
    } else if (/imac/i.test(name)) {
      s.model = 'iMac';
    } else if (/mac\s*pro/i.test(name)) {
      s.model = 'Mac Pro';
    } else {
      s.model = 'MacBook';
    }
    
    // sizeæŠ½å‡ºï¼ˆEMCã‹ã‚‰å–å¾—æ¸ˆã¿ã§ãªã‘ã‚Œã°ï¼‰
    if (!s.size) {
      const nameForSize = name.replace(/\([^)]*\)/g, '');
      const sizeMatch = nameForSize.match(/(\d{2})[- ]?inch|(\d{2}(?:\.\d)?)[ï½²ã‚¤]?ï¾?ï¾|(\d{2}(?:\.\d)?)ã‚¤ãƒ³ãƒ/i);
      if (sizeMatch) {
        s.size = (sizeMatch[1] || sizeMatch[2] || sizeMatch[3]) + 'ã‚¤ãƒ³ãƒ';
      }
    }
    
    // yearæŠ½å‡ºï¼ˆEMCã‹ã‚‰å–å¾—æ¸ˆã¿ã§ãªã‘ã‚Œã°ï¼‰
    if (!s.year) {
      const yearMatch = name.match(/\b(20[12]\d)\b/);
      if (yearMatch) {
        s.year = yearMatch[1];
      }
    }
    
    // yearãŒãªã‘ã‚Œã°CPUå‹ç•ªã‹ã‚‰æ¨æ¸¬
    if (!s.year && cpu) {
      // Ice Lake Macç”¨ï¼ˆ1000NG4, 1030NG7ãªã©ï¼‰
      if (/10[0-9]{2}NG/i.test(cpu)) {
        s.year = '2020';
      } else {
        // ç¬¬10ä¸–ä»£ä»¥é™ï¼ˆ10xxxã€œ14xxxï¼‰
        let genMatch = cpu.match(/i[3579]-(1[0-4])\d{3}/i);
        if (genMatch) {
          const gen = parseInt(genMatch[1]);
          const yearMap = {10: '2020', 11: '2020', 12: '2021', 13: '2022', 14: '2023'};
          s.year = yearMap[gen] || '';
        } else {
          // ç¬¬4-9ä¸–ä»£ï¼ˆ4xxxã€œ9xxxï¼‰
          genMatch = cpu.match(/i[3579]-([4-9])\d{3}/i);
          if (genMatch) {
            const gen = parseInt(genMatch[1]);
            const yearMap = {4: '2013', 5: '2015', 6: '2016', 7: '2017', 8: '2018', 9: '2019'};
            s.year = yearMap[gen] || '';
          }
        }
      }
    }
    
    // chipæŠ½å‡ºï¼ˆM1/M2/M3/M4ãªã©ã€M1P=M1 Proãªã©çŸ­ç¸®å½¢ã‚‚å¯¾å¿œï¼‰
    const chipMatch = cpu.match(/\b(M[1-4](?:\s*(?:Pro|Max|Ultra))?)\b/i) || cpu.match(/\b(M[1-4]P)\b/i);
    if (chipMatch) {
      let chip = chipMatch[1];
      // çŸ­ç¸®å½¢ã‚’å±•é–‹
      chip = chip.replace(/^M(\d)P$/i, 'M$1 Pro');
      s.chip = chip;
    }
  }
  
  // å°‚ç”¨åˆ—ãŒã‚ã‚Œã°å„ªå…ˆ
  if (row['ãƒ¡ãƒ¢ãƒª']) s.memory = normalizeMemory(row['ãƒ¡ãƒ¢ãƒª']);
  if (row['ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸']) s.storage = normalizeStorage(row['ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸']);
  if (row['ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã‚µã‚¤ã‚º']) {
    const d = row['ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã‚µã‚¤ã‚º'].replace(/[ï½²ï¾ï¾ã‚¤ãƒ³ãƒå‹]/g, '').trim();
    if (d) s.display = `${d}ã‚¤ãƒ³ãƒ`;
  }
  
  // CPUåˆ—ã‚’è§£æ
  if (cpu) {
    const p = cpu.split('/');
    s.cpu = p[0]?.trim() || '';
    
    // CPUåˆ—ã‹ã‚‰GPUæŠ½å‡º
    p.forEach(x => { if (/RTX|GTX|MX\d/i.test(x) && !s.gpu) s.gpu = x.trim(); });
    
    // å°‚ç”¨åˆ—ãŒç©ºã®å ´åˆã€CPUåˆ—ã‹ã‚‰æŠ½å‡º
    if (!s.memory && p[1]) s.memory = normalizeMemory(p[1].trim());
    if (!s.storage && p[2]) s.storage = normalizeStorage(p[2].trim());
    if (!s.display && p[3]) {
      const d = p[3].replace(/[ï½²ï¾ï¾ã‚¤ãƒ³ãƒå‹]/g, '').trim();
      if (d) s.display = `${d}ã‚¤ãƒ³ãƒ`;
    }
    
    // Macç”¨: sizeãŒã¾ã ç©ºãªã‚‰CPUåˆ—ã‹ã‚‰å–å¾—
    if (!s.size && p[3]) {
      const sizeFromCpu = p[3].match(/(\d{2}(?:\.\d)?)/);
      if (sizeFromCpu) s.size = sizeFromCpu[1] + 'ã‚¤ãƒ³ãƒ';
    }
  }
  
  return s;
};

const detectProductType = (row, specs) => {
  const m = (specs.maker || '').toLowerCase();
  const n = (row['å•†å“å'] || '').toLowerCase();
  const c = row['CPU'] || '';
  if (m.includes('apple') || n.includes('mac')) {
    // M1/M2/M3/M4ã€ã¾ãŸã¯M1P/M2Pãªã©çŸ­ç¸®å½¢
    return /\bM[1-4]\b|^M[1-4]P?\b/i.test(c) ? 'apple_silicon' : 'intel_mac';
  }
  return 'windows';
};

const parseAccessories = (str) => {
  if (!str) return [];
  const r = [];
  str.split(/[\s/]+/).forEach(p => {
    if (ACCESSORY_EXCLUDE.some(e => p.includes(e))) return;
    for (const [k, v] of Object.entries(ACCESSORY_MAP)) {
      if (p.includes(k) && !r.includes(v)) { r.push(v); break; }
    }
  });
  return r;
};

// ãƒ©ãƒ³ã‚¯ã‚’æ—¥æœ¬èªã«å¤‰æ›
const RANK_DISPLAY = {
  'A': 'ç¾å“',
  'B': 'ç¾å“',
  'C': 'è‰¯å“',
  'D': 'å‚·ã‚ã‚Š',
  'E': 'ã‚¸ãƒ£ãƒ³ã‚¯'
};

// ã‚¿ã‚¤ãƒˆãƒ«ç”¨CPUè¡¨è¨˜ã‚¯ãƒªãƒ¼ãƒ³ï¼ˆCi5-1.3G-1335U â†’ Core i5-1335Uï¼‰
const cleanCpuForTitle = (cpu) => {
  if (!cpu) return '';
  let c = cpu;
  // å‘¨æ³¢æ•°ã‚’é™¤å»: -1.7G-, -2.3G, 1.60GHzç­‰
  c = c.replace(/-[\d.]+G(?=-|$)/g, '');  // -1.7G- å½¢å¼
  c = c.replace(/\s*[\d.]+\s*GHz/i, '');   // 1.60GHz å½¢å¼
  // Ci3/Ci5/Ci7/Ci9 â†’ Core i3/i5/i7/i9
  c = c.replace(/^Ci(\d)/i, 'Core i$1');
  // Corei5 â†’ Core i5ï¼ˆã‚¹ãƒšãƒ¼ã‚¹æŒ¿å…¥ï¼‰
  c = c.replace(/^Corei(\d)/i, 'Core i$1');
  // Core i5- ç­‰ã®ãƒ€ãƒƒã‚·ãƒ¥ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«ï¼ˆCore i5-10310U â†’ Core i5 10310Uï¼‰
  c = c.replace(/^(Core\s*i\d)\s*-\s*/i, '$1 ');
  // äºŒé‡ãƒ€ãƒƒã‚·ãƒ¥ãƒ»æœ«å°¾ãƒ€ãƒƒã‚·ãƒ¥æ•´ç†
  c = c.replace(/--+/g, '-').replace(/^-|-$/g, '');
  return c.trim();
};

const makeTitle = (p) => {
  const s = p.specs || {};
  const t = p.product_type;
  // ã‚¸ãƒ£ãƒ³ã‚¯å“ã®å ´åˆã¯ã€ã‚¸ãƒ£ãƒ³ã‚¯ã€‘ã®ã¿ã€é€šå¸¸ã¯ã€ãƒ©ãƒ³ã‚¯ã€‘ã€1é€±é–“ä¿è¨¼ã€‘
  let prefix;
  if (p.isJunk) {
    prefix = 'ã€ã‚¸ãƒ£ãƒ³ã‚¯ã€‘';
  } else {
    const rankJp = RANK_DISPLAY[p.rank] || 'è‰¯å“';
    prefix = `ã€${rankJp}ã€‘ã€1é€±é–“ä¿è¨¼ã€‘`;
  }
  const parts = [prefix];
  if (t === 'intel_mac' || t === 'apple_silicon') {
    parts.push(`${s.model || 'MacBook'} ${s.size || ''}`);
    if (s.year) parts.push(String(s.year));
    if (t === 'apple_silicon' && s.chip) parts.push(s.chip);
    else if (s.cpu) {
      parts.push(cleanCpuForTitle(s.cpu));
    }
    if (s.memory) parts.push(s.memory);
    if (s.storage) parts.push(s.storage);
  } else {
    if (s.maker) parts.push(s.maker.replace('mouse computer', 'mouse'));
    if (s.cpu) {
      parts.push(cleanCpuForTitle(s.cpu));
    }
    if (s.memory) parts.push(s.memory);
    if (s.storage) parts.push(s.storage);
    if (s.display) parts.push(s.display);
    // å¤–ä»˜ã‘GPUã®ã¿è¡¨ç¤ºï¼ˆRTX/GTX/MX/Radeon/GeForceï¼‰ã€å†…è”µGPU(Intel/Lakeç³»)ã¯é™¤å¤–
    if (s.gpu && /RTX|GTX|MX\d|Radeon|GeForce/i.test(s.gpu)) parts.push(s.gpu);
    parts.push('Win11');
  }
  let title = parts[0] + parts.slice(1).join(' / ');
  return title.length > 65 ? title.slice(0, 62) + '...' : title;
};

// ã‚¸ãƒ£ãƒ³ã‚¯å“ç”¨ã®çŠ¶æ…‹ãƒ†ã‚­ã‚¹ãƒˆ
const JUNK_STATE_TEXT = `æœ¬å•†å“ã¯ã‚¸ãƒ£ãƒ³ã‚¯å“ã®ãŸã‚ã€å‹•ä½œãƒ»çŠ¶æ…‹ãƒ»éƒ¨å“ã®æ¬ å“ã‚’ä¸€åˆ‡ä¿è¨¼ã—ã¾ã›ã‚“ã€‚
èµ·å‹•ä¸å¯ãƒ»ç”»é¢ä¸è‰¯ãƒ»ç•°éŸ³ãƒ»ç«¯å­ä¸è‰¯ãƒ»ãƒãƒƒãƒ†ãƒªãƒ¼åŠ£åŒ–ãƒ»å¤–è£…ç ´æãªã©ã€ã„ã‹ãªã‚‹ä¸å…·åˆã§ã‚‚è¿”å“ãƒ»è¿”é‡‘ãƒ»äº¤æ›ä¸å¯ã¨ãªã‚Šã¾ã™ã€‚
ä¿®ç†ãƒ»éƒ¨å“å–ã‚Šå‰æã§ã”è³¼å…¥ãã ã•ã„ã€‚`;

const makeDescription = (p, customNotice) => {
  const s = p.specs || {};
  const t = p.product_type;
  // å‹ç•ªã‹ã‚‰ã€Œä»– Xå°ã‚»ãƒƒãƒˆã€ã‚’å‰Šé™¤
  const modelClean = (s.product_name || '-').replace(/ä»–?\s*\d+å°[ï½¾ã‚»][ï½¯ãƒƒ][ï¾„ãƒˆ]/g, '').trim() || '-';
  const lines = [];
  if (t === 'intel_mac' || t === 'apple_silicon') {
    lines.push(`ãƒ¢ãƒ‡ãƒ«ï¼š${s.model || 'MacBook'} ${s.year || ''}`);
    if (t === 'apple_silicon') lines.push(`ãƒãƒƒãƒ—ï¼šApple ${s.chip || ''}`);
    else lines.push(`CPUï¼š${s.cpu || '-'}`);
    if (s.gpu) lines.push(`GPUï¼š${s.gpu}`);
    lines.push(`ãƒ¡ãƒ¢ãƒªï¼š${s.memory || '-'}`, `ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼š${s.storage || '-'}`, `ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ï¼š${s.size || '-'}`);
    if (p.cycle_count) lines.push(`å……æ”¾é›»å›æ•°ï¼š${p.cycle_count}å›`);
    if (p.battery_health) lines.push(`ãƒãƒƒãƒ†ãƒªãƒ¼æœ€å¤§å®¹é‡ï¼š${p.battery_health}%`);
    lines.push(`åˆæœŸè¨­å®šãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼š0000`);
  } else {
    lines.push(`ãƒ¡ãƒ¼ã‚«ãƒ¼ï¼š${s.maker || '-'}`, `å‹ç•ªï¼š${modelClean}`, `CPUï¼š${s.cpu || '-'}`);
    if (s.gpu) lines.push(`GPUï¼š${s.gpu}`);
    lines.push(`ãƒ¡ãƒ¢ãƒªï¼š${s.memory || '-'}`, `ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼š${s.storage || '-'}`, `ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ï¼š${s.display || '-'}`, 'OSï¼šWindows 11');
    if (p.hasOffice) lines.push('Officeï¼šMicrosoft Office2024(æ°¸ç¶šç‰ˆ)æ­è¼‰\nâ‡’word,excel,PowerPointç­‰åˆ©ç”¨å¯èƒ½');
  }
  if (p.is_english_kb) lines.push('ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼šè‹±å­—é…åˆ—');
  const spec = 'ã€ã‚¹ãƒšãƒƒã‚¯ã€‘\n' + lines.join('\n');
  const acc = `ã€ä»˜å±å“ã€‘\n${(p.accessories || []).join('ã€')}`;
  // ã‚¸ãƒ£ãƒ³ã‚¯å“ã®å ´åˆã¯å°‚ç”¨ãƒ†ã‚­ã‚¹ãƒˆã€é€šå¸¸ã¯ç‘•ç–µæƒ…å ±
  const stateContent = p.isJunk ? JUNK_STATE_TEXT : (p.defect_info || '');
  const state = `ã€çŠ¶æ…‹ã€‘\n${stateContent}`;
  // ã‚¸ãƒ£ãƒ³ã‚¯å“ã®å ´åˆã¯NOTICE_TEXTã‚’çœç•¥
  const notice = p.isJunk ? '' : (customNotice || DEFAULT_NOTICE_TEXT);
  return `${p.barcode || ''}\n\n${p.intro || ''}\n\n${spec}\n\n${acc}\n\n${state}${notice ? '\n\n' + notice : ''}`;
};

// OpenAI APIï¼ˆgpt-4.1-miniå›ºå®šï¼‰
const callOpenAI = async (key, msgs, max = 200) => {
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
    body: JSON.stringify({ model: 'gpt-4.1-mini', messages: msgs, max_completion_tokens: max })
  });
  const d = await r.json();
  if (d.error) throw new Error(d.error.message);
  return d.choices[0].message.content.trim();
};

// OCR
const ocrBarcode = async (key, dataUrl) => {
  const base64 = dataUrl.split(',')[1];
  const media = dataUrl.startsWith('data:image/png') ? 'image/png' : 'image/jpeg';
  const result = await callOpenAI(key, [{
    role: 'user',
    content: [
      { type: 'text', text: 'ã“ã®ç”»åƒã«ã‚ã‚‹æ•°å­—ã®ä¸‹6æ¡ã‚’è¿”ã—ã¦ãã ã•ã„ã€€è¿”ç­”ã¯æ•°å­—ã®6æ¡ã®ã¿ã§' },
      { type: 'image_url', image_url: { url: `data:${media};base64,${base64}` } }
    ]
  }], 50);
  const digits = result.trim().replace(/[^0-9]/g, '');
  if (!digits) return null;
  return digits.padStart(6, '0').slice(-6);
};

// ç”»åƒåˆ†é¡ï¼ˆGPT-4o-miniå›ºå®šã§ã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼‰
const classifyImages = async (key, images) => {
  const imageContents = images.map((img, i) => ({
    type: 'image_url',
    image_url: { url: img.dataUrl, detail: 'low' }
  }));
  
  const prompt = `ä¸­å¤PCå•†å“ã®ç”»åƒã‚’åˆ†é¡ã—ã¦ãã ã•ã„ã€‚å„ç”»åƒã«1ã‚«ãƒ†ã‚´ãƒªå‰²ã‚Šå½“ã¦ï¼š
- main: PCãŒé–‹ã„ãŸçŠ¶æ…‹ã§å…¨ä½“ãŒè¦‹ãˆã‚‹å†™çœŸ
- screen: ç”»é¢ã®ã‚¢ãƒƒãƒ—ï¼ˆã‚¹ãƒšãƒƒã‚¯è¡¨ç¤ºãƒ»ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãƒ»ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ï¼‰
- keyboard: ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ã‚¢ãƒƒãƒ—
- side: é–‰ã˜ãŸå¤©é¢ã€å´é¢ãƒãƒ¼ãƒˆã€åº•é¢ã€å¤–è£…ã®å†™çœŸï¼ˆPCãŒé–‰ã˜ã¦ã„ã‚‹ç”»åƒã¯å…¨ã¦sideï¼‰
- battery: ãƒãƒƒãƒ†ãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆï¼ˆpowercfg/Battery report/å……æ”¾é›»å›æ•°ï¼‰
- spec: ãƒ©ãƒ™ãƒ«ãƒ»ã‚·ãƒ¼ãƒ«ãƒ»ä»•æ§˜æ›¸ã®ã‚¢ãƒƒãƒ—
- barcode: ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«ï¼ˆæ•°å­—ã®ç¾…åˆ—ï¼‹ç¸¦ç·šï¼‰
- other: ä¸Šè¨˜ä»¥å¤–

é‡è¦: PCãŒé–‰ã˜ã¦ã„ã‚‹å†™çœŸï¼ˆå¤©é¢ãƒ­ã‚´å«ã‚€ï¼‰ã¯mainã§ã¯ãªãsideã§ã™ã€‚

JSONå‡ºåŠ›ï¼ˆindexã¯0å§‹ã¾ã‚Šï¼‰:
{"results":[{"index":0,"category":"main"},{"index":1,"category":"screen"},...]}`;

  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
    body: JSON.stringify({
      model: 'gpt-4.1-mini',
      messages: [{ role: 'user', content: [{ type: 'text', text: prompt }, ...imageContents] }],
      max_completion_tokens: 500
    })
  });
  const d = await r.json();
  if (d.error) throw new Error(d.error.message);
  
  try {
    const text = d.choices[0].message.content.trim();
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]).results;
    }
  } catch (e) {
    console.error('åˆ†é¡çµæœã®ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:', e);
  }
  return null;
};

const generateIntro = async (key, p) => {
  const s = p.specs || {};
  // å‹ç•ªã‹ã‚‰ã€Œä»– Xå°ã‚»ãƒƒãƒˆã€ã‚’å‰Šé™¤
  const modelClean = (s.product_name || '').replace(/ä»–?\s*\d+å°[ï½¾ã‚»][ï½¯ãƒƒ][ï¾„ãƒˆ]/g, '').trim();
  const officeInfo = p.hasOffice ? 'Microsoft Office2024(æ°¸ç¶šç‰ˆ)æ­è¼‰' : 'ãªã—';
  
  // ã‚¸ãƒ£ãƒ³ã‚¯å“ã®å ´åˆã¯å°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
  if (p.isJunk) {
    const prompt = `ä»¥ä¸‹ã®ã‚¸ãƒ£ãƒ³ã‚¯å“PCã®ç´¹ä»‹æ–‡ã‚’3ã€œ4è¡Œã§ä½œæˆã—ã¦ãã ã•ã„ã€‚è‡ªç„¶ãªæ—¥æœ¬èªã§ã€‚ã‚¸ãƒ£ãƒ³ã‚¯å“ã§ã‚ã‚‹ã“ã¨ã€å‹•ä½œä¿è¨¼ãŒãªã„ã“ã¨ã€ä¿®ç†ãƒ»éƒ¨å“å–ã‚Šç”¨ã§ã‚ã‚‹ã“ã¨ã‚’æ˜ç¢ºã«ä¼ãˆã¦ãã ã•ã„ã€‚
å•†å“ã‚¿ã‚¤ãƒ—: ${p.product_type}
ãƒ¡ãƒ¼ã‚«ãƒ¼: ${s.maker}
å‹ç•ª: ${modelClean}
CPU: ${s.cpu}
ãƒ¡ãƒ¢ãƒª: ${s.memory}
ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸: ${s.storage}
ç´¹ä»‹æ–‡ã®ã¿ã‚’å‡ºåŠ›:`;
    return await callOpenAI(key, [{ role: 'user', content: prompt }], 200);
  }
  
  const prompt = `ä»¥ä¸‹ã®ä¸­å¤PCã®ç´¹ä»‹æ–‡ã‚’3ã€œ4è¡Œã§ä½œæˆã—ã¦ãã ã•ã„ã€‚è‡ªç„¶ãªæ—¥æœ¬èªã§ã€‚1å°ã®å•†å“ã¨ã—ã¦ç´¹ä»‹ã—ã¦ãã ã•ã„ã€‚
å•†å“ã‚¿ã‚¤ãƒ—: ${p.product_type}
ãƒ¡ãƒ¼ã‚«ãƒ¼: ${s.maker}
å‹ç•ª: ${modelClean}
CPU: ${s.cpu}
ãƒ¡ãƒ¢ãƒª: ${s.memory}
ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸: ${s.storage}
Office: ${officeInfo}
ç´¹ä»‹æ–‡ã®ã¿ã‚’å‡ºåŠ›:`;
  return await callOpenAI(key, [{ role: 'user', content: prompt }], 200);
};

// ç”»åƒçµåˆé–¢æ•°ï¼ˆ2æšæ¨ªä¸¦ã³ / 3æšLå­— / 4æšã‚°ãƒªãƒƒãƒ‰ï¼‰
const mergeImages = async (images, cols = 2) => {
  const size = 1000;
  const rows = Math.ceil(images.length / cols);
  const canvas = document.createElement('canvas');
  canvas.width = size * cols;
  canvas.height = size * rows;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  for (let i = 0; i < images.length; i++) {
    const img = new Image();
    await new Promise((resolve) => {
      img.onload = resolve;
      img.onerror = resolve;
      img.src = images[i].dataUrl;
    });
    const col = i % cols;
    const row = Math.floor(i / cols);
    ctx.drawImage(img, col * size, row * size, size, size);
  }
  
  const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
  const filename = `_merged_${Date.now()}.jpg`;
  return { dataUrl, filename };
};

// dataUrlã‚’Blobã«å¤‰æ›
const dataUrlToBlob = (dataUrl) => {
  const [header, data] = dataUrl.split(',');
  const mime = header.match(/:(.*?);/)[1];
  const bin = atob(data);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return new Blob([arr], { type: mime });
};

// ãƒ•ã‚©ãƒ«ãƒ€ã«ç”»åƒã‚’ä¿å­˜
const saveImageToFolder = async (dirHandle, filename, dataUrl) => {
  try {
    const blob = dataUrlToBlob(dataUrl);
    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
    return true;
  } catch (e) {
    console.error('ç”»åƒä¿å­˜ã‚¨ãƒ©ãƒ¼:', e);
    return false;
  }
};

// ã‚¢ã‚¤ã‚³ãƒ³
const Icon = ({ name, className = "w-5 h-5" }) => {
  const icons = {
    upload: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />,
    file: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />,
    key: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z" />,
    image: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />,
    check: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />,
    x: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />,
    refresh: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />,
    left: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />,
    right: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />,
    scan: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z" />,
    eye: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />,
    eyeOff: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />,
    search: <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />,
  };
  return <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">{icons[name]}</svg>;
};

// DropZoneã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const DropZone = ({ title, icon, color, accept, multiple, directory, onFiles, hint }) => {
  const [isDragging, setIsDragging] = useState(false);
  const inputRef = useRef(null);
  const fileInputRef = useRef(null);
  const dragCounter = useRef(0);
  
  const handleDragIn = (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current++;
    if (dragCounter.current === 1) {
      setIsDragging(true);
    }
  };
  
  const handleDragOut = (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current--;
    if (dragCounter.current === 0) {
      setIsDragging(false);
    }
  };
  
  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  const handleDrop = async (e) => {
    e.preventDefault();
    e.stopPropagation();
    dragCounter.current = 0;
    setIsDragging(false);
    
    const items = e.dataTransfer.items;
    const droppedFiles = e.dataTransfer.files;
    const files = [];
    
    console.log('Drop event - items:', items?.length, 'files:', droppedFiles?.length);
    
    // webkitGetAsEntryãŒä½¿ãˆã‚‹å ´åˆï¼ˆãƒ•ã‚©ãƒ«ãƒ€å¯¾å¿œï¼‰
    let entryError = false;
    if (items && items.length > 0) {
      const entries = [];
      for (let i = 0; i < items.length; i++) {
        if (items[i].webkitGetAsEntry) {
          const entry = items[i].webkitGetAsEntry();
          if (entry) entries.push(entry);
        }
      }
      
      if (entries.length > 0) {
        for (const entry of entries) {
          try {
            const entryFiles = await readEntry(entry);
            if (entryFiles.length > 0) {
              files.push(...entryFiles);
            } else if (entry.isDirectory) {
              // ãƒ•ã‚©ãƒ«ãƒ€ãªã®ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå–å¾—ã§ããªã‹ã£ãŸ
              entryError = true;
            }
          } catch (err) {
            console.error('readEntry error:', err);
            entryError = true;
          }
        }
      }
    }
    
    // fallback: é€šå¸¸ã®ãƒ•ã‚¡ã‚¤ãƒ«
    if (files.length === 0 && droppedFiles.length > 0) {
      console.log('Using fallback file handling');
      for (let i = 0; i < droppedFiles.length; i++) {
        const f = droppedFiles[i];
        // ãƒ•ã‚©ãƒ«ãƒ€ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆsize=0, type=ç©ºï¼‰
        if (f.size === 0 && f.type === '') {
          console.log('Detected folder in fallback, skipping:', f.name);
          entryError = true;
          continue;
        }
        // webkitRelativePathãŒãªã„å ´åˆã¯åå‰ã‚’ã‚»ãƒƒãƒˆ
        if (!f.webkitRelativePath) {
          Object.defineProperty(f, 'webkitRelativePath', {
            value: f.name,
            writable: false,
            configurable: true
          });
        }
        files.push(f);
      }
    }
    
    console.log('Processed files:', files.length, files.slice(0,5).map(f => f.webkitRelativePath || f.name));
    
    if (files.length > 0) {
      onFiles(files);
    } else if (entryError) {
      // ãƒ•ã‚©ãƒ«ãƒ€ãƒ‰ãƒ­ãƒƒãƒ—ãŒå¤±æ•—ã—ãŸå ´åˆ
      alert('âš ï¸ ãƒ•ã‚©ãƒ«ãƒ€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\næ—¥æœ¬èªãƒ•ã‚©ãƒ«ãƒ€åã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§å¯¾å¿œã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚\n\nã€å¯¾å‡¦æ³•ã€‘\nãƒ»ä¸‹ã®ã€Œãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã€ãƒœã‚¿ãƒ³ã‚’ä½¿ã†\nãƒ»ã¾ãŸã¯ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç›´æ¥ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—');
    } else {
      console.warn('No files found after processing drop');
    }
  };
  
  const readEntry = async (entry, path = '') => {
    return new Promise(async (resolve) => {
      const files = [];
      
      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ10ç§’ï¼‰
      const timeout = setTimeout(() => {
        console.warn('readEntry timeout for:', path + entry.name);
        resolve(files);
      }, 10000);
      
      try {
        if (entry.isFile) {
          entry.file((file) => {
            clearTimeout(timeout);
            // webkitRelativePathã‚’æ¨¡å€£
            Object.defineProperty(file, 'webkitRelativePath', {
              value: path + file.name,
              writable: false,
              configurable: true
            });
            files.push(file);
            resolve(files);
          }, (err) => {
            clearTimeout(timeout);
            console.error('file() error:', err);
            resolve(files);
          });
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const readAllEntries = async () => {
            return new Promise((res, rej) => {
              const results = [];
              const readBatch = () => {
                reader.readEntries((batch) => {
                  if (batch.length === 0) {
                    res(results);
                  } else {
                    results.push(...batch);
                    readBatch();
                  }
                }, (err) => {
                  console.error('readEntries error:', err);
                  // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ä»Šã¾ã§å–å¾—ã—ãŸåˆ†ã¯è¿”ã™
                  rej(err);
                });
              };
              readBatch();
            });
          };
          
          try {
            const entries = await readAllEntries();
            for (const child of entries) {
              const childFiles = await readEntry(child, path + entry.name + '/');
              files.push(...childFiles);
            }
          } catch (err) {
            // readAllEntriesã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆï¼ˆæ—¥æœ¬èªãƒ•ã‚©ãƒ«ãƒ€åãªã©ï¼‰
            console.error('Failed to read directory:', entry.name, err);
          }
          clearTimeout(timeout);
          resolve(files);
        } else {
          clearTimeout(timeout);
          resolve(files);
        }
      } catch (err) {
        clearTimeout(timeout);
        console.error('readEntry catch error:', err);
        resolve(files);
      }
    });
  };
  
  const handleClick = () => {
    if (directory) {
      inputRef.current?.click();
    } else {
      inputRef.current?.click();
    }
  };
  
  const handleFileClick = (e) => {
    e.stopPropagation();
    fileInputRef.current?.click();
  };
  
  const handleChange = (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length > 0) {
      onFiles(files);
    }
  };
  
  const colorClasses = {
    blue: { border: 'hover:border-blue-400', icon: 'text-blue-500', dragBg: 'bg-blue-50 border-blue-400' },
    green: { border: 'hover:border-green-400', icon: 'text-green-500', dragBg: 'bg-green-50 border-green-400' },
    red: { border: 'hover:border-red-400', icon: 'text-red-500', dragBg: 'bg-red-50 border-red-400' },
    orange: { border: 'hover:border-orange-400', icon: 'text-orange-500', dragBg: 'bg-orange-50 border-orange-400' },
  };
  const c = colorClasses[color] || colorClasses.blue;
  
  return (
    <div 
      className="bg-white rounded shadow p-4"
      onDragEnter={handleDragIn}
      onDragLeave={handleDragOut}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
    >
      <h3 className="font-bold mb-3 flex items-center gap-2">
        <Icon name={icon} className={`w-5 h-5 ${c.icon}`}/>{title}
      </h3>
      <div
        onClick={handleClick}
        className={`border-2 border-dashed rounded p-4 text-center cursor-pointer transition-all ${isDragging ? c.dragBg : `border-gray-300 ${c.border}`}`}
      >
        <Icon name="upload" className="w-6 h-6 mx-auto mb-1 text-gray-400"/>
        <span className="text-sm text-gray-600">{isDragging ? 'ãƒ‰ãƒ­ãƒƒãƒ—ï¼' : (hint || 'ã‚¯ãƒªãƒƒã‚¯ or ãƒ‰ãƒ©ãƒƒã‚°')}</span>
        {directory && (
          <input
            ref={inputRef}
            type="file"
            accept={accept}
            multiple={multiple}
            webkitdirectory=""
            directory=""
            className="hidden"
            onChange={handleChange}
          />
        )}
        {!directory && (
          <input
            ref={inputRef}
            type="file"
            accept={accept}
            multiple={multiple}
            className="hidden"
            onChange={handleChange}
          />
        )}
      </div>
      {directory && (
        <div className="mt-2 flex gap-2">
          <button
            onClick={handleClick}
            className="flex-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 py-1 px-2 rounded border"
          >
            ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ
          </button>
          <button
            onClick={handleFileClick}
            className="flex-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 py-1 px-2 rounded border"
          >
            ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
          </button>
        </div>
      )}
      {directory && (
        <input
          ref={fileInputRef}
          type="file"
          accept={accept}
          multiple={true}
          className="hidden"
          onChange={handleChange}
        />
      )}
    </div>
  );
};

// ãƒ¡ã‚¤ãƒ³App
function App() {
  const [step, setStep] = useState(1);
  const [apiKey, setApiKey] = useState(localStorage.getItem('openai_key') || '');
  const [outputDirHandle, setOutputDirHandle] = useState(null); // ç”»åƒä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€
  const [purchaseData, setPurchaseData] = useState([]);
  const [priceData, setPriceData] = useState([]);

  const [products, setProducts] = useState([]);
  const [currentIdx, setCurrentIdx] = useState(0);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [dragIdx, setDragIdx] = useState(null);
  const [selectedImages, setSelectedImages] = useState([]);
  const [imageHistory, setImageHistory] = useState([]); // å±¥æ­´ï¼ˆUndoç”¨ï¼‰
  const [zoomImage, setZoomImage] = useState(null); // æ‹¡å¤§è¡¨ç¤ºç”¨
  // ä¿è¨¼æ–‡ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆç·¨é›†å¯èƒ½ï¼‰
  const [noticeText, setNoticeText] = useState(() => localStorage.getItem('mercari_notice_text') || DEFAULT_NOTICE_TEXT);
  const [showNoticeEditor, setShowNoticeEditor] = useState(false);

  // æ¤œç´¢URLæ§‹ç¯‰
  const buildSearchQuery = (p) => {
    const s = p.specs || {};
    const parts = [s.maker, s.cpu, s.memory, s.storage].filter(Boolean);
    if (s.model) parts.unshift(s.model);
    return parts.join(' ').trim();
  };
  const buildYahooUrl = (query) => {
    const q = encodeURIComponent(query);
    return `https://auctions.yahoo.co.jp/closedsearch/closedsearch?p=${q}&va=${q}&b=1&n=50`;
  };
  const buildMercariUrl = (query) => {
    const q = encodeURIComponent(query);
    return `https://jp.mercari.com/search?keyword=${q}&status=sold_out&sort=created_time&order=desc`;
  };

  // å†™çœŸæŒ¯ã‚Šåˆ†ã‘ãƒ¢ãƒ¼ãƒ‰
  const [sorterMode, setSorterMode] = useState(false);
  const [sorterPhotos, setSorterPhotos] = useState([]);
  const [sorterSplits, setSorterSplits] = useState(new Set());
  const [sorterBarcodes, setSorterBarcodes] = useState(new Set()); // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç”»åƒã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const [sorterManualBC, setSorterManualBC] = useState(false); // æ‰‹å‹•BCé¸æŠãƒ¢ãƒ¼ãƒ‰
  const [sorterSelected, setSorterSelected] = useState(-1);
  const [sorterPreview, setSorterPreview] = useState(null);

  // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«localStorageã‹ã‚‰å¾©å…ƒ
  useEffect(() => {
    try {
      const savedPurchase = localStorage.getItem('mercari_purchase_data');
      const savedPrice = localStorage.getItem('mercari_price_data');
      if (savedPurchase) {
        const data = JSON.parse(savedPurchase);
        setPurchaseData(data);
        console.log(`ä»•å…¥ãƒ‡ãƒ¼ã‚¿å¾©å…ƒ: ${data.length}ä»¶`);
      }
      if (savedPrice) {
        const data = JSON.parse(savedPrice);
        setPriceData(data);
        console.log(`ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿å¾©å…ƒ: ${data.length}ä»¶`);
      }
    } catch (e) {
      console.error('ãƒ‡ãƒ¼ã‚¿å¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
    }
  }, []);

  // ä»•å…¥ãƒ‡ãƒ¼ã‚¿å¤‰æ›´æ™‚ã«ä¿å­˜
  useEffect(() => {
    if (purchaseData.length > 0) {
      try {
        localStorage.setItem('mercari_purchase_data', JSON.stringify(purchaseData));
        console.log(`ä»•å…¥ãƒ‡ãƒ¼ã‚¿ä¿å­˜: ${purchaseData.length}ä»¶`);
      } catch (e) {
        console.error('ä»•å…¥ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã‚¨ãƒ©ãƒ¼:', e);
      }
    }
  }, [purchaseData]);

  // ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿å¤‰æ›´æ™‚ã«ä¿å­˜
  useEffect(() => {
    if (priceData.length > 0) {
      try {
        localStorage.setItem('mercari_price_data', JSON.stringify(priceData));
        console.log(`ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ä¿å­˜: ${priceData.length}ä»¶`);
      } catch (e) {
        console.error('ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã‚¨ãƒ©ãƒ¼:', e);
      }
    }
  }, [priceData]);

  // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢é–¢æ•°
  const clearSavedData = () => {
    if (confirm('ä¿å­˜ã•ã‚ŒãŸCSVãƒ»ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
      localStorage.removeItem('mercari_purchase_data');
      localStorage.removeItem('mercari_price_data');
      setPurchaseData([]);
      setPriceData([]);
      setMessage('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
    }
  };

  // APIã‚­ãƒ¼ä¿å­˜
  const saveApiKey = () => {
    localStorage.setItem('openai_key', apiKey);
    setMessage('APIã‚­ãƒ¼ä¿å­˜å®Œäº†');
  };

  // APIãƒ†ã‚¹ãƒˆ
  const testApi = async () => {
    if (!apiKey) return setMessage('âŒ APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    setLoading(true);
    setMessage('ãƒ†ã‚¹ãƒˆä¸­...');
    try {
      const r = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
        body: JSON.stringify({ model: 'gpt-4.1-mini', messages: [{ role: 'user', content: 'Say OK' }], max_completion_tokens: 50 })
      });
      const d = await r.json();
      if (d.error) {
        setMessage(`âŒ ${d.error.message}`);
      } else {
        setMessage(`âœ… gpt-4.1-mini: æ¥ç¶šOKï¼`);
      }
    } catch (e) {
      setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${e.message}`);
    }
    setLoading(false);
  };

  // ä»•å…¥CSVèª­è¾¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«é…åˆ—ã‚’å—ã‘å–ã‚‹ï¼‰
  const handlePurchaseFiles = (files) => {
    const all = [];
    let done = 0;
    files.forEach(f => {
      const reader = new FileReader();
      reader.onload = (ev) => {
        Papa.parse(ev.target.result, {
          header: true, skipEmptyLines: true,
          complete: (r) => {
            all.push(...r.data);
            if (++done === files.length) {
              setPurchaseData(all);
              setMessage(`ä»•å…¥CSV: ${all.length}ä»¶`);
            }
          }
        });
      };
      reader.readAsText(f, 'Shift_JIS');
    });
  };

  // ä¾¡æ ¼Excelèª­è¾¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«é…åˆ—ã‚’å—ã‘å–ã‚‹ï¼‰
  const handlePriceFiles = (files) => {
    const all = [];
    let done = 0;
    files.forEach(f => {
      const reader = new FileReader();
      reader.onload = (ev) => {
        const wb = XLSX.read(new Uint8Array(ev.target.result), { type: 'array' });
        const json = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]);
        all.push(...json);
        if (++done === files.length) {
          setPriceData(all);
          setMessage(`ä¾¡æ ¼: ${all.length}ä»¶`);
        }
      };
      reader.readAsArrayBuffer(f);
    });
  };

  // è‡ªå‹•ä¾¡æ ¼è¨ˆç®—: ä»•å…¥åŸä¾¡ â†’ è²©å£²ä¾¡æ ¼
  // å¼: è²©å£²ä¾¡æ ¼ = ROUND((ä»•å…¥åŸä¾¡ + é€æ–™1500 + æ¢±åŒ…æ1000) / (1 - æ‰‹æ•°æ–™0.1 - åˆ©ç›Šç‡0.2), 0)
  //    = ROUND((ä»•å…¥åŸä¾¡ + 2500) / 0.7, 0)
  const calcSellingPrice = (purchaseCost) => {
    if (!purchaseCost || isNaN(purchaseCost) || purchaseCost <= 0) return null;
    return Math.round((purchaseCost + 2500) / 0.7);
  };

  // ç”»åƒèª­è¾¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«é…åˆ—ã‚’å—ã‘å–ã‚‹ - ãƒ•ã‚©ãƒ«ãƒ€ã§ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ç›´æ¥ã§ã‚‚OKï¼‰
  const handleImageFiles = async (files) => {
    console.log('handleImageFiles called with', files.length, 'files');
    setLoading(true);
    setMessage('ç”»åƒèª­è¾¼ä¸­...');
    const map = {};
    
    for (const f of files) {
      const path = f.webkitRelativePath || f.name;
      console.log('Processing file:', path, 'type:', f.type, 'size:', f.size);
      
      const parts = path.split('/');
      let folder, name;
      
      if (parts.length >= 2) {
        // ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ãŒã‚ã‚‹å ´åˆ
        folder = parts[parts.length - 2];
        name = parts[parts.length - 1];
      } else {
        // ãƒ•ã‚¡ã‚¤ãƒ«ç›´æ¥ã®å ´åˆï¼šãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ‹¡å¼µå­ã‚’é™¤ã„ãŸéƒ¨åˆ†ã‚’ãƒ•ã‚©ãƒ«ãƒ€åã«
        // ã¾ãŸã¯æ•°å­—éƒ¨åˆ†ã§ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°
        name = f.name;
        // ãƒ•ã‚¡ã‚¤ãƒ«åã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è§£æï¼ˆä¾‹: 001_01.jpg â†’ 001ãŒãƒ•ã‚©ãƒ«ãƒ€ï¼‰
        const match = name.match(/^(\d+)[_-]/);
        if (match) {
          folder = match[1];
        } else {
          // ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒãªã„å ´åˆã¯æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«å
          folder = name.replace(/\.[^.]+$/, '');
        }
      }
      
      const ext = name.split('.').pop().toLowerCase();
      if (!['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext)) {
        console.log('Skipping non-image file:', name);
        continue;
      }
      
      if (!map[folder]) map[folder] = [];
      
      try {
        const dataUrl = await new Promise((resolve, reject) => {
          const rd = new FileReader();
          rd.onload = e => resolve(e.target.result);
          rd.onerror = e => reject(e);
          rd.readAsDataURL(f);
        });
        map[folder].push({ id: `${folder}_${name}`, filename: name, dataUrl, excluded: false });
      } catch (err) {
        console.error('FileReader error for', name, err);
      }
    }
    
    console.log('Grouped into folders:', Object.keys(map));
    
    const prods = Object.entries(map).sort().map(([folder, imgs]) => ({
      id: folder, folder, images: imgs.sort((a, b) => a.filename.localeCompare(b.filename)), barcode: null
    }));
    
    if (prods.length === 0) {
      setMessage('ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      setLoading(false);
      return;
    }
    
    setProducts(prods);
    setMessage(`${prods.length}å•†å“`);
    setStep(2);
    setLoading(false);
  };

  // === å†™çœŸæŒ¯ã‚Šåˆ†ã‘ãƒ¢ãƒ¼ãƒ‰ ===
  // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç”»åƒè‡ªå‹•æ¤œå‡ºï¼ˆãƒ–ãƒ©ã‚¦ã‚¶BarcodeDetector API â†’ é«˜é€Ÿãƒ»ç„¡æ–™ï¼‰
  const detectBarcodesInPhotos = async (photos) => {
    const barcodeSet = new Set();
    
    // BarcodeDetector APIå¯¾å¿œãƒã‚§ãƒƒã‚¯
    const hasBarcodeAPI = typeof BarcodeDetector !== 'undefined';
    let detector = null;
    if (hasBarcodeAPI) {
      try { detector = new BarcodeDetector({ formats: ['code_128', 'code_39', 'ean_13', 'ean_8', 'qr_code', 'itf', 'codabar'] }); }
      catch(e) { console.warn('BarcodeDetectoråˆæœŸåŒ–å¤±æ•—:', e); }
    }
    
    if (detector) {
      // ãƒ–ãƒ©ã‚¦ã‚¶å†…æ¤œå‡ºï¼ˆä¸¦åˆ—å‡¦ç†ã€è¶…é«˜é€Ÿï¼‰
      const concurrency = 10;
      for (let b = 0; b < photos.length; b += concurrency) {
        const batch = photos.slice(b, Math.min(b + concurrency, photos.length));
        if (b % 100 === 0) setMessage(`ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ¤œå‡ºä¸­ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰... ${Math.min(b + concurrency, photos.length)}/${photos.length}`);
        
        const promises = batch.map((photo, bi) => {
          const idx = b + bi;
          return new Promise(resolve => {
            const img = new Image();
            img.onload = async () => {
              try {
                // å°ã•ã„canvasã§é«˜é€ŸåŒ–
                const canvas = document.createElement('canvas');
                const scale = Math.min(1, 800 / Math.max(img.width, img.height));
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const barcodes = await detector.detect(canvas);
                if (barcodes.length > 0) resolve(idx);
                else resolve(null);
              } catch(e) { resolve(null); }
            };
            img.onerror = () => resolve(null);
            img.src = photo.dataUrl;
          });
        });
        
        const results = await Promise.all(promises);
        results.forEach(idx => { if (idx !== null) barcodeSet.add(idx); });
      }
      setMessage(`âœ… ãƒ­ãƒ¼ã‚«ãƒ«æ¤œå‡ºå®Œäº†: ${barcodeSet.size}æšã®ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç™ºè¦‹`);
    } else if (apiKey) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: GPT APIï¼ˆBarcodeDetectoréå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ç”¨ï¼‰
      const batchSize = 20;
      for (let b = 0; b < photos.length; b += batchSize) {
        const batch = photos.slice(b, b + batchSize);
        setMessage(`ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ¤œå‡ºä¸­ï¼ˆAPIï¼‰... ${Math.min(b + batchSize, photos.length)}/${photos.length}`);
        try {
          const imageContents = batch.map(p => ({
            type: 'image_url',
            image_url: { url: p.dataUrl, detail: 'low' }
          }));
          const r = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
              model: 'gpt-4.1-mini',
              messages: [{ role: 'user', content: [
                { type: 'text', text: `${batch.length}æšã®ç”»åƒãŒã‚ã‚Šã¾ã™ã€‚å„ç”»åƒãŒãƒãƒ¼ã‚³ãƒ¼ãƒ‰/ãƒ©ãƒ™ãƒ«ã®ç”»åƒã‹ã©ã†ã‹åˆ¤å®šã—ã¦ãã ã•ã„ã€‚ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ»ã‚·ãƒªã‚¢ãƒ«ãƒŠãƒ³ãƒãƒ¼ãƒ©ãƒ™ãƒ«ãƒ»ç®¡ç†ç•ªå·ã‚·ãƒ¼ãƒ«ã®ç”»åƒãªã‚‰1ã€ãã‚Œä»¥å¤–ï¼ˆPCæœ¬ä½“ãƒ»ç”»é¢ãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ç­‰ï¼‰ãªã‚‰0ã€‚\nJSONé…åˆ—ã®ã¿å‡ºåŠ›: [0,1,0,...]` },
                ...imageContents
              ] }],
              max_completion_tokens: 200
            })
          });
          const d = await r.json();
          if (!d.error) {
            const text = d.choices[0].message.content.trim();
            const arrMatch = text.match(/\[[\d\s,]+\]/);
            if (arrMatch) {
              const arr = JSON.parse(arrMatch[0]);
              arr.forEach((v, i) => { if (v === 1) barcodeSet.add(b + i); });
            }
          }
        } catch (e) { console.error('ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', e); }
      }
    } else {
      setMessage('âš ï¸ æ‰‹å‹•ã§åŒºåˆ‡ã£ã¦ãã ã•ã„ï¼ˆBarcodeDetectoréå¯¾å¿œãƒ»APIã‚­ãƒ¼æœªè¨­å®šï¼‰');
    }
    
    return barcodeSet;
  };

  const handleSorterFiles = async (files) => {
    setLoading(true);
    setMessage('å†™çœŸèª­è¾¼ä¸­...');
    const validFiles = Array.from(files).filter(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return ['jpg','jpeg','png','gif','webp'].includes(ext);
    });
    if (validFiles.length === 0) { setMessage('ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); setLoading(false); return; }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«åé †ã‚½ãƒ¼ãƒˆ
    validFiles.sort((a,b) => a.name.localeCompare(b.name));
    
    // ãƒãƒƒãƒèª­è¾¼ï¼ˆãƒ¡ãƒ¢ãƒªç®¡ç† + é€²æ—è¡¨ç¤ºï¼‰
    const photos = [];
    const readBatch = 50;
    for (let b = 0; b < validFiles.length; b += readBatch) {
      const batch = validFiles.slice(b, b + readBatch);
      if (b % 200 === 0) setMessage(`å†™çœŸèª­è¾¼ä¸­... ${Math.min(b + readBatch, validFiles.length)}/${validFiles.length}`);
      const results = await Promise.all(batch.map(f => new Promise(resolve => {
        const rd = new FileReader();
        rd.onload = e => resolve({ id: f.name, filename: f.name, dataUrl: e.target.result, file: f });
        rd.onerror = () => resolve(null);
        rd.readAsDataURL(f);
      })));
      results.forEach(r => { if (r) photos.push(r); });
    }
    
    setMessage(`${photos.length}æšèª­è¾¼å®Œäº†ã€ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ¤œå‡ºä¸­...`);
    setSorterPhotos(photos);
    setSorterSplits(new Set());
    setSorterBarcodes(new Set());
    setSorterManualBC(false);
    setSorterSelected(-1);
    setSorterMode(true);

    // è‡ªå‹•ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ¤œå‡º
    const bcSet = await detectBarcodesInPhotos(photos);
    setSorterBarcodes(bcSet);
    if (bcSet.size > 0) {
      const autoSplits = new Set();
      Array.from(bcSet).sort((a,b) => a - b).forEach(idx => {
        if (idx + 1 < photos.length) autoSplits.add(idx + 1);
      });
      setSorterSplits(autoSplits);
      setMessage(`âœ… ${bcSet.size}æšã®ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’æ¤œå‡ºã€${autoSplits.size}ã‚°ãƒ«ãƒ¼ãƒ—ã«è‡ªå‹•åˆ†å‰²`);
    } else {
      setMessage('ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æœªæ¤œå‡ºã€‚æ‰‹å‹•ã§åŒºåˆ‡ã£ã¦ãã ã•ã„');
      setSorterManualBC(true);
    }
    setLoading(false);
  };

  const sorterToggleSplit = () => {
    if (sorterSelected < 0 || sorterSelected >= sorterPhotos.length - 1) return;
    const sp = sorterSelected + 1;
    setSorterSplits(prev => {
      const n = new Set(prev);
      n.has(sp) ? n.delete(sp) : n.add(sp);
      return n;
    });
  };

  const sorterUndoSplit = () => {
    setSorterSplits(prev => {
      if (prev.size === 0) return prev;
      const sorted = Array.from(prev).sort((a,b) => b - a);
      const n = new Set(prev);
      n.delete(sorted[0]);
      return n;
    });
  };

  const sorterGetGroups = () => {
    const sorted = [0, ...Array.from(sorterSplits).sort((a,b) => a - b)];
    return sorted.map((start, i) => {
      const end = i + 1 < sorted.length ? sorted[i + 1] : sorterPhotos.length;
      return { start, end, count: end - start, photos: sorterPhotos.slice(start, end) };
    });
  };

  const sorterFinish = async () => {
    setLoading(true);
    setMessage('ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆä¸­...');
    const groups = sorterGetGroups();
    const prods = groups.map((g, i) => {
      const folder = `PC_${String(i+1).padStart(3,'0')}`;
      const bcPhotoIdx = g.photos.findIndex((_, pi) => sorterBarcodes.has(g.start + pi));
      return {
        id: folder, folder,
        images: g.photos.map((p, pi) => ({ 
          id: p.id, filename: p.filename, dataUrl: p.dataUrl, excluded: false,
          isBarcode: sorterBarcodes.has(g.start + pi)
        })),
        barcode: null,
        _bcPhotoIdx: bcPhotoIdx >= 0 ? bcPhotoIdx : g.photos.length - 1
      };
    });
    
    // APIã‚­ãƒ¼ãŒã‚ã‚Œã°ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç”»åƒã‚’è‡ªå‹•OCR
    if (apiKey) {
      setMessage('ãƒãƒ¼ã‚³ãƒ¼ãƒ‰è‡ªå‹•èª­å–ä¸­...');
      for (let i = 0; i < prods.length; i++) {
        const p = prods[i];
        const bcImg = p.images[p._bcPhotoIdx];
        if (bcImg) {
          try {
            setMessage(`ãƒãƒ¼ã‚³ãƒ¼ãƒ‰èª­å–ä¸­... ${i+1}/${prods.length}`);
            const bc = await ocrBarcode(apiKey, bcImg.dataUrl);
            if (bc) p.barcode = bc;
          } catch (e) { console.error('OCRã‚¨ãƒ©ãƒ¼:', e); }
        }
      }
      
      // è‡ªå‹•ä¸¦ã³æ›¿ãˆï¼†çµåˆ
      for (let i = 0; i < prods.length; i++) {
        setMessage(`ç”»åƒåˆ†é¡ï¼†ä¸¦æ›¿ä¸­... ${i+1}/${prods.length}`);
        const p = prods[i];
        const activeImgs = p.images.filter(img => !img.excluded);
        if (activeImgs.length < 2) continue;
        try {
          const classifications = await classifyImages(apiKey, activeImgs);
          if (!classifications) continue;
          
          const byCategory = { main: [], screen: [], keyboard: [], side: [], battery: [], spec: [], barcode: [], other: [] };
          classifications.forEach(c => {
            const img = activeImgs[c.index];
            if (img && byCategory[c.category]) byCategory[c.category].push(img);
            else if (img) byCategory.other.push(img);
          });
          
          // ä¸¦ã³é †: main(2) â†’ screen(2) â†’ keyboard(1) â†’ side(çµåˆ) â†’ battery(1) â†’ spec(çµåˆ) â†’ other â†’ barcode
          const sorted = [];
          const toMerge = [];
          
          sorted.push(...byCategory.main.slice(0, 2));
          if (byCategory.main.length > 2) byCategory.other.push(...byCategory.main.slice(2));
          
          if (byCategory.screen.length <= 2) { sorted.push(...byCategory.screen); }
          else { sorted.push(...byCategory.screen.slice(0, 1)); toMerge.push({ name: 'screen', imgs: byCategory.screen.slice(1) }); }
          
          sorted.push(...byCategory.keyboard.slice(0, 1));
          if (byCategory.keyboard.length > 1) byCategory.other.push(...byCategory.keyboard.slice(1));
          
          if (byCategory.side.length >= 2) {
            toMerge.push({ name: 'side', imgs: byCategory.side.slice(0, 4) });
            if (byCategory.side.length > 4) byCategory.other.push(...byCategory.side.slice(4));
          } else { sorted.push(...byCategory.side); }
          
          sorted.push(...byCategory.battery.slice(0, 1));
          if (byCategory.battery.length > 1) byCategory.other.push(...byCategory.battery.slice(1));
          
          if (byCategory.spec.length >= 2) { toMerge.push({ name: 'spec', imgs: byCategory.spec }); }
          else { sorted.push(...byCategory.spec); }
          
          sorted.push(...byCategory.other);
          
          for (const item of toMerge) {
            if (item.imgs.length >= 2) {
              const { dataUrl, filename } = await mergeImages(item.imgs, 2);
              sorted.push({ id: `merged_${Date.now()}_${item.name}`, filename, dataUrl, excluded: false });
            }
          }
          
          sorted.push(...byCategory.barcode);
          
          const mergedIds = new Set(toMerge.flatMap(t => t.imgs.map(im => im.id)));
          const excludedImgs = p.images.filter(img => img.excluded || mergedIds.has(img.id)).map(img => ({ ...img, excluded: true }));
          p.images = [...sorted, ...excludedImgs];
        } catch (e) { console.error('autoSortã‚¨ãƒ©ãƒ¼:', e); }
      }
    }
    
    prods.forEach(p => delete p._bcPhotoIdx);
    
    setProducts(prods);
    setSorterMode(false);
    const ocrCount = prods.filter(p => p.barcode).length;
    setMessage(`âœ… ${prods.length}å•†å“ã«æŒ¯ã‚Šåˆ†ã‘ã€${ocrCount}ä»¶BCèª­å–ã€ç”»åƒè‡ªå‹•æ•´ç†å®Œäº†`);
    setStep(2);
    setLoading(false);
  };

  // OCR
  const doOcr = async (idx) => {
    const p = products[idx];
    if (!p.images.length || !apiKey) return;
    setLoading(true);
    try {
      const bc = await ocrBarcode(apiKey, p.images[p.images.length - 1].dataUrl);
      if (bc) {
        const np = [...products];
        np[idx].barcode = bc;
        setProducts(np);
        setMessage(`OCRæˆåŠŸ: ${bc}`);
      } else {
        alert('èª­å–å¤±æ•—: ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      }
    } catch (e) {
      console.error('OCR Error:', e);
      alert('èª­å–å¤±æ•—: ' + e.message);
    }
    setLoading(false);
  };

  const doOcrAll = async () => {
    if (!apiKey) return alert('APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„');
    setLoading(true);
    let successCount = 0;
    for (let i = 0; i < products.length; i++) {
      if (products[i].barcode) continue;
      try {
        const bc = await ocrBarcode(apiKey, products[i].images[products[i].images.length - 1].dataUrl);
        if (bc) {
          const np = [...products];
          np[i].barcode = bc;
          setProducts(np);
          successCount++;
        }
      } catch (e) {
        console.error('OCR error for product', i, e);
      }
    }
    setMessage(`OCRå®Œäº†: ${successCount}ä»¶æˆåŠŸ`);
    setLoading(false);
  };

  // ç”»åƒä¸¦ã³æ›¿ãˆ
  const moveImage = (from, to) => {
    const p = products[currentIdx];
    const imgs = [...p.images];
    const [moved] = imgs.splice(from, 1);
    imgs.splice(to, 0, moved);
    const np = [...products];
    np[currentIdx] = { ...p, images: imgs };
    setProducts(np);
  };

  const toggleExclude = (imgIdx) => {
    const np = [...products];
    np[currentIdx].images[imgIdx].excluded = !np[currentIdx].images[imgIdx].excluded;
    setProducts(np);
  };

  // è‡ªå‹•ç”»åƒä¸¦ã³æ›¿ãˆ
  // ãƒ‡ãƒ¼ã‚¿å‡¦ç†
  const processProducts = () => {
    setLoading(true);
    // å˜å“ãƒ‡ãƒ¼ã‚¿ã‚’å„ªå…ˆï¼ˆã€Œä»–ã€ãŒã¤ã„ã¦ãªã„ã‚‚ã®ï¼‰
    const findPurchase = (bc) => {
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      const matches = purchaseData.filter(r => {
        const v = String(r['ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç•ªå·'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
      if (matches.length === 0) return null;
      // ã€Œä»–ã€ãŒãªã„ã‚‚ã®ï¼ˆå˜å“ï¼‰ã‚’å„ªå…ˆ
      const single = matches.find(r => !String(r['ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç•ªå·'] || '').includes('ä»–'));
      return single || matches[0];
    };
    // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç•ªå·ã®ä¸‹6æ¡ã§ä¾¡æ ¼ã‚’ç…§åˆ
    const findPrice = (bc) => {
      const bcNorm = bc.replace(/[^0-9]/g, '').padStart(6, '0').slice(-6);
      return priceData.find(r => {
        const v = String(r['ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç•ªå·'] || '').replace(/[^0-9]/g, '');
        return v.length >= 6 && v.slice(-6).padStart(6, '0') === bcNorm;
      });
    };

    const np = products.map(p => {
      if (!p.barcode) return { ...p, status: 'no_barcode' };
      // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ï¼ˆå…ˆé ­ã‚¼ãƒ­ä¿æŒã€6æ¡ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
      const bcRaw = p.barcode.replace(/[^0-9]/g, '');
      const barcode = bcRaw ? bcRaw.padStart(6, '0').slice(-6) : '';
      if (!barcode) return { ...p, status: 'no_barcode' };
      const row = findPurchase(barcode);
      if (!row) return { ...p, barcode, status: 'no_data' };
      const specs = extractSpecs(row);
      const type = detectProductType(row, specs);
      const priceRow = findPrice(barcode);
      let price = priceRow ? parseInt(priceRow['ãƒ¡ãƒ«ã‚«ãƒªè²©å£²ä¾¡æ ¼(å…¥åŠ›)']) || null : null;
      // ä¾¡æ ¼Excelã«ç„¡ã‘ã‚Œã°ä»•å…¥åŸä¾¡ã‹ã‚‰è‡ªå‹•è¨ˆç®—
      const purchaseCost = parseInt(row['æˆç´„é‡‘é¡']) || parseInt(row['è‡ªç¤¾å…¥æœ­é‡‘é¡']) || null;
      if (!price && purchaseCost) {
        price = calcSellingPrice(purchaseCost);
      }
      const rank = String(row['è©•ä¾¡ç‚¹'] || '').trim().toUpperCase();
      const acc = parseAccessories(row['ä»˜å±å“æƒ…å ±'] || '');
      const accessories = acc.length > 0 ? acc : ['ã‚ã‚Š'];
      const defect = [row['ç‘•ç–µæƒ…å ±1'], row['ç‘•ç–µæƒ…å ±2']].filter(x => x && !x.includes('ä¸­å¤å“ã®ç‚º')).join('ã€');
      return {
        ...p, barcode, status: 'ok', specs, product_type: type, price, purchaseCost, rank,
        condition: CONDITION_MAP[rank] || 'ã‚„ã‚„å‚·ã‚„æ±šã‚Œã‚ã‚Š',
        accessories: accessories, defect_info: defect,
        is_english_kb: (row['ä»˜å±å“æƒ…å ±'] || '').includes('è‹±å­—KB'),
        hasOffice: p.hasOffice || false,  // OFFICEæ­è¼‰ãƒ•ãƒ©ã‚°ã‚’ä¿æŒ
        isJunk: p.isJunk || false  // ã‚¸ãƒ£ãƒ³ã‚¯å“ãƒ•ãƒ©ã‚°ã‚’ä¿æŒ
      };
    });
    setProducts(np);
    setStep(3);
    setLoading(false);
  };

  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»é¢ã¸ï¼ˆç´¹ä»‹æ–‡ç”Ÿæˆï¼‰
  const goToPreview = async () => {
    setLoading(true);
    setMessage('ç´¹ä»‹æ–‡ç”Ÿæˆä¸­...');
    const np = [...products];
    
    for (let i = 0; i < np.length; i++) {
      if (!np[i].barcode || np[i].intro) continue;
      try {
        np[i].intro = apiKey ? await generateIntro(apiKey, np[i]) : `${np[i].specs?.maker || ''}ã®ä¸­å¤PCã§ã™ã€‚`;
        // ã‚¿ã‚¤ãƒˆãƒ«ã¨èª¬æ˜æ–‡ã‚‚äº‹å‰ç”Ÿæˆ
        np[i].title = np[i].title || makeTitle(np[i]);
        np[i].description = np[i].description || makeDescription(np[i], noticeText);
        setProducts([...np]);
        setMessage(`ç´¹ä»‹æ–‡ç”Ÿæˆä¸­... (${i+1}/${np.length})`);
      } catch (e) {
        console.error('ç´¹ä»‹æ–‡ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', e);
        np[i].intro = `${np[i].specs?.maker || ''}ã®ä¸­å¤PCã§ã™ã€‚`;
        np[i].title = np[i].title || makeTitle(np[i]);
        np[i].description = np[i].description || makeDescription(np[i], noticeText);
      }
    }
    
    // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã‚ã‚‹å•†å“ã®ã‚¿ã‚¤ãƒˆãƒ«ãƒ»èª¬æ˜æ–‡ã‚’ç”Ÿæˆ
    np.forEach(p => {
      if (p.barcode && !p.title) p.title = makeTitle(p);
      if (p.barcode && !p.description) p.description = makeDescription(p, noticeText);
    });
    
    setProducts(np);
    setCurrentIdx(0);
    setStep(4);
    setLoading(false);
    setMessage('');
  };

  // CSVç”Ÿæˆ
  // å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€é¸æŠ
  const pickOutputFolder = async () => {
    try {
      const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
      setOutputDirHandle(handle);
      setMessage(`ğŸ“ ä¿å­˜å…ˆ: ${handle.name}`);
      return handle;
    } catch (e) {
      if (e.name !== 'AbortError') setMessage('âŒ ãƒ•ã‚©ãƒ«ãƒ€é¸æŠå¤±æ•—');
      return null;
    }
  };

  // å…¨å•†å“ã®ç”»åƒã‚’ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜
  const saveAllImages = async () => {
    let dir = outputDirHandle;
    if (!dir) {
      dir = await pickOutputFolder();
      if (!dir) return;
    }
    setLoading(true);
    const okProducts = products.filter(p => p.barcode);
    let saved = 0;
    for (let pi = 0; pi < okProducts.length; pi++) {
      const p = okProducts[pi];
      const folderName = `${p.barcode}_${(p.specs?.maker || 'PC').replace(/[\\/:*?"<>|]/g, '')}`;
      setMessage(`ğŸ“ ä¿å­˜ä¸­... ${pi + 1}/${okProducts.length} (${folderName})`);
      try {
        const subDir = await dir.getDirectoryHandle(folderName, { create: true });
        const activeImgs = p.images.filter((img, i) => i < p.images.length - 1 && !img.excluded);
        for (let i = 0; i < Math.min(activeImgs.length, 10); i++) {
          const fname = `${String(i + 1).padStart(2, '0')}_${activeImgs[i].filename || `img_${i}.jpg`}`;
          await saveImageToFolder(subDir, fname, activeImgs[i].dataUrl);
          saved++;
        }
      } catch (e) { console.error(`ä¿å­˜ã‚¨ãƒ©ãƒ¼ (${folderName}):`, e); }
    }
    setLoading(false);
    setMessage(`âœ… ${okProducts.length}å•†å“ / ${saved}æšã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
  };

  const generateCsv = async () => {
    setLoading(true);
    setMessage('CSVç”Ÿæˆä¸­...');
    
    // ãƒ¡ãƒ«ã‚«ãƒªCSVãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆæ­£ã—ã„é †åºï¼‰
    const headers = [
      ...Array.from({length:20}, (_,i) => `å•†å“ç”»åƒå_${i+1}`),
      'å•†å“å', 'å•†å“èª¬æ˜',
      'SKU1_ç¨®é¡', 'SKU1_åœ¨åº«æ•°', 'SKU1_å•†å“ç®¡ç†ã‚³ãƒ¼ãƒ‰', 'SKU1_JANã‚³ãƒ¼ãƒ‰',
      'ãƒ–ãƒ©ãƒ³ãƒ‰ID', 'è²©å£²ä¾¡æ ¼', 'ã‚«ãƒ†ã‚´ãƒªID', 'å•†å“ã®çŠ¶æ…‹',
      'é…é€æ–¹æ³•', 'ç™ºé€å…ƒã®åœ°åŸŸ', 'ç™ºé€ã¾ã§ã®æ—¥æ•°', 'å•†å“ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹', 'é…é€æ–™ã®è² æ‹…'
    ];
    
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Œã°OKã€ä¾¡æ ¼ãªã—ã¯999999ï¼‰
    const okProducts = products.filter(p => p.barcode);
    
    const rows = okProducts.map(p => {
      // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç”»åƒé™¤ãã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ãã®ã¾ã¾ä½¿ç”¨ã€æœ€å¤§20æšï¼‰
      const imgs = p.images
        .filter((img, i) => i < p.images.length - 1 && !img.excluded)
        .slice(0, 20)
        .map(img => img.filename);  // å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ãã®ã¾ã¾ä½¿ç”¨
      while (imgs.length < 20) imgs.push('');
      
      const cat = ['intel_mac', 'apple_silicon'].includes(p.product_type) ? CONFIG.category_macbook : CONFIG.category_windows;
      const conditionCode = CONFIG.condition_map[p.condition] || 4;
      const price = p.price || 999999;  // ä¾¡æ ¼ãŒãªã‘ã‚Œã°999999
      
      return [
        ...imgs,                           // å•†å“ç”»åƒå_1ï½20
        p.title || makeTitle(p),           // å•†å“åï¼ˆç·¨é›†æ¸ˆã¿ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ï¼‰
        p.description || makeDescription(p, noticeText), // å•†å“èª¬æ˜ï¼ˆç·¨é›†æ¸ˆã¿ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ï¼‰
        '',                                // SKU1_ç¨®é¡
        1,                                 // SKU1_åœ¨åº«æ•°
        '',                                // SKU1_å•†å“ç®¡ç†ã‚³ãƒ¼ãƒ‰ï¼ˆç©ºï¼‰
        '',                                // SKU1_JANã‚³ãƒ¼ãƒ‰
        '',                                // ãƒ–ãƒ©ãƒ³ãƒ‰ID
        price,                             // è²©å£²ä¾¡æ ¼
        cat,                               // ã‚«ãƒ†ã‚´ãƒªID
        conditionCode,                     // å•†å“ã®çŠ¶æ…‹
        CONFIG.shipping_method,            // é…é€æ–¹æ³•
        CONFIG.region,                     // ç™ºé€å…ƒã®åœ°åŸŸ
        CONFIG.shipping_days,              // ç™ºé€ã¾ã§ã®æ—¥æ•°
        1,                                 // å•†å“ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆ1=ä¸‹æ›¸ãï¼‰
        CONFIG.shipping_fee                // é…é€æ–™ã®è² æ‹…
      ];
    });
    
    // CSVç”Ÿæˆï¼ˆShift-JISã€æ”¹è¡Œã¯ãã®ã¾ã¾ï¼‰
    const escapeForCsv = (str) => {
      const s = String(str);
      // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
      if (s.includes('"') || s.includes(',') || s.includes('\n') || s.includes('\r')) {
        return '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    };
    
    const csvContent = [headers, ...rows].map(r => r.map(c => escapeForCsv(c)).join(',')).join('\r\n');
    
    // Shift-JISã«å¤‰æ›ã—ã¦Blobä½œæˆ
    const unicodeArray = Encoding.stringToCode(csvContent);
    const sjisArray = Encoding.convert(unicodeArray, { to: 'SJIS', from: 'UNICODE' });
    const blob = new Blob([new Uint8Array(sjisArray)], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `mercari_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    setMessage(`${rows.length}å•†å“ã®CSVã‚’ç”Ÿæˆã—ã¾ã—ãŸ`);
    setStep(5);
    setLoading(false);
  };

  const cur = products[currentIdx];

  return (
    <div className="min-h-screen bg-gray-100">
      <header className="bg-red-500 text-white py-3 px-6 shadow">
        <h1 className="text-xl font-bold">ãƒ¡ãƒ«ã‚«ãƒªCSVç”Ÿæˆãƒ„ãƒ¼ãƒ«</h1>
      </header>

      <div className="max-w-6xl mx-auto p-4">
        {/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */}
        <div className="bg-white rounded shadow p-3 mb-4 flex gap-6 text-sm items-center">
          <span>ä»•å…¥: <b>{purchaseData.length}</b></span>
          <span>ä¾¡æ ¼: <b>{priceData.length}</b></span>
          <span>API: {apiKey ? 'âœ“' : 'æœªè¨­å®š'}</span>
          <span className="text-purple-600">ğŸ¤– gpt-4.1-mini</span>
          {(purchaseData.length > 0 || priceData.length > 0) && (
            <button onClick={clearSavedData} className="text-red-500 hover:text-red-700 text-xs">ğŸ—‘ï¸ ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢</button>
          )}
          <span className="ml-auto text-gray-500">Step {step}/5</span>
          <button onClick={() => setShowNoticeEditor(true)} className="text-gray-500 hover:text-gray-700 text-xs ml-2">ğŸ“ ä¿è¨¼æ–‡</button>
          {sorterPhotos.length > 0 && !sorterMode && (
            <button onClick={() => setSorterMode(true)} className="text-blue-500 hover:text-blue-700 text-xs ml-2">ğŸ“· æŒ¯ã‚Šåˆ†ã‘å†é–‹</button>
          )}
        </div>

        {message && <div className={`px-4 py-2 rounded mb-4 border ${message.startsWith('âŒ') ? 'bg-red-50 border-red-200 text-red-700' : message.startsWith('âœ…') ? 'bg-green-50 border-green-200 text-green-700' : 'bg-blue-50 border-blue-200 text-blue-700'}`}>{message}</div>}

        {/* Step 1 */}
        {step === 1 && (
          <div>
            {/* ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®è¡¨ç¤º */}
            {(purchaseData.length > 0 || priceData.length > 0) && (
              <div className="bg-green-50 border border-green-200 rounded p-3 mb-4 text-sm">
                <span className="font-medium text-green-700">ğŸ’¾ ä¿å­˜æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿: </span>
                {purchaseData.length > 0 && <span className="mr-3">ä»•å…¥CSV {purchaseData.length}ä»¶</span>}
                {priceData.length > 0 && <span className="mr-3">ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ {priceData.length}ä»¶</span>}
                <span className="text-green-600 ml-2">ï¼ˆè‡ªå‹•å¾©å…ƒæ¸ˆã¿ï¼‰</span>
              </div>
            )}
            <div className="grid grid-cols-2 lg:grid-cols-5 gap-4">
              <DropZone
                title="ä»•å…¥CSV"
                icon="file"
                color="blue"
                accept=".csv"
                multiple={true}
                onFiles={handlePurchaseFiles}
              />
              <DropZone
                title="ä¾¡æ ¼Excel"
                icon="file"
                color="green"
                accept=".xlsx,.xls,.csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel"
                multiple={true}
                onFiles={handlePriceFiles}
              />
              <div className="bg-white rounded shadow p-4">
                <h3 className="font-bold mb-3 flex items-center gap-2"><Icon name="key" className="w-5 h-5 text-purple-500"/>OpenAI API</h3>
                <input type="password" placeholder="sk-..." value={apiKey} onChange={e => setApiKey(e.target.value)} className="w-full border rounded px-2 py-1 mb-2 text-sm"/>
                <div className="flex gap-2">
                  <button onClick={saveApiKey} className="flex-1 bg-purple-500 text-white rounded py-1 text-sm hover:bg-purple-600">ä¿å­˜</button>
                  <button onClick={testApi} disabled={loading} className="flex-1 bg-blue-500 text-white rounded py-1 text-sm hover:bg-blue-600 disabled:opacity-50">ãƒ†ã‚¹ãƒˆ</button>
                </div>
              </div>
              <DropZone
                title="ç”»åƒ"
                icon="image"
                color="red"
                accept="image/*"
                multiple={true}
                directory={true}
                onFiles={handleImageFiles}
                hint="ãƒ‰ãƒ©ãƒƒã‚° or ä¸‹ã®ãƒœã‚¿ãƒ³"
              />
              <DropZone
                title="å†™çœŸæŒ¯ã‚Šåˆ†ã‘"
                icon="image"
                color="blue"
                accept="image/*"
                multiple={true}
                directory={true}
                onFiles={handleSorterFiles}
                hint="æœªæ•´ç†å†™çœŸã‚’ãƒ‰ãƒ­ãƒƒãƒ—"
              />
            </div>
            {/* å•†å“ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã€Step2ã«æˆ»ã‚Œã‚‹ãƒœã‚¿ãƒ³ */}
            {products.length > 0 && (
              <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded flex items-center justify-between">
                <span className="text-yellow-800">ğŸ“¦ ç·¨é›†ä¸­ã®å•†å“ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ï¼ˆ{products.length}ä»¶ï¼‰</span>
                <button onClick={() => setStep(2)} className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600">
                  Step2ã«æˆ»ã‚‹ â†’
                </button>
              </div>
            )}
          </div>
        )}

        {/* Step 2: ç”»åƒç·¨é›† */}
        {step === 2 && cur && (() => {
          const activeImages = cur.images.filter(img => !img.excluded);
          const excludedImages = cur.images.filter(img => img.excluded);
          const uploadCount = activeImages.length > 0 ? activeImages.length - 1 : 0; // ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ä»¥å¤–
          
          // å±¥æ­´ã«ä¿å­˜ã™ã‚‹é–¢æ•°
          const saveHistory = () => {
            setImageHistory(prev => [...prev, JSON.parse(JSON.stringify(cur.images))]);
          };
          
          // Undoé–¢æ•°
          const undoMerge = () => {
            if (imageHistory.length === 0) return;
            const np = [...products];
            np[currentIdx].images = imageHistory[imageHistory.length - 1];
            setProducts(np);
            setImageHistory(prev => prev.slice(0, -1));
          };
          
          return (
          <div className="bg-white rounded shadow">
            <div className="border-b p-4 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <button onClick={() => { setCurrentIdx(Math.max(0, currentIdx-1)); setImageHistory([]); setSelectedImages([]); }} disabled={currentIdx===0} className="p-1 rounded hover:bg-gray-100 disabled:opacity-30"><Icon name="left"/></button>
                <span className="font-bold">{currentIdx+1}/{products.length}</span>
                <button onClick={() => { setCurrentIdx(Math.min(products.length-1, currentIdx+1)); setImageHistory([]); setSelectedImages([]); }} disabled={currentIdx===products.length-1} className="p-1 rounded hover:bg-gray-100 disabled:opacity-30"><Icon name="right"/></button>
                <span className="text-gray-500">{cur.folder}</span>
                {cur.barcode && <span className="bg-green-100 text-green-700 px-2 py-0.5 rounded text-sm">{cur.barcode}</span>}
                <label className="flex items-center gap-1 ml-4 cursor-pointer">
                  <input 
                    type="checkbox" 
                    checked={cur.hasOffice || false}
                    onChange={e => { const np = [...products]; np[currentIdx].hasOffice = e.target.checked; setProducts(np); }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-medium text-blue-600">ğŸ“¦ OFFICEæ­è¼‰</span>
                </label>
                <label className="flex items-center gap-1 ml-2 cursor-pointer">
                  <input 
                    type="checkbox" 
                    checked={cur.isJunk || false}
                    onChange={e => { const np = [...products]; np[currentIdx].isJunk = e.target.checked; setProducts(np); }}
                    className="w-4 h-4"
                  />
                  <span className="text-sm font-medium text-red-600">âš ï¸ ã‚¸ãƒ£ãƒ³ã‚¯å“</span>
                </label>
              </div>
              <div className="flex items-center gap-2">
                <span className={`text-sm font-bold ${uploadCount <= 10 ? 'text-green-600' : 'text-red-600'}`}>
                  å‡ºå“ç”»åƒ: {uploadCount}æš {uploadCount > 10 && 'âš ï¸ 10æšä»¥ä¸‹ã«ã—ã¦ãã ã•ã„'}
                </span>
                <button onClick={doOcrAll} disabled={loading} className="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600 disabled:opacity-50">
                  {loading ? 'å‡¦ç†ä¸­...' : 'å…¨OCR'}
                </button>
              </div>
            </div>

            <div className="flex">
              {/* å•†å“ãƒªã‚¹ãƒˆ */}
              <div className="w-44 border-r bg-gray-50 p-2 max-h-[600px] overflow-y-auto">
                {products.map((p, i) => {
                  const pActive = p.images.filter(img => !img.excluded);
                  const pUpload = pActive.length > 0 ? pActive.length - 1 : 0;
                  return (
                  <button key={p.id} onClick={() => { setCurrentIdx(i); setSelectedImages([]); setImageHistory([]); }} className={`w-full text-left px-2 py-1 rounded text-sm truncate ${i === currentIdx ? 'bg-blue-500 text-white' : 'hover:bg-gray-200'}`}>
                    {i+1}. {p.folder} {p.barcode && 'âœ“'} <span className={pUpload > 10 ? 'text-red-400' : ''}>[{pUpload}]</span>
                  </button>
                  );
                })}
              </div>

              {/* ãƒ¡ã‚¤ãƒ³ç·¨é›†ã‚¨ãƒªã‚¢ */}
              <div className="flex-1 p-4 overflow-y-auto max-h-[600px]">
                {/* å‡ºå“ç”»åƒï¼ˆãƒãƒ¼ã‚³ãƒ¼ãƒ‰ä»¥å¤–ï¼‰ */}
                <div className="mb-4">
                  <div className="flex items-center gap-2 mb-2 flex-wrap">
                    <h4 className="font-bold text-sm">ğŸ“· å‡ºå“ç”»åƒï¼ˆæœ€å¾Œã®1æš=ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ï¼‰</h4>
                    <span className="text-xs text-gray-500">ã‚¯ãƒªãƒƒã‚¯:é¸æŠ / ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯:æ‹¡å¤§</span>
                    {selectedImages.length >= 2 && (
                      <button onClick={async () => {
                        saveHistory();
                        const selected = selectedImages.map(idx => cur.images.find((img, i) => i === idx)).filter(Boolean);
                        if (selected.length < 2) return;
                        const cols = selected.length <= 2 ? 2 : 2;
                        const { dataUrl, filename } = await mergeImages(selected, cols);
                        const np = [...products];
                        const newImg = { id: `merged_${Date.now()}`, filename, dataUrl, excluded: false };
                        // å…ƒã®ä½ç½®ï¼ˆæœ€åˆã«é¸æŠã—ãŸç”»åƒã®ä½ç½®ï¼‰ã«æŒ¿å…¥
                        const firstIdx = Math.min(...selectedImages);
                        const newImages = cur.images.map((img, i) => selectedImages.includes(i) ? {...img, excluded: true} : img);
                        newImages.splice(firstIdx, 0, newImg);
                        np[currentIdx].images = newImages;
                        setProducts(np);
                        setSelectedImages([]);
                      }} className="px-2 py-1 bg-blue-500 text-white rounded text-xs">
                        {selectedImages.length}æšã‚’çµåˆ
                      </button>
                    )}
                    {selectedImages.length > 0 && (
                      <button onClick={() => setSelectedImages([])} className="px-2 py-1 bg-gray-300 text-gray-700 rounded text-xs">é¸æŠè§£é™¤</button>
                    )}
                    {imageHistory.length > 0 && (
                      <button onClick={undoMerge} className="px-2 py-1 bg-yellow-500 text-white rounded text-xs">â†© æˆ»ã™ ({imageHistory.length})</button>
                    )}
                  </div>
                  <div className="flex flex-wrap gap-2">
                    {cur.images.map((img, i) => {
                      if (img.excluded) return null;
                      const activeIdx = activeImages.indexOf(img);
                      const isBarcode = activeIdx === activeImages.length - 1;
                      const isSelected = selectedImages.includes(i);
                      const displayNum = activeIdx + 1;
                      return (
                      <div key={img.id} 
                        draggable={!isBarcode}
                        onDragStart={() => !isBarcode && setDragIdx(i)} 
                        onDragOver={e => e.preventDefault()} 
                        onDrop={() => { if (dragIdx !== null && dragIdx !== i) moveImage(dragIdx, i); setDragIdx(null); }}
                        onClick={() => {
                          if (isBarcode) {
                            setZoomImage(img.dataUrl);
                          } else if (isSelected) {
                            setSelectedImages(selectedImages.filter(x => x !== i));
                          } else {
                            setSelectedImages([...selectedImages, i]);
                          }
                        }}
                        onDoubleClick={() => !isBarcode && setZoomImage(img.dataUrl)}
                        className={`relative cursor-pointer ${isSelected ? 'ring-4 ring-blue-500' : ''} ${isBarcode ? 'ring-2 ring-red-400' : ''}`}>
                        <img src={img.dataUrl} className={`w-24 h-24 object-cover rounded border-2 ${isBarcode ? 'border-red-400' : 'border-gray-200'}`}/>
                        <span className={`absolute top-1 left-1 text-xs px-1 rounded ${isBarcode ? 'bg-red-500 text-white' : 'bg-black/50 text-white'}`}>{isBarcode ? 'ğŸ”BC' : displayNum}</span>
                        {isSelected && <span className="absolute top-1 right-1 bg-blue-500 text-white text-xs w-5 h-5 flex items-center justify-center rounded-full font-bold">{selectedImages.indexOf(i) + 1}</span>}
                        <button onClick={(e) => { e.stopPropagation(); toggleExclude(i); }} className="absolute bottom-1 right-1 bg-white rounded-full p-0.5 opacity-70 hover:opacity-100">
                          <Icon name="eyeOff" className="w-3 h-3"/>
                        </button>
                      </div>
                      );
                    })}
                  </div>
                </div>

                {/* é™¤å¤–ç”»åƒ */}
                {excludedImages.length > 0 && (
                <div className="mb-4">
                  <h4 className="font-bold text-sm mb-2 text-gray-400">ğŸš« é™¤å¤–æ¸ˆã¿ï¼ˆ{excludedImages.length}æšï¼‰- ã‚¯ãƒªãƒƒã‚¯ã§å¾©å…ƒ</h4>
                  <div className="flex flex-wrap gap-2">
                    {cur.images.map((img, i) => {
                      if (!img.excluded) return null;
                      return (
                      <div key={img.id} className="relative opacity-50 cursor-pointer hover:opacity-80" onClick={() => toggleExclude(i)}>
                        <img src={img.dataUrl} className="w-20 h-20 object-cover rounded border-2 border-gray-300 grayscale"/>
                        <button onClick={(e) => { e.stopPropagation(); toggleExclude(i); }} className="absolute top-1 right-1 bg-white rounded-full p-0.5">
                          <Icon name="eye" className="w-3 h-3"/>
                        </button>
                      </div>
                      );
                    })}
                  </div>
                </div>
                )}
              </div>

              {/* å³ãƒ‘ãƒãƒ« */}
              <div className="w-56 border-l p-4 bg-gray-50">
                <label className="block text-sm font-medium mb-1">ãƒãƒ¼ã‚³ãƒ¼ãƒ‰</label>
                <div className="flex gap-1 mb-3">
                  <input type="text" value={cur.barcode || ''} onChange={e => { const np = [...products]; np[currentIdx].barcode = e.target.value; setProducts(np); }} className="flex-1 border rounded px-2 py-1 text-sm"/>
                  <button onClick={() => doOcr(currentIdx)} disabled={loading} className="px-2 py-1 bg-blue-500 text-white rounded text-sm"><Icon name="scan" className="w-4 h-4"/></button>
                </div>
                <label className="block text-sm font-medium mb-1">å……æ”¾é›»å›æ•°</label>
                <input type="text" value={cur.cycle_count || ''} onChange={e => { const np = [...products]; np[currentIdx].cycle_count = e.target.value; setProducts(np); }} className="w-full border rounded px-2 py-1 text-sm mb-3"/>
                <label className="block text-sm font-medium mb-1">ãƒãƒƒãƒ†ãƒªãƒ¼(%)</label>
                <input type="text" value={cur.battery_health || ''} onChange={e => { const np = [...products]; np[currentIdx].battery_health = e.target.value; setProducts(np); }} className="w-full border rounded px-2 py-1 text-sm mb-4"/>
                
                <hr className="my-3"/>
                <p className="text-xs text-gray-500 mb-2">ç”»åƒçµåˆ</p>
                <p className="text-xs mb-2">{selectedImages.length > 0 ? <span className="text-blue-600 font-bold">{selectedImages.length}æšé¸æŠä¸­</span> : <span className="text-gray-400">ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠ</span>}</p>
                <button disabled={selectedImages.length < 2} onClick={async () => {
                  const selImgs = selectedImages.sort((a,b) => a - b).map(i => cur.images[i]).filter(img => img && !img.excluded);
                  if (selImgs.length < 2) return;
                  saveHistory();
                  const cols = 2;
                  const { dataUrl, filename } = await mergeImages(selImgs, cols);
                  const np = [...products];
                  const newImg = { id: `merged_${Date.now()}`, filename, dataUrl, excluded: false };
                  const mergedIds = selImgs.map(img => img.id);
                  const firstIdx = cur.images.findIndex(img => img.id === selImgs[0].id);
                  const newImages = cur.images.map(img => mergedIds.includes(img.id) ? {...img, excluded: true} : img);
                  newImages.splice(firstIdx, 0, newImg);
                  np[currentIdx].images = newImages;
                  setProducts(np);
                  setSelectedImages([]);
                }} className="w-full mb-2 px-2 py-1 bg-orange-500 text-white rounded text-sm disabled:opacity-40">
                  {selectedImages.length < 2 ? '2æšä»¥ä¸Šé¸æŠ' : `${selectedImages.length}æšâ†’1æš`}
                </button>
                {selectedImages.length > 0 && <button onClick={() => setSelectedImages([])} className="w-full mb-2 px-2 py-1 bg-gray-400 text-white rounded text-xs">é¸æŠè§£é™¤</button>}
                {imageHistory.length > 0 && (
                  <button onClick={undoMerge} className="w-full px-2 py-1 bg-yellow-500 text-white rounded text-sm">â†© æˆ»ã™ ({imageHistory.length})</button>
                )}
              </div>
            </div>

            <div className="border-t p-4 flex justify-between">
              <button onClick={() => setStep(1)} className="px-4 py-2 border rounded hover:bg-gray-50">æˆ»ã‚‹</button>
              <button onClick={processProducts} className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">æ¬¡ã¸</button>
            </div>
          </div>
          );
        })()}

        {/* Step 3: ä¾¡æ ¼ç¢ºèª */}
        {step === 3 && (
          <div className="bg-white rounded shadow p-4">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-bold">ä¾¡æ ¼ç¢ºèª</h2>
              <span className="text-xs text-gray-500">ğŸ’¡ ä¾¡æ ¼Excelæœªè¨­å®šæ™‚ã¯ä»•å…¥åŸä¾¡ã‹ã‚‰è‡ªå‹•è¨ˆç®—ï¼ˆåˆ©ç›Š20%+æ‰‹æ•°æ–™10%+é€æ–™Â¥1,500+æ¢±åŒ…Â¥1,000ï¼‰</span>
            </div>
            <table className="w-full text-sm">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-3 py-2 text-left">ãƒ•ã‚©ãƒ«ãƒ€</th>
                  <th className="px-3 py-2 text-left">BCï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†ï¼‰</th>
                  <th className="px-3 py-2 text-left">å•†å“</th>
                  <th className="px-3 py-2 text-right">ä»•å…¥</th>
                  <th className="px-3 py-2 text-right">è²©å£²ä¾¡æ ¼</th>
                  <th className="px-3 py-2 text-center">ç›¸å ´</th>
                  <th className="px-3 py-2">çŠ¶æ…‹</th>
                </tr>
              </thead>
              <tbody>
                {products.map((p, i) => {
                  const activeImgs = p.images.filter(img => !img.excluded);
                  const bcImg = activeImgs.length > 0 ? activeImgs[activeImgs.length - 1] : null;
                  const hasPrice = p.price && p.price > 0;
                  const profit = hasPrice && p.purchaseCost ? p.price - Math.round(p.price * 0.1) - 1500 - 1000 - p.purchaseCost : null;
                  const profitRate = profit && p.price ? Math.round(profit / p.price * 100) : null;
                  const rowBg = p.status !== 'ok' ? 'bg-red-50' : (!hasPrice ? 'bg-yellow-50' : (i % 2 ? 'bg-gray-50' : ''));
                  return (
                  <tr key={p.id} className={rowBg}>
                    <td className="px-3 py-2">{p.folder}</td>
                    <td className="px-3 py-2">
                      <div className="flex items-center gap-2">
                        {bcImg && (
                          <img 
                            src={bcImg.dataUrl} 
                            className="w-12 h-12 object-cover rounded cursor-pointer hover:opacity-80 border"
                            onClick={() => { setCurrentIdx(i); setZoomImage(bcImg.dataUrl); }}
                            title="ã‚¯ãƒªãƒƒã‚¯ã§æ‹¡å¤§ãƒ»ç·¨é›†"
                          />
                        )}
                        <span className={`font-mono ${p.barcode ? '' : 'text-gray-400'}`}>{p.barcode || 'æœªå…¥åŠ›'}</span>
                      </div>
                    </td>
                    <td className="px-3 py-2">{p.specs?.maker} {p.specs?.product_name}</td>
                    <td className="px-3 py-2 text-right text-gray-500">
                      {p.purchaseCost ? `Â¥${p.purchaseCost.toLocaleString()}` : '-'}
                    </td>
                    <td className="px-3 py-2 text-right">
                      <div className="flex items-center justify-end gap-1">
                        <input type="number" value={p.price || ''} onChange={e => { const np = [...products]; np[i].price = parseInt(e.target.value) || null; setProducts(np); }} placeholder="999999" className={`w-24 border rounded px-2 py-1 text-right ${!hasPrice ? 'border-yellow-400 bg-yellow-50' : ''}`}/>
                      </div>
                      {profit !== null && (
                        <div className={`text-xs mt-0.5 ${profit > 0 ? 'text-green-600' : 'text-red-500'}`}>
                          åˆ©ç›Š Â¥{profit.toLocaleString()} ({profitRate}%)
                        </div>
                      )}
                    </td>
                    <td className="px-2 py-2 text-center">
                      {p.status === 'ok' && (() => {
                        const q = buildSearchQuery(p);
                        return q ? (
                          <div className="flex gap-1 justify-center">
                            <a href={buildYahooUrl(q)} target="_blank" rel="noopener" className="px-1.5 py-0.5 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200" title={`ãƒ¤ãƒ•ã‚ªã‚¯: ${q}`}>Y!</a>
                            <a href={buildMercariUrl(q)} target="_blank" rel="noopener" className="px-1.5 py-0.5 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200" title={`ãƒ¡ãƒ«ã‚«ãƒª: ${q}`}>M</a>
                          </div>
                        ) : null;
                      })()}
                    </td>
                    <td className="px-3 py-2 text-center">
                      {p.status !== 'ok' ? (
                        <Icon name="x" className="w-5 h-5 text-red-400 mx-auto" title="ãƒ‡ãƒ¼ã‚¿ãªã—"/>
                      ) : hasPrice ? (
                        <Icon name="check" className="w-5 h-5 text-green-500 mx-auto" title="OK"/>
                      ) : (
                        <span className="text-yellow-500 font-bold" title="ä¾¡æ ¼ãªã—ï¼ˆ999999ã§å‡ºåŠ›ï¼‰">âš </span>
                      )}
                    </td>
                  </tr>
                  );
                })}
              </tbody>
            </table>
            <div className="flex justify-between mt-4">
              <button onClick={() => setStep(2)} className="px-4 py-2 border rounded">æˆ»ã‚‹</button>
              <div className="flex gap-2">
                <button onClick={processProducts} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">å†ç…§åˆ</button>
                <button onClick={goToPreview} disabled={loading} className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                  {loading ? 'å‡¦ç†ä¸­...' : 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ â†’'}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Step 4: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·¨é›† */}
        {step === 4 && (() => {
          const okProducts = products.filter(p => p.barcode);
          const cur = okProducts[currentIdx] || null;
          const curProductIdx = cur ? products.findIndex(p => p.id === cur.id) : -1;
          const activeImgs = cur ? cur.images.filter((img, i) => i < cur.images.length - 1 && !img.excluded) : [];
          
          // ç”»åƒå…¥ã‚Œæ›¿ãˆé–¢æ•°
          const swapImages = (fromIdx, toIdx) => {
            if (curProductIdx < 0) return;
            const np = [...products];
            const imgs = [...np[curProductIdx].images];
            // activeImgsã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å®Ÿéš›ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›
            const activeToReal = [];
            let ai = 0;
            imgs.forEach((img, i) => {
              if (i < imgs.length - 1 && !img.excluded) {
                activeToReal[ai] = i;
                ai++;
              }
            });
            const realFrom = activeToReal[fromIdx];
            const realTo = activeToReal[toIdx];
            if (realFrom !== undefined && realTo !== undefined) {
              [imgs[realFrom], imgs[realTo]] = [imgs[realTo], imgs[realFrom]];
              np[curProductIdx].images = imgs;
              setProducts(np);
            }
          };
          
          return (
          <div className="bg-white rounded shadow">
            <div className="p-4 border-b flex items-center justify-between">
              <h2 className="text-lg font-bold">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·¨é›†</h2>
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-600">{okProducts.length}å•†å“</span>
                <button onClick={pickOutputFolder} className="px-3 py-1 border rounded text-sm hover:bg-gray-50">
                  ğŸ“ {outputDirHandle ? outputDirHandle.name : 'ä¿å­˜å…ˆ'}
                </button>
                <button onClick={saveAllImages} className="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                  ğŸ’¾ å…¨ç”»åƒä¿å­˜
                </button>
                <button onClick={() => setStep(3)} className="px-3 py-1 border rounded text-sm">æˆ»ã‚‹</button>
                <button onClick={generateCsv} disabled={loading} className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50">
                  {loading ? 'å‡¦ç†ä¸­...' : 'CSVç”Ÿæˆ'}
                </button>
              </div>
            </div>
            
            <div className="flex" style={{height: 'calc(100vh - 220px)'}}>
              {/* å•†å“ãƒªã‚¹ãƒˆ */}
              <div className="w-48 border-r bg-gray-50 overflow-y-auto">
                {okProducts.map((p, i) => (
                  <button 
                    key={p.id} 
                    onClick={() => setCurrentIdx(i)} 
                    className={`w-full text-left px-3 py-2 text-sm border-b ${i === currentIdx ? 'bg-blue-500 text-white' : 'hover:bg-gray-100'}`}
                  >
                    <div className="font-medium truncate">{p.specs?.maker || 'Unknown'}</div>
                    <div className="text-xs opacity-75 truncate">{p.barcode}</div>
                  </button>
                ))}
              </div>
              
              {/* ç·¨é›†ã‚¨ãƒªã‚¢ */}
              {cur && (
                <div className="flex-1 overflow-y-auto p-4">
                  {/* ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå…¥ã‚Œæ›¿ãˆãƒ»æ‹¡å¤§å¯èƒ½ï¼‰ */}
                  <div className="mb-4">
                    <div className="flex items-center gap-2 mb-2">
                      <span className="text-sm font-medium">ğŸ“· å‡ºå“ç”»åƒ</span>
                      <span className="text-xs text-gray-500">ãƒ‰ãƒ©ãƒƒã‚°ã§å…¥ã‚Œæ›¿ãˆ / ã‚¯ãƒªãƒƒã‚¯ã§æ‹¡å¤§</span>
                    </div>
                    <div className="flex gap-2 overflow-x-auto pb-2">
                      {activeImgs.slice(0, 10).map((img, i) => (
                        <div 
                          key={i}
                          draggable
                          onDragStart={e => e.dataTransfer.setData('text/plain', i.toString())}
                          onDragOver={e => e.preventDefault()}
                          onDrop={e => {
                            e.preventDefault();
                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                            if (fromIdx !== i) swapImages(fromIdx, i);
                          }}
                          className="relative flex-shrink-0 cursor-move"
                        >
                          <img 
                            src={img.dataUrl} 
                            className="w-20 h-20 object-cover rounded border hover:border-blue-400"
                            onClick={() => setZoomImage(img.dataUrl)}
                          />
                          <span className="absolute bottom-0 left-0 bg-black/60 text-white text-xs px-1 rounded-tr">{i+1}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                  
                  {/* ã‚¿ã‚¤ãƒˆãƒ« */}
                  <div className="mb-4">
                    <div className="flex items-center justify-between mb-1">
                      <label className="font-medium text-sm">ã‚¿ã‚¤ãƒˆãƒ«</label>
                      <span className={`text-xs ${(cur.title || '').length > 65 ? 'text-red-500' : 'text-gray-500'}`}>
                        {(cur.title || '').length}/65
                      </span>
                    </div>
                    <input 
                      type="text" 
                      value={cur.title || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].title = e.target.value;
                        setProducts(np); 
                      }} 
                      className={`w-full border rounded px-3 py-2 ${(cur.title || '').length > 65 ? 'border-red-400' : ''}`}
                    />
                  </div>
                  
                  {/* ä¾¡æ ¼ */}
                  <div className="mb-4">
                    <label className="font-medium text-sm block mb-1">ä¾¡æ ¼</label>
                    <input 
                      type="number" 
                      value={cur.price || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].price = parseInt(e.target.value) || null;
                        setProducts(np); 
                      }} 
                      placeholder="999999"
                      className="w-32 border rounded px-3 py-2"
                    />
                    {!cur.price && <span className="ml-2 text-yellow-600 text-sm">âš  ä¾¡æ ¼æœªè¨­å®šï¼ˆ999999ã§å‡ºåŠ›ï¼‰</span>}
                  </div>
                  
                  {/* ä»˜å±å“ */}
                  <div className="mb-4">
                    <label className="font-medium text-sm block mb-1">ä»˜å±å“</label>
                    <div className="flex flex-wrap gap-1.5 mb-2">
                      {['ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼', 'ACã‚³ãƒ¼ãƒ‰', 'MagSafeã‚±ãƒ¼ãƒ–ãƒ«', 'ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰', 'ã‚ã‚Š', 'ãªã—'].map(item => {
                        const has = (cur.accessories || []).includes(item);
                        return (
                          <button key={item} onClick={() => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = [...(np[idx].accessories || [])];
                            if (has) { accs = accs.filter(a => a !== item); }
                            else { if (item === 'ã‚ã‚Š' || item === 'ãªã—') accs = [item]; else { accs = accs.filter(a => a !== 'ã‚ã‚Š' && a !== 'ãªã—'); accs.push(item); } }
                            if (accs.length === 0) accs = ['ã‚ã‚Š'];
                            np[idx].accessories = accs;
                            // èª¬æ˜æ–‡ã®ä»˜å±å“ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚æ›´æ–°
                            if (np[idx].description) {
                              np[idx].description = np[idx].description.replace(/ã€ä»˜å±å“ã€‘\n[^\n]*/, `ã€ä»˜å±å“ã€‘\n${accs.join('ã€')}`);
                            }
                            setProducts(np);
                          }}
                          className={`px-2.5 py-1 rounded-full text-xs border transition-colors ${has ? 'bg-blue-500 text-white border-blue-500' : 'bg-white text-gray-700 border-gray-300 hover:border-blue-400'}`}
                          >{has ? 'âœ“ ' : ''}{item}</button>
                        );
                      })}
                      {/* ã‚«ã‚¹ã‚¿ãƒ ä»˜å±å“ï¼ˆæ—¢å­˜ã®ã†ã¡å®šå‹å¤–ï¼‰ */}
                      {(cur.accessories || []).filter(a => !['ACã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼', 'ACã‚³ãƒ¼ãƒ‰', 'MagSafeã‚±ãƒ¼ãƒ–ãƒ«', 'ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰', 'ã‚ã‚Š', 'ãªã—'].includes(a)).map(item => (
                        <span key={item} className="px-2.5 py-1 rounded-full text-xs bg-green-100 text-green-800 border border-green-300 flex items-center gap-1">
                          {item}
                          <button onClick={() => {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = np[idx].accessories.filter(a => a !== item);
                            if (accs.length === 0) accs = ['ã‚ã‚Š'];
                            np[idx].accessories = accs;
                            if (np[idx].description) np[idx].description = np[idx].description.replace(/ã€ä»˜å±å“ã€‘\n[^\n]*/, `ã€ä»˜å±å“ã€‘\n${accs.join('ã€')}`);
                            setProducts(np);
                          }} className="text-green-600 hover:text-red-500">Ã—</button>
                        </span>
                      ))}
                      {/* è¿½åŠ å…¥åŠ› */}
                      <input
                        type="text" placeholder="+ è¿½åŠ " 
                        className="px-2 py-1 border rounded text-xs w-20"
                        onKeyDown={e => {
                          if (e.key === 'Enter' && e.target.value.trim()) {
                            const np = [...products];
                            const idx = np.findIndex(p => p.id === cur.id);
                            if (idx < 0) return;
                            let accs = [...(np[idx].accessories || [])].filter(a => a !== 'ã‚ã‚Š' && a !== 'ãªã—');
                            const v = e.target.value.trim();
                            if (!accs.includes(v)) accs.push(v);
                            np[idx].accessories = accs;
                            if (np[idx].description) np[idx].description = np[idx].description.replace(/ã€ä»˜å±å“ã€‘\n[^\n]*/, `ã€ä»˜å±å“ã€‘\n${accs.join('ã€')}`);
                            setProducts(np);
                            e.target.value = '';
                          }
                        }}
                      />
                    </div>
                  </div>
                  
                  {/* å•†å“èª¬æ˜ */}
                  <div>
                    <label className="font-medium text-sm block mb-1">å•†å“èª¬æ˜</label>
                    <textarea 
                      value={cur.description || ''} 
                      onChange={e => { 
                        const np = [...products]; 
                        const idx = np.findIndex(p => p.id === cur.id);
                        if (idx >= 0) np[idx].description = e.target.value;
                        setProducts(np); 
                      }} 
                      rows={20}
                      className="w-full border rounded px-3 py-2 text-sm font-mono"
                    />
                  </div>
                </div>
              )}
            </div>
          </div>
          );
        })()}

        {/* Step 5: å®Œäº† */}
        {step === 5 && (
          <div className="bg-white rounded shadow p-8 text-center">
            <Icon name="check" className="w-16 h-16 text-green-500 mx-auto mb-4"/>
            <h2 className="text-xl font-bold mb-2">å®Œäº†ï¼</h2>
            <p className="text-gray-600 mb-6">{message}</p>
            <button onClick={() => { setStep(1); setProducts([]); }} className="text-blue-500 hover:underline">æ–°è¦ä½œæˆ</button>
          </div>
        )}
      </div>

      {/* ä¿è¨¼æ–‡ã‚¨ãƒ‡ã‚£ã‚¿ */}
      {showNoticeEditor && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" onClick={() => setShowNoticeEditor(false)}>
          <div className="bg-white rounded-lg shadow-xl max-w-3xl w-full max-h-[85vh] overflow-hidden" onClick={e => e.stopPropagation()}>
            <div className="p-4 border-b flex items-center justify-between">
              <h3 className="font-bold text-lg">ğŸ“ ä¿è¨¼æ–‡ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç·¨é›†</h3>
              <button onClick={() => setShowNoticeEditor(false)} className="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div className="p-4">
              <textarea
                value={noticeText}
                onChange={e => setNoticeText(e.target.value)}
                rows={18}
                className="w-full border rounded px-3 py-2 text-sm font-mono"
              />
              <div className="flex justify-between mt-3">
                <button onClick={() => { setNoticeText(DEFAULT_NOTICE_TEXT); }} className="px-3 py-1 border rounded text-sm hover:bg-gray-50">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
                <div className="flex gap-2">
                  <button onClick={() => setShowNoticeEditor(false)} className="px-4 py-2 border rounded">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                  <button onClick={() => { localStorage.setItem('mercari_notice_text', noticeText); setShowNoticeEditor(false); setMessage('âœ… ä¿è¨¼æ–‡ã‚’ä¿å­˜ã—ã¾ã—ãŸ'); }} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ä¿å­˜</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {loading && (
        <div className="fixed inset-0 bg-black/30 flex items-center justify-center" style={{zIndex:999}}>
          <div className="bg-white rounded p-6 flex items-center gap-3 shadow-xl">
            <Icon name="refresh" className="w-6 h-6 animate-spin text-blue-500"/>{message || 'å‡¦ç†ä¸­...'}
          </div>
        </div>
      )}

      {/* ç”»åƒæ‹¡å¤§ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {zoomImage && (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setZoomImage(null)}>
          <div className="relative max-w-5xl w-full max-h-[90vh]" onClick={e => e.stopPropagation()}>
            {/* é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ */}
            <button onClick={() => setZoomImage(null)} className="absolute -top-10 right-0 text-white text-3xl hover:text-gray-300">&times;</button>
            
            {/* ç”»åƒ */}
            <img src={zoomImage} className="w-full h-auto rounded-lg" style={{maxHeight: '75vh', objectFit: 'contain'}}/>
            
            {/* ãƒãƒ¼ã‚³ãƒ¼ãƒ‰å…¥åŠ›ï¼ˆä¸‹éƒ¨ï¼‰ */}
            <div className="mt-4 bg-white rounded-lg p-4 flex items-center gap-4">
              <label className="font-medium whitespace-nowrap">ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç•ªå·:</label>
              <input 
                type="text" 
                value={products[currentIdx]?.barcode || ''} 
                onChange={e => { 
                  const np = [...products]; 
                  np[currentIdx].barcode = e.target.value; 
                  setProducts(np); 
                }} 
                placeholder="ä¸‹6æ¡ã‚’å…¥åŠ›ï¼ˆä¾‹: 185660ï¼‰"
                className="flex-1 border-2 border-blue-400 rounded px-3 py-2 text-lg font-mono focus:border-blue-600 focus:outline-none"
              />
              <button 
                onClick={() => setZoomImage(null)} 
                className="px-6 py-2 bg-blue-500 text-white rounded font-medium hover:bg-blue-600"
              >
                OK
              </button>
            </div>
          </div>
        </div>
      )}

      {/* å†™çœŸæŒ¯ã‚Šåˆ†ã‘ãƒ¢ãƒ¼ãƒ‰ */}
      {sorterMode && (() => {
        const groups = sorterGetGroups();
        const currentGroup = groups.find(g => sorterSelected >= g.start && sorterSelected < g.end);
        return (
        <div className="sorter-overlay" onKeyDown={e => {
          if (sorterPreview) {
            if (e.key === 'Escape' || e.key === ' ') { e.preventDefault(); setSorterPreview(null); }
            else if (e.key === 'ArrowLeft' && sorterSelected > 0) { e.preventDefault(); setSorterSelected(s => s-1); setSorterPreview(sorterPhotos[sorterSelected-1]?.dataUrl); }
            else if (e.key === 'ArrowRight' && sorterSelected < sorterPhotos.length-1) { e.preventDefault(); setSorterSelected(s => s+1); setSorterPreview(sorterPhotos[sorterSelected+1]?.dataUrl); }
            return;
          }
          if (e.key === 'ArrowRight') { e.preventDefault(); setSorterSelected(s => Math.min(sorterPhotos.length-1, s+1)); }
          else if (e.key === 'ArrowLeft') { e.preventDefault(); setSorterSelected(s => Math.max(0, s-1)); }
          else if (e.key === 's' || e.key === 'S') { e.preventDefault(); sorterToggleSplit(); }
          else if (e.key === 'b' || e.key === 'B') { e.preventDefault(); if (sorterSelected >= 0) setSorterBarcodes(prev => { const n = new Set(prev); n.has(sorterSelected) ? n.delete(sorterSelected) : n.add(sorterSelected); if (n.size > 0) setSorterManualBC(false); return n; }); }
          else if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); sorterUndoSplit(); }
          else if (e.key === ' ') { e.preventDefault(); if (sorterSelected >= 0) setSorterPreview(sorterPhotos[sorterSelected]?.dataUrl); }
          else if (e.key === 'Escape') { if (confirm('æŒ¯ã‚Šåˆ†ã‘ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ')) setSorterMode(false); }
        }} tabIndex={0} ref={el => el && el.focus()}>
          <div className="sorter-header">
            <h2>ğŸ“· å†™çœŸæŒ¯ã‚Šåˆ†ã‘ãƒ¢ãƒ¼ãƒ‰</h2>
            <div className="sorter-stats">
              <div className="sorter-stat">å†™çœŸ: <b>{sorterPhotos.length}</b></div>
              <div className="sorter-stat">BC: <b style={{color:'#ef4444'}}>{sorterBarcodes.size}</b></div>
              <div className="sorter-stat">PCæ•°: <b>{groups.length}</b></div>
              {currentGroup && <div className="sorter-stat">ç¾åœ¨: <b>{currentGroup.count}</b>æš</div>}
            </div>
          </div>
          <div className="sorter-toolbar">
            <button className="sbtn sbtn-split" onClick={sorterToggleSplit}>âœ‚ ã“ã“ã§åŒºåˆ‡ã‚‹ (S)</button>
            <button className="sbtn" style={{background:'#3b82f6'}} onClick={() => {
              if (sorterSelected < 0) return;
              setSorterBarcodes(prev => {
                const n = new Set(prev);
                n.has(sorterSelected) ? n.delete(sorterSelected) : n.add(sorterSelected);
                if (n.size > 0) setSorterManualBC(false);
                return n;
              });
            }} title="é¸æŠç”»åƒã®ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°åˆ‡æ›¿">ğŸ· BCåˆ‡æ›¿ (B)</button>
            <button className="sbtn" style={{background:'#f59e0b'}} onClick={() => {
              const autoSplits = new Set();
              Array.from(sorterBarcodes).sort((a,b) => a - b).forEach(idx => {
                if (idx + 1 < sorterPhotos.length) autoSplits.add(idx + 1);
              });
              setSorterSplits(autoSplits);
              setMessage(`BCã§${autoSplits.size}ã‚°ãƒ«ãƒ¼ãƒ—ã«åŒºåˆ‡ã‚Šç›´ã—ã¾ã—ãŸ`);
            }} title="ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ä½ç½®ã§åŒºåˆ‡ã‚Šç›´ã™" disabled={sorterBarcodes.size === 0}>âœ‚ BCã§åŒºåˆ‡ã‚Šç›´ã™</button>
            <button className="sbtn" style={{background:'#8b5cf6'}} onClick={async () => {
              if (!apiKey) { setMessage('APIã‚­ãƒ¼æœªè¨­å®š'); return; }
              setLoading(true);
              const bcSet = await detectBarcodesInPhotos(sorterPhotos);
              setSorterBarcodes(bcSet);
              const autoSplits = new Set();
              Array.from(bcSet).sort((a,b) => a - b).forEach(idx => {
                if (idx + 1 < sorterPhotos.length) autoSplits.add(idx + 1);
              });
              setSorterSplits(autoSplits);
              setLoading(false);
              setMessage(`âœ… ${bcSet.size}æšæ¤œå‡ºã€${autoSplits.size}ã‚°ãƒ«ãƒ¼ãƒ—`);
            }} title="ãƒãƒ¼ã‚³ãƒ¼ãƒ‰å†æ¤œå‡º">ğŸ”„ å†æ¤œå‡º</button>
            <button className="sbtn sbtn-undo" onClick={sorterUndoSplit}>â†© æˆ»ã™ (Z)</button>
            <button className="sbtn sbtn-done" onClick={sorterFinish} disabled={sorterSplits.size === 0}>
              âœ… æŒ¯ã‚Šåˆ†ã‘å®Œäº† ({groups.length}å°)
            </button>
            <button className="sbtn sbtn-cancel" onClick={() => { if(confirm('ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ')) setSorterMode(false); }}>âœ• ä¸­æ­¢</button>
            <div className="sorter-keys">
              <kbd>S</kbd> åŒºåˆ‡ã‚‹ <kbd>B</kbd> BCåˆ‡æ›¿ <kbd>Z</kbd> æˆ»ã™ <kbd>Space</kbd> ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ <kbd>â†â†’</kbd> ç§»å‹•
            </div>
          </div>
          {/* ãƒãƒ¼ã‚³ãƒ¼ãƒ‰æœªæ¤œå‡ºã‚¢ãƒ©ãƒ¼ãƒˆ */}
          {sorterManualBC && sorterBarcodes.size === 0 && (
            <div style={{background:'#fef3c7',borderBottom:'2px solid #f59e0b',padding:'12px 20px',display:'flex',alignItems:'center',gap:12}}>
              <span style={{fontSize:24}}>âš ï¸</span>
              <div>
                <div style={{fontWeight:'bold',color:'#92400e',marginBottom:2}}>ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãŒè‡ªå‹•æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ</div>
                <div style={{color:'#78350f',fontSize:13}}>ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ç”»åƒã‚’é¸æŠã—ã¦ <kbd style={{background:'#fff',border:'1px solid #d1d5db',borderRadius:3,padding:'1px 6px',fontSize:12}}>B</kbd> ã‚­ãƒ¼ã¾ãŸã¯ã€ŒğŸ· BCåˆ‡æ›¿ã€ãƒœã‚¿ãƒ³ã§ãƒãƒ¼ã‚¯ â†’ ã€Œâœ‚ BCã§åŒºåˆ‡ã‚Šç›´ã™ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„</div>
              </div>
            </div>
          )}
          <div style={{display:'flex', flex:1, overflow:'hidden'}}>
            {/* PCä¸€è¦§ã‚µã‚¤ãƒ‰ãƒãƒ¼ */}
            <div className="sorter-sidebar">
              {groups.map((g, i) => (
                <div key={i}
                  className={`sorter-pc-item ${currentGroup === g ? 's-active' : ''}`}
                  onClick={() => setSorterSelected(g.start)}>
                  <span>PC {i+1}</span><span style={{color:'#888',fontSize:12}}>{g.count}æš</span>
                </div>
              ))}
            </div>
            {/* å†™çœŸã‚°ãƒªãƒƒãƒ‰ */}
            <div className="sorter-grid">
              {sorterPhotos.map((photo, i) => {
                const isSplit = sorterSplits.has(i);
                const isNextSplit = sorterSplits.has(i + 1);
                const isSelected = i === sorterSelected;
                // PCåŒºåˆ‡ã‚Šãƒ˜ãƒƒãƒ€ãƒ¼
                const groupIdx = groups.findIndex(g => g.start === i);
                return (
                  <React.Fragment key={photo.id}>
                    {(i === 0 || isSplit) && (
                      <div className="sorter-divider">
                        <span>PC {groupIdx >= 0 ? groupIdx + 1 : '?'}</span>
                        <span>{groups[groupIdx]?.count || 0}æš</span>
                      </div>
                    )}
                    <div
                      className={`sorter-item ${isSelected ? 's-selected' : ''} ${isNextSplit ? 's-split' : ''}`}
                      onClick={() => setSorterSelected(i)}
                      onDoubleClick={() => setSorterPreview(photo.dataUrl)}
                      draggable
                      onDragStart={e => e.dataTransfer.setData('text/plain', i.toString())}
                      onDragOver={e => e.preventDefault()}
                      onDrop={e => {
                        e.preventDefault();
                        const from = parseInt(e.dataTransfer.getData('text/plain'));
                        if (from === i) return;
                        setSorterPhotos(prev => {
                          const arr = [...prev];
                          const [moved] = arr.splice(from, 1);
                          arr.splice(i, 0, moved);
                          return arr;
                        });
                        // splitPointsã‚‚èª¿æ•´
                        setSorterSplits(prev => {
                          const newSplits = new Set();
                          Array.from(prev).sort((a,b)=>a-b).forEach(sp => {
                            let ns = sp;
                            if (from < i) { if(sp > from && sp <= i) ns=sp-1; else if(sp===from) ns=i; }
                            else { if(sp >= i && sp < from) ns=sp+1; else if(sp===from) ns=i; }
                            if(ns > 0 && ns < sorterPhotos.length) newSplits.add(ns);
                          });
                          return newSplits;
                        });
                        // barcodeãƒ•ãƒ©ã‚°ã‚‚èª¿æ•´
                        setSorterBarcodes(prev => {
                          const newBc = new Set();
                          Array.from(prev).forEach(bp => {
                            let nb = bp;
                            if (from < i) { if(bp > from && bp <= i) nb=bp-1; else if(bp===from) nb=i; }
                            else { if(bp >= i && bp < from) nb=bp+1; else if(bp===from) nb=i; }
                            if(nb >= 0 && nb < sorterPhotos.length) newBc.add(nb);
                          });
                          return newBc;
                        });
                        setSorterSelected(i);
                      }}
                    >
                      <img src={photo.dataUrl} loading="lazy"/>
                      <div className="s-label">{photo.filename.replace(/\.[^.]+$/, '').replace('IMG_', '')}</div>
                      {sorterBarcodes.has(i) && <div style={{position:'absolute',top:2,left:2,background:'#ef4444',color:'#fff',fontSize:10,padding:'1px 4px',borderRadius:3,fontWeight:'bold'}}>BC</div>}
                    </div>
                  </React.Fragment>
                );
              })}
            </div>
          </div>

          {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
          {sorterPreview && (
            <div className="sorter-preview active" onClick={() => setSorterPreview(null)}>
              <img src={sorterPreview}/>
            </div>
          )}
        </div>
        );
      })()}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
